[{"title":"几种语言实现socket例子","date":"2018-01-21T12:23:51.000Z","path":"2018/01/21/几种语言实现socket例子/","text":"参考： windows环境下用c++实现socket编 linux下C/C++网络编程基本：socket实现tcp和udp的例子 Windows Socket TCP/UDP写在前面参考《Python核心编程》中关于TCP、UDP介绍的例子。不管用什么语言，在什么系统下，万变不离其宗，都是类似于下面伪代码的逻辑。TCP服务器123456789ss = socket() # 创建服务器套接字ss.bind() # 套接字与地址绑定ss.listen() # 监听连接inf_loop: # 服务器无限循环 cs = ss.accept() # 接收客户端连接 comm_loop: # 通信循环 cs.recv/cs.send() # 对话（接收/发送） cs.close() # 关闭客户端套接字ss.close() # 关闭服务器套接字（可选） TCP客户端12345cs = socket() # 创建客户端套接字cs.connect() # 尝试连接服务器comm_loop: # 通信循环 cs.send()/cs.recv() # 对话（发送/接收）cs.close() # 关闭客户端套接字 UDP服务器12345ss = socket() # 创建服务器套接字ss.bind() # 绑定服务器套接字inf_loop: # 服务器无限循环 cs = ss.recvfrom()/ss.sendto() # 对话（接收/发送）ss.close() # 关闭服务器套接字 UDP客户端1234cs = socket() # 创建客户端套接字comm_loop: # 通信循环 cs.sendto()/cs.recvfrom() # 对话（发送/接收）cs.close() # 关闭客户端套接字 下面实现的例子功能都是 客户端发送一条消息之后 服务端在原消息基础上增加时间戳并返回给客户端 客户端发送#之后退出 TCPwindows C/C++服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#include &lt;time.h&gt;# pragma comment(lib, \"ws2_32.lib\")# define BUFFSIZE 255const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;int main()&#123; //step-1:加载套接字库（WSAStartup()）; WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"init socket fail\\n\"); exit(-1); &#125; //step-2:创建服务器套接字(socket()) SOCKET serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(serverSocket == INVALID_SOCKET) &#123; printf(\"socket error!\\n\"); exit(-1); &#125; sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(sockaddr)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = INADDR_ANY; //step-3:绑定套接字到一个IP地址和一个端口上(bind()) //这里绑定到任意的ip和固定的8888端口 if(bind(serverSocket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(\"bind error\\n\"); closesocket(serverSocket); exit(-1); &#125; //step-4:将套接字设置为监听模式等待连接请求(listen()) if(listen(serverSocket, 5) == SOCKET_ERROR) &#123; printf(\"listen error\\n\"); exit(-1); &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) //服务器无限循环 &#123; printf(\"waiting for connect...\\n\"); //step-5:等待连接请求，并返回对应于此连接的socket(accept()) sockaddr_in remoteAddr; int addrLen = sizeof(remoteAddr); SOCKET clientSocket = accept(serverSocket, (SOCKADDR*)&amp;remoteAddr, &amp;addrLen); if(clientSocket == INVALID_SOCKET) &#123; printf(\"accept error\\n\"); continue; &#125; printf(\"receive a connect :%s\\n\", inet_ntoa(remoteAddr.sin_addr)); while(true) //对话循环 &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); //step-6:等待接收客户端发送过来的数据（recv()） int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len &gt; 0) &#123; recvData[len] = '\\0'; //收到#则退出本次对话 if(strcmp(recvData,\"#\") == 0) &#123; printf(\"recv exit symbol, exit...\\n\"); break; &#125; printf(\"%s\\n\", recvData); &#125; else &#123; printf(\"recv data fail\\n\"); break; &#125; const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); //step-7:向客户端发送响应（send()） if(send(clientSocket, sendData, strlen(sendData), 0) == SOCKET_ERROR) &#123; printf(\"send data fail\\n\"); break; &#125; &#125; //step-8:关闭此次连接请求的socket closesocket(clientSocket); &#125; //step-9：关闭服务端socket closesocket(serverSocket); //step-10：关闭加载的socket库 WSACleanup(); return 0;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#pragma comment(lib, \"ws2_32.lib\")#define BUFFSIZE 255int main()&#123; WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; //step-1:加载套接字库 if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"socket start fail\\n\"); exit(-1); &#125; //step-2:创建套接字 SOCKET clientSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(clientSocket == INVALID_SOCKET) &#123; printf(\"invalid socket\\n\"); exit(-1); &#125; sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(sockaddr_in)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); //step-3:向服务端发送连接请求 if(connect(clientSocket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(\"connect error\\n\"); closesocket(clientSocket); exit(-1); &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) &#123; memset(sendData, 0, BUFFSIZE); memset(recvData, 0, BUFFSIZE); scanf(\"%s\", &amp;sendData); //step-4:向服务端发送数据 if(send(clientSocket, sendData, strlen(sendData), 0) == SOCKET_ERROR) &#123; printf(\"send data fail\\n\"); exit(-1); &#125; //输入#则退出 if(strcmp(sendData, \"#\") == 0) &#123; break; &#125; //step-5:收到服务器的响应 int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; //step-6:关闭本次连接socket closesocket(clientSocket); //step-7:关闭加载的套接字库 WSACleanup(); return 0;&#125; linux C/C++服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;#define BUFFSIZE 255int main()&#123; //step-1：创建服务器端套接字 int serverSocket = socket(AF_INET, SOCK_STREAM, 0); if(serverSocket &lt; 0) &#123; printf(\"invalid socket\\n\"); return -1; &#125; struct sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(serAddr)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.s_addr = INADDR_ANY; //step-2:绑定套接字到一个地址 if(bind(serverSocket, (struct sockaddr*)&amp;serAddr, sizeof(serAddr)) &lt; 0) &#123; printf(\"bind error\\n\"); return -1; &#125; //step-3:将套接字设置为监听模式等待连接请求 if(listen(serverSocket, 5) &lt; 0) &#123; printf(\"listen error\\n\"); return -1; &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) &#123; printf(\"waiting for connect...\\n\"); struct sockaddr_in remoteAddr; int addrLen = sizeof(struct sockaddr_in); //step-4:等待连接请求，并返回对应于此连接的socket int clientSocket = accept(serverSocket, (struct sockaddr*)&amp;remoteAddr, (socklen_t*)&amp;addrLen); if(clientSocket &lt; 0) &#123; perror(\"accept error\"); continue; &#125; printf(\"receive a connect :%s\\n\", inet_ntoa(remoteAddr.sin_addr)); while(true) &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); //step-5:等待接收客户端发送过来的数据 int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len&gt; 0) &#123; recvData[len] = '\\0'; //收到#则退出本次对话 if(strcmp(recvData,\"#\") == 0) &#123; printf(\"recv exit symbol, exit...\\n\"); break; &#125; printf(\"%s\\n\", recvData); &#125; else &#123; printf(\"recv data fail\\n\"); break; &#125; const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); //step-6:向客户端发送响应（send()） if(send(clientSocket, sendData, strlen(sendData), 0) &lt; 0) &#123; printf(\"send data fail\\n\"); break; &#125; &#125; //step-7:关闭此次连接请求的socket close(clientSocket); &#125; //step-8：关闭服务端socket close(serverSocket); return 0;&#125; 客户端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#define BUFFSIZE 255int main()&#123; //step-1:创建套接字 int clientSocket = socket(AF_INET, SOCK_STREAM, 0); if(clientSocket &lt; 0) &#123; printf(\"invalid socket\\n\"); return -1; &#125; sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(serAddr)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); //step-2:向服务端发送连接请求 if(connect(clientSocket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) &lt; 0) &#123; printf(\"connect error\\n\"); close(clientSocket); return -1; &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) &#123; memset(sendData, 0, BUFFSIZE); memset(recvData, 0, BUFFSIZE); scanf(\"%s\", &amp;sendData); //step-3:向服务端发送数据 if(send(clientSocket, sendData, strlen(sendData), 0) &lt; 0) &#123; printf(\"send data fail\\n\"); return -1; &#125; //输入#则退出 if(strcmp(sendData, \"#\") == 0) &#123; break; &#125; //step-4:收到服务器的响应 int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; //step-5:关闭本次连接socket close(clientSocket); return 0;&#125; Python服务端12345678910111213141516171819202122232425262728#!/usr/bin/env python3from socket import *from time import ctimeHOST = ''PORT = 8888BUFFSIZE = 1024ADDR = (HOST, PORT)serSock = socket(AF_INET, SOCK_STREAM)serSock.bind(ADDR)serSock.listen(5)while True: print('waiting for connection...') cliSock, addr = serSock.accept() print('...connected from:', addr) while True: data = cliSock.recv(BUFFSIZE) print(data) if data == b'#': break cliSock.send(b'[%s] %s' % (bytes(ctime(), 'utf-8'), data)) cliSock.close()serSock.close() 客户端123456789101112131415161718192021#!/usr/bin/env python3from socket import *HOST = '127.0.0.1'PORT = 8888ADDR = (HOST, PORT)BUFFSIZE = 1024cliSock = socket(AF_INET, SOCK_STREAM)cliSock.connect(ADDR)while True: data = input('&gt;') cliSock.send(bytes(data, 'utf-8')) if data == '#': break data = cliSock.recv(BUFFSIZE); print(data)cliSock.close() udpwindows C/C++服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#include &lt;time.h&gt;#pragma comment(lib, \"ws2_32.lib\")#define BUFFSIZE 255const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;int main()&#123; WSADATA wsaData; WORD sockVersion = MAKEWORD(2, 2); if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"init socket fail\\n\"); exit(-1); &#125; SOCKET serSoket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); if(serSoket == INVALID_SOCKET) &#123; printf(\"socket error\\n\"); exit(-1); &#125; sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(serSoket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(\"bind error\\n\"); closesocket(serSoket); exit(-1); &#125; char recvData[BUFFSIZE]; char sendData[BUFFSIZE]; while(true) &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); printf(\"waiting for message...\\n\"); sockaddr_in remoteAddr; int nAddrLen = sizeof(remoteAddr); int len = recvfrom(serSoket, recvData, BUFFSIZE, 0, (sockaddr*)&amp;remoteAddr, &amp;nAddrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); sendto(serSoket, sendData, strlen(sendData), 0, (sockaddr*)&amp;remoteAddr, nAddrLen); &#125; &#125; closesocket(serSoket); WSACleanup(); return 0;&#125; 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#pragma comment(lib, \"ws2_32.lib\")#define BUFFSIZE 255int main()&#123; WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"init socket fail\\n\"); exit(-1); &#125; SOCKET sClient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8888); sin.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); int addrLen = sizeof(sockaddr_in); char sendData[BUFFSIZE]; char recvData[BUFFSIZE]; while(true) &#123; scanf(\"%s\", &amp;sendData); if(strcmp(sendData, \"#\") == 0) &#123; printf(\"exit...\\n\"); break; &#125; sendto(sClient, sendData, strlen(sendData), 0, (sockaddr*)&amp;sin, addrLen); int len = recvfrom(sClient, recvData, BUFFSIZE, 0, (sockaddr*)&amp;sin, &amp;addrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; closesocket(sClient); WSACleanup(); return 0;&#125; linux C/C++服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#define BUFFSIZE 255const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;int main()&#123; int serSoket = socket(AF_INET, SOCK_DGRAM, 0); if(serSoket &lt; 0) &#123; printf(\"socket error\\n\"); return -1; &#125; sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.s_addr = INADDR_ANY; if(bind(serSoket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) &lt; 0) &#123; printf(\"bind error\\n\"); close(serSoket); return -1; &#125; char recvData[BUFFSIZE]; char sendData[BUFFSIZE]; while(true) &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); printf(\"waiting for message...\\n\"); sockaddr_in remoteAddr; int addrLen = sizeof(remoteAddr); int len = recvfrom(serSoket, recvData, BUFFSIZE, 0, (sockaddr*)&amp;remoteAddr, (socklen_t*)&amp;addrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); sendto(serSoket, sendData, strlen(sendData), 0, (sockaddr*)&amp;remoteAddr, addrLen); &#125; &#125; close(serSoket); return 0;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#define BUFFSIZE 255int main()&#123; int sClient = socket(AF_INET, SOCK_DGRAM, 0); sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8888); sin.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); int addrLen = sizeof(sockaddr_in); char sendData[BUFFSIZE]; char recvData[BUFFSIZE]; while(true) &#123; scanf(\"%s\", &amp;sendData); if(strcmp(sendData, \"#\") == 0) &#123; printf(\"exit...\\n\"); break; &#125; sendto(sClient, sendData, strlen(sendData), 0, (sockaddr*)&amp;sin, addrLen); int len = recvfrom(sClient, recvData, BUFFSIZE, 0, (sockaddr*)&amp;sin, (socklen_t*)&amp;addrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; close(sClient); return 0;&#125; Python服务端123456789101112131415161718192021#!/usr/bin/env python3from socket import *from time import ctimeHOST = ''PORT = 8888ADDR = (HOST, PORT)BUFFSIZE = 1024serSock = socket(AF_INET, SOCK_DGRAM)serSock.bind(ADDR)while True: print('waiting for message...') data, addr = serSock.recvfrom(BUFFSIZE) serSock.sendto(b'[%s] %s' % (bytes(ctime(), 'utf-8'), data), addr) print('...received from and returned to:', addr)serSock.close() 客户端12345678910111213141516171819#!/usr/bin/env python3from socket import *HOST = '127.0.0.1'PORT = 8888ADDR = (HOST, PORT)BUFFSIZE = 1024cliSock = socket(AF_INET, SOCK_DGRAM)while True: data = input('&gt;') if data == \"#\": break cliSock.sendto(bytes(data, 'utf-8'), ADDR) data, addr = cliSock.recvfrom(BUFFSIZE) print(data)cliSock.close() websocket参考： 非常有趣的理解websocket HTML5 WebSocket 说明 是什么：HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议 什么用：解决http轮询等的资源消耗，建立连接后，服务器和客户端可以快速地互相传输数据 怎么用：参考下面的例子 例子 服务端各个语言都有实现，仅Python就发现了两种实现1、pywebsocket2、python-websocket-server 打个标记，后面有时间啃一下 客户端比较简单，上面的例子都有","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"二叉树C++实现","date":"2018-01-15T11:23:51.000Z","path":"2018/01/15/二叉树C++实现/","text":"类声明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;iostream&gt;template &lt;class T&gt;class BinaryTree&#123;public: enum ORDER &#123; LEVELORDER, //层次 PREORDER, //先序 &#125;; BinaryTree() : root_(nullptr), size_(0) &#123;&#125; //通过数组构造，其中数组里的值默认按照层次优先排列; //nullVal表示为空的值，order表示传入数组的排列顺序 //下面以T为int，nullVal为-1时举例 // 3 // / \\ // 2 7 // \\ / \\ // 4 5 1 //要构造这样一个二叉树，则各种顺序下需要传入的数组为 //层次：&#123;3, 2, 7, -1, 4, 5, 1&#125; //先序：&#123;3, 2, -1, 4, -1, -1, 7, 5, -1, -1, 1&#125; //目前只想到这两种初始化的方式。 //因为必须先构造父，再构造左右孩子，所以应该只能先序吧 BinaryTree(const std::vector&lt;T&gt; &amp;array, const T &amp;nullVal, ORDER order=LEVELORDER); //前序遍历 std::vector&lt;T&gt; preOrder(bool useRecursive=true) const; //中序遍历 std::vector&lt;T&gt; inOrder(bool useRecursive=true) const; //后序遍历 std::vector&lt;T&gt; postOrder(bool useRecursive=true) const; //层次遍历 std::vector&lt;T&gt; levelOrder() const; ~BinaryTree();private: struct Node &#123; T data_; Node *lchild_; Node *rchild_; Node(const T&amp; data) : data_(data), lchild_(nullptr), rchild_(nullptr) &#123;std::cout &lt;&lt; \"Node constructor: \" &lt;&lt; data_ &lt;&lt; std::endl;&#125; ~Node() &#123;std::cout &lt;&lt; \"Node destructor: \" &lt;&lt; data_ &lt;&lt; std::endl; &#125; &#125;; void levelOrderInit(const std::vector&lt;T&gt; &amp;array, const T &amp;nullVal); void preOrderInit(const std::vector&lt;T&gt; &amp;array, Node *&amp;root, int &amp;index, const T &amp;nullVal); //xxx_recursive表示递归方式遍历；xxx_loop表示循环方式遍历 void preOrder_recursive(Node *, std::vector&lt;T&gt; &amp;) const; void preOrder_loop(std::vector&lt;T&gt; &amp;) const; void inOrder_recursive(Node *, std::vector&lt;T&gt; &amp;) const; void inOrder_loop(std::vector&lt;T&gt; &amp;) const; void postOrder_recursive(Node *, std::vector&lt;T&gt; &amp;) const; void postOrder_loop(std::vector&lt;T&gt; &amp;) const; void clearTree(Node *node); Node *root_; int size_;&#125;; 构造构造函数1234567891011121314151617181920212223template&lt;class T&gt;BinaryTree&lt;T&gt;::BinaryTree(const std::vector&lt;T&gt; &amp;array, const T&amp; nullVal, ORDER order)&#123; size_ = array.size(); if(!size_) &#123; root_ = nullptr; return; &#125; int index = 0; switch(order) &#123; case LEVELORDER: levelOrderInit(array, nullVal); break; case PREORDER: preOrderInit(array, root_, index, nullVal); break; default: break; &#125;&#125; 层次数组初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445template&lt;class T&gt;void BinaryTree&lt;T&gt;::levelOrderInit(const std::vector&lt;T&gt; &amp;array, const T&amp; nullVal)&#123; root_ = new Node(array[0]); std::queue&lt;Node*&gt; q; q.push(root_); int start = 1; //每一层级节点的个（第二层有2个） int levelNums = 2; while(start &lt; size_) &#123; for(int i = start; i &lt; (start + levelNums) &amp;&amp; i &lt; size_; i += 2) &#123; if(q.empty()) &#123; printf(\"input array not valid\\n\"); return; &#125; //从左到右依次取出上一层的父节点 Node *node = q.front(); q.pop(); const T&amp; lVal = array.at(i); if(lVal != nullVal) &#123; Node *lchild = new Node(lVal); node-&gt;lchild_ = lchild; q.push(lchild); &#125; //最后一个右孩子可能没给出，导致i+1越界，这里判断 if(i + 1 &gt;= size_) break; const T&amp; rVal = array.at(i + 1); if(rVal != nullVal) &#123; Node *rchild = new Node(rVal); node-&gt;rchild_ = rchild; q.push(rchild); &#125; &#125; start += levelNums; //每层节点数都是上一层的两倍，即使是无效值，也必须用nullVal给出 levelNums *= 2; &#125;&#125; 先序数组初始化123456789101112131415161718template &lt;class T&gt;void BinaryTree&lt;T&gt;::preOrderInit(const std::vector&lt;T&gt; &amp;array, Node *&amp;root, int &amp;index, const T &amp;nullVal)&#123; if(index &lt; size_) &#123; const T &amp;curData = array.at(index); if(curData != nullVal) &#123; //构造父 root = new Node(curData); //递归构造左孩子 preOrderInit(array, root-&gt;lchild_, ++index, nullVal); //递归构造右孩子 preOrderInit(array, root-&gt;rchild_, ++index, nullVal); &#125; &#125;&#125; 析构1234567891011121314151617//后序遍历递归删除所有节点//这里应该只能使用后序吧，毕竟要把左右孩子删除，才能删除父嘛template &lt;class T&gt;void BinaryTree&lt;T&gt;::clearTree(Node *node)&#123; if(!node) return; clearTree(node-&gt;lchild_); clearTree(node-&gt;rchild_); delete node;&#125;template &lt;class T&gt;BinaryTree&lt;T&gt;::~BinaryTree()&#123; clearTree(root_);&#125; 遍历下面的几种遍历方式都分了递归和循环两种方式。显然递归方式更简单清晰； 但是有些公司是不允许使用递归的，这样就只能使用循环啦 先序遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::preOrder(bool useRecursive) const&#123; std::vector&lt;T&gt; result; if(useRecursive) preOrder_recursive(root_, result); else preOrder_loop(result); return result;&#125;//递归先序遍历，先访问父，再访问左孩子，再访问右孩子template &lt;class T&gt;void BinaryTree&lt;T&gt;::preOrder_recursive(Node *root, std::vector&lt;T&gt; &amp;result) const&#123; if(!root) return; result.push_back(root-&gt;data_); preOrder_recursive(root-&gt;lchild_, result); preOrder_recursive(root-&gt;rchild_, result);&#125;//循环先序遍历template &lt;class T&gt;void BinaryTree&lt;T&gt;::preOrder_loop(std::vector&lt;T&gt; &amp;result) const&#123; Node *root = root_; std::stack&lt;Node*&gt; stk; while(root || !stk.empty()) &#123; if(root) &#123; result.push_back(root-&gt;data_); stk.push(root); root = root-&gt;lchild_; &#125; else &#123; root = stk.top()-&gt;rchild_; stk.pop(); &#125; &#125;&#125; 中序遍历12345678910111213141516171819202122232425262728293031323334353637383940414243template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::inOrder(bool useRecursive) const&#123; std::vector&lt;T&gt; result; if(useRecursive) inOrder_recursive(root_, result); else inOrder_loop(result); return result;&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::inOrder_recursive(Node *root, std::vector&lt;T&gt; &amp;result) const&#123; if(!root) return; inOrder_recursive(root-&gt;lchild_, result); result.push_back(root-&gt;data_); inOrder_recursive(root-&gt;rchild_, result);&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::inOrder_loop(std::vector&lt;T&gt; &amp;result) const&#123; Node *root = root_; std::stack&lt;Node*&gt; stk; while(root || !stk.empty()) &#123; if(root) &#123; stk.push(root); root = root-&gt;lchild_; &#125; else &#123; Node *tmp = stk.top(); stk.pop(); result.push_back(tmp-&gt;data_); root = tmp-&gt;rchild_; &#125; &#125;&#125; 后序遍历后序遍历的非递归有点难,参考 二叉树递归与非递归遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::postOrder(bool useRecursive) const&#123; std::vector&lt;T&gt; result; if(useRecursive) postOrder_recursive(root_, result); else postOrder_loop(result); return result;&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::postOrder_recursive(Node *root, std::vector&lt;T&gt; &amp;result) const&#123; if(!root) return; postOrder_recursive(root-&gt;lchild_, result); postOrder_recursive(root-&gt;rchild_, result); result.push_back(root-&gt;data_);&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::postOrder_loop(std::vector&lt;T&gt; &amp;result) const&#123; std::stack&lt;Node*&gt; stk; stk.push(root_); Node *cur = nullptr, *pre = nullptr; while(!stk.empty()) &#123; cur = stk.top(); if((!cur-&gt;lchild_ &amp;&amp; !cur-&gt;rchild_) || (pre &amp;&amp; (pre == cur-&gt;lchild_ || pre == cur-&gt;rchild_))) &#123; result.push_back(cur-&gt;data_); stk.pop(); pre = cur; &#125; else &#123; if(cur-&gt;rchild_) stk.push(cur-&gt;rchild_); if(cur-&gt;lchild_) stk.push(cur-&gt;lchild_); &#125; &#125;&#125; 层次遍历123456789101112131415161718template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::levelOrder() const&#123; std::vector&lt;T&gt; result; std::queue&lt;Node*&gt; q; q.push(root_); while(!q.empty()) &#123; Node *t = q.front(); q.pop(); result.push_back(t-&gt;data_); if(t-&gt;lchild_) q.push(t-&gt;lchild_); if(t-&gt;rchild_) q.push(t-&gt;rchild_); &#125; return result;&#125; 测试1234567891011121314151617181920212223242526template &lt;class T&gt;void test(char *desc, std::vector&lt;T&gt; &amp;array)&#123; printf(\"%s\", desc); for(int val : array) printf(\"%d \", val); printf(\"\\n\");&#125;int main()&#123; std::vector&lt;int&gt; array&#123;3, 2, 7, -1, 4, 5, 1&#125;; BinaryTree&lt;int&gt; tree(array, -1); //std::vector&lt;int&gt; array&#123;3, 2, -1, 4, -1, -1, 7, 5, -1, -1, 1&#125;; //BinaryTree&lt;int&gt; tree(array, -1, BinaryTree&lt;int&gt;::PREORDER); std::vector&lt;int&gt; result; test(\"pre order recursive: \", tree.preOrder()); //3 2 4 7 5 1 test(\"pre order loop: \", tree.preOrder(false)); //3 2 4 7 5 1 test(\"in order recursive: \", tree.inOrder()); //2 4 3 5 7 1 test(\"in order loop: \", tree.inOrder(false)); //2 4 3 5 7 1 test(\"post order recursive: \", tree.postOrder()); //4 2 5 1 7 3 test(\"post order loop: \", tree.postOrder(false)); //4 2 5 1 7 3 test(\"level order: \", tree.levelOrder()); //3 2 7 4 5 1 return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"C++中常见数据结构的实现","date":"2018-01-05T12:23:51.000Z","path":"2018/01/05/C++中常见数据结构的实现/","text":"vector说明类似于基本数组，但是内存的回收在类内进行 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106template &lt;class T&gt;class Vector&#123;public: explicit Vector(int size = 0) : size_(size), capacity_(size + SPACE_CAPACITY), array_(new T[capacity_]) &#123; &#125; Vector(const Vector &amp;rhs) :array_(nullptr) &#123; operator=(rhs); &#125; ~Vector() &#123; if(array_) delete []array_; &#125; Vector &amp;operator=(const Vector &amp;rhs) &#123; //判断是否自己赋给自己 if(this != &amp;rhs) &#123; if(array_) delete []array_; size_ = rhs.size_; capacity_ = rhs.capacity_; array_ = new T[capacity_]; for(int i = 0; i &lt; size_; ++i) array_[i] = rhs.array_[i]; //这里用memcpy应该也可以吧 //memcpy(array_, rhs.array_, size_*sizeof(T)) &#125; return *this; &#125; void resize(int newSize) &#123; if(newSize &gt; capacity_) reverse(newSize * 2 + 1); size_ = newSize; &#125; void reverse(int newCapacity) &#123; if(newCapacity &lt; size_) return; T *newArray = new T[newCapacity]; for(int i = 0; i &lt; size_; ++i) newArray[i] = array_[i]; capacity_ = newCapacity; delete []array_; array_ = newArray; &#125; T &amp;operator[](int index) &#123; return array_[index]; &#125; //这里两个[]函数分别返回引用和常引用 const T &amp;operator[](int index) const &#123; return array_[index]; &#125; bool empty() &#123; return size_ == 0; &#125; int size()&#123; return size_;&#125; int capacity() &#123; return capacity_;&#125; void push_back(const T &amp;data) &#123; if(size_ == capacity_) reverse(2 * capacity_ + 1); array_[size_++] = data; &#125; void pop_back()&#123; size_--; &#125; const T &amp;back() const &#123; return array_[size_ - 1]; &#125; typedef T* iterator; typedef const T* const_iterator; iterator begin() &#123; return &amp;array_[0];&#125; const_iterator begin() const &#123; return &amp;array_[0];&#125; iterator end() &#123; return &amp;array_[size_]; &#125; const_iterator end() const &#123; return &amp;array_[size_]; &#125; private: enum &#123; SPACE_CAPACITY = 16 &#125;; T *array_; int size_; int capacity_;&#125;; 链表说明此为双向链表的实现 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193template &lt;class T&gt;class List&#123;private: struct Node &#123; Node(const T &amp;data = T(), Node *p=nullptr, Node *q=nullptr) : data_(data), prev_(p), next_(q) &#123;&#125; T data_; Node *prev_; Node *next_; &#125;;public: class const_iterator &#123; public: const_iterator()&#123;&#125; const T &amp;operator*() const &#123; return retrieve(); &#125; //前置++itr const_iterator &amp;operator++() &#123; currentPos_ = currentPos_-&gt;next_; return *this; &#125; //后置itr++ //注意这里不能返回引用了,因为函数返回后old变量已经不存在 const_iterator operator++(int) &#123; const_iterator old = *this; ++(*this); return old; &#125; bool operator==(const const_iterator &amp;rhs) const &#123; return currentPos_ == rhs.currentPos_;&#125; bool operator!=(const const_iterator &amp;rhs) const &#123; return !(*this == rhs);&#125; protected: const_iterator(Node *pos) : currentPos_(pos) &#123;&#125; T &amp;retrieve() const &#123; return currentPos_-&gt;data_; &#125; Node *currentPos_; friend class List&lt;T&gt;; &#125;; class iterator : public const_iterator &#123; public: iterator()&#123;&#125; T &amp;operator*() &#123; return retrieve(); &#125; const T &amp;operator*() const &#123; return const_iterator::operator*();&#125; iterator &amp;operator++() &#123; currentPos_ = currentPos_-&gt;next_; return *this; &#125; iterator operator++(int) &#123; iterator old = *this; ++(*this); return old; &#125; protected: iterator(Node *pos) : const_iterator(pos) &#123;&#125; friend class List&lt;T&gt;; &#125;;public: List() &#123; init(); &#125; List(const List &amp;rhs) &#123; init(); *this = rhs; &#125; ~List() &#123; clear(); delete header_; delete tail_; &#125; const List &amp;operator=(const List &amp;rhs) &#123; if(this != &amp;rhs) &#123; clear(); for(auto itr = rhs.begin(); itr != rhs.end(); ++itr) push_back(*itr); &#125; return *this; &#125; iterator begin() &#123; return iterator(header_-&gt;next_); &#125; const_iterator begin() const &#123; return const_iterator(header_-&gt;next_); &#125; iterator end() &#123; return iterator(tail_); &#125; const_iterator end() const &#123; return const_iterator(tail_); &#125; int size() &#123; return size_; &#125; bool empty() &#123; return size_ == 0; &#125; void clear() &#123; while(size_) pop_front(); &#125; T &amp;front() &#123; return *begin(); &#125; const T &amp;front() const &#123; return *begin(); &#125; T &amp;back() &#123; return *--end(); &#125; const T &amp;back() const &#123; return *--end(); &#125; void push_front(const T &amp;data) &#123; insert(begin(), data); &#125; void push_back(const T &amp;data) &#123; insert(end(), data);&#125; void pop_front() &#123; erase(begin()); &#125; void pop_back() &#123; erase(--end()); &#125; //insert data before itr iterator insert(iterator itr, const T &amp;data) &#123; Node *p = itr.currentPos_; ++size_; Node *newNode = new Node(data, p-&gt;prev_, p); p-&gt;prev_-&gt;next_ = newNode; p-&gt;prev_ = newNode; return iterator(newNode); //或者简写如下 //return iterator(p-&gt;prev_ = p-&gt;prev_-&gt;next_ = new Node(data, p-&gt;prev_, p)) &#125; iterator erase(iterator itr) &#123; if(itr == end()) return end(); Node *p = itr.currentPos_; iterator retVal(p-&gt;next_); --size_; p-&gt;prev_-&gt;next_ = p-&gt;next_; p-&gt;next_-&gt;prev_ = p-&gt;prev_; delete p; return retVal; &#125; iterator erase(iterator from, iterator to) &#123; for(auto itr = begin; i != to;) itr = erase(itr); return to; &#125; private: Node *header_; Node *tail_; int size_; void init() &#123; header_ = new Node; tail_ = new Node; header_-&gt;next_ = tail_; tail_-&gt;prev_ = header_; size_ = 0; &#125;&#125;; stack说明只能通过top元素操作，基本操作是push(进栈)和pop(出栈)。遵循LIFO(后进先出)原则 实现分别可以通过链表和数组实现，较简单书上没有实现。这里借助之前的Vector类简单实现一下。12345678910111213141516171819202122232425262728293031template &lt;class T&gt;class Stack&#123;public: Stack()&#123; topOfArray_ = -1; &#125; //因为Vector和int都为数值类型，所以理论上析构函数，复制构造函数， //operator=都可以使用默认的，无需显示写出 const T &amp;top() &#123; return stack_[topOfArray_];&#125; void push(const T&amp; data) &#123; stack_[++topOfArray_] = data; &#125; const T&amp; pop() &#123; return stack_[topOfArray_--]; &#125; bool empty() &#123; return topOfArray_ == -1;&#125;private: Vector&lt;T&gt; stack_; int topOfArray_;&#125;;int main()&#123; Stack&lt;int&gt; stack; stack.push(5); stack.push(10); stack.push(3); printf(\"%d\\n\", stack.top()); //3 while(!stack.empty()) printf(\"%d \", stack.pop()); //3 10 5 return 0;&#125; 应用检查代码中的平衡符号如[()]合法，而[(])非法。检查方法如下– 初始化一个空栈，读取字符至文件尾。– 若字符是开放符号，则压栈– 若字符是封闭符号，则如果栈为空则报错，若果栈非空则弹出栈元素，如果不是对应的开放符号，则报错– 如果到文件尾，且栈非空则报错 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//检查是否为一组开闭符号bool isPairSymbol(char left, char right)&#123; return (left == '(' &amp;&amp; right == ')') || (left == '&#123;' &amp;&amp; right == '&#125;') || (left == '&lt;' &amp;&amp; right == '&gt;') || (left == '[' &amp;&amp; right == ']');&#125;//是否开放符号bool isOpenSymbol(char ch)&#123; return ch == '(' || ch == '&#123;' || ch == '&lt;' || ch == '[';&#125;//是否封闭符号bool isCloseSymbol(char ch)&#123; return ch == ')' || ch == '&#125;' || ch == '&gt;' || ch == ']';&#125;//函数功能：检查平衡符号是否合法//入参str：包含平衡符号的字符串//返回值：合法为true，非法为falsebool checkEquSymbol(std::string str)&#123; Stack&lt;char&gt; stack; for(int i = 0; i &lt; str.size(); ++i) &#123; char ch = str[i]; if(isOpenSymbol(ch)) stack.push(ch); else if(isCloseSymbol(ch)) &#123; if(stack.empty()) return false; else if(!isPairSymbol(stack.pop(), ch)) return false; &#125; &#125; return stack.empty();&#125;int main()&#123; printf(\"%d\\n\", checkEquSymbol(\"2esvdf&#123;&#125;&lt;^&amp;&gt;\")); //1 printf(\"%d\\n\", checkEquSymbol(\"3&lt;[&#123;()&#125;]&gt;\")); //1 printf(\"%d\\n\", checkEquSymbol(\"2&lt;12&lt;&gt;\")); //0 printf(\"%d\\n\", checkEquSymbol(\"2&gt;\")); //0 return 0;&#125; 后缀表达式比如一个计算表达式为位[4+5+62]可转换为如下后缀（逆波兰)记法[4 5+6 2+] 求值过程如下： 遇到一个数时压入栈 遇到操作符时从栈中弹出两个数，求得结果再入栈 为简单起见，假设所有数字都是一位，且只有+-*/四则运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//通过操作符返回结果值（简单起见这里就不用工厂模式了）double calc(int num1, int num2, char op)&#123; switch(op) &#123; case '+': return num1 + num2; case '-': return num1 - num2; case '*': return num1 * num2; case '/': return num1 / num2; default: return 0; &#125;&#125;bool isOperator(char ch)&#123; return ch == '+' || ch == '-' || ch == '*' || ch == '/';&#125;//函数功能：计算表达式的数值结果，其中表达式为逆波兰记法，数字为1位int calcExp(std::string str)&#123; Stack&lt;double&gt; stack; for(int i = 0; i &lt; str.size(); ++i) &#123; char ch = str[i]; if(isOperator(ch)) &#123; //这里应当判空 double num1 = stack.pop(), num2 = stack.pop(); stack.push(calc(num1, num2, ch)); &#125; else stack.push(ch - '0'); &#125; return stack.pop();&#125;int main()&#123; printf(\"%d\\n\", calcExp(\"6523+8*+3+*\")); //288 return 0;&#125; 从中缀转换为后缀表达式作用：将一个标准形式的（中缀）表达式，转换成上面提到的后缀表达式 为了简化问题假设只包含+*()三种操作符 求值过程如下 读到一个操作数时立即输出 读到一个右括号’)’时，弹出栈元素，直到遇到一个对应的左括号。且左括号不输出 读到其他字符’+’,’*’,’(‘时，弹出栈元素直到发现优先级更低的；并且不能弹出’(‘元素。弹出工作完成之后，再将当前操作符入栈 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//运算符的优先级int priority(char op)&#123; switch(op) &#123; case '+': return 1; case '*': return 2; case '(': case ')': return 999; default: return 0; &#125;&#125;//函数功能：中缀表达式到后缀表达式//入参str：中缀表达式，其中只包含+*()三种运算符，其他数字用字母代替void infixToPostfix(std::string str)&#123; Stack&lt;char&gt; stack; char op; for(int i = 0; i &lt; str.size(); ++i) &#123; char ch = str[i]; if(ch == '+' || ch == '*' || ch == '(') &#123; //1、栈非空 //2、栈顶元素不是'(' //3、栈顶元素优先级不小于当前元素优先级 while(!stack.empty() &amp;&amp; stack.top() != '(' &amp;&amp; priority(stack.top()) &gt;= priority(ch)) printf(\"%c\", stack.pop()); //当前操作符入栈 stack.push(ch); &#125; else if(ch == ')') &#123; while(!stack.empty()) &#123; //出栈直到遇到'('，且'('不输出 op = stack.pop(); if(op != '(') printf(\"%c\", op); else break; &#125; &#125; else &#123; //其他即为操作数，立即输出 printf(\"%c\", ch); &#125; &#125; while(!stack.empty()) printf(\"%c\", stack.pop());&#125;int main()&#123; infixToPostfix(\"a+b*c+(d*e+f)*g\"); //abc*+de*f+g*+ return 0;&#125; 函数调用queue说明队列（queue）也是一种表，基本操作有 enqueue(入队)，在表的末端（队尾）插入一个元素 dequeue(出队)，删除并返回表的开头（队头）元素 实现链表实现较简单1234567891011121314151617181920212223242526template &lt;class T&gt;class Queue&#123;public: Queue()&#123;&#125; void enqueue(const T &amp;data) &#123; queue_.push_back(data); &#125; const T &amp;dequeue() &#123; const T &amp;data = queue_.front(); queue_.pop_front(); return data; &#125; bool empty()&#123; return queue_.empty(); &#125;private: List&lt;T&gt; queue_;&#125;;int main()&#123; Queue&lt;int&gt; queue; queue.enqueue(15); queue.enqueue(4); printf(\"%d\\n\",queue.dequeue());//15 return 0;&#125; 数组实现需要考虑循环数组的问题 二叉树参考:二叉树的C++实现 二叉查找树说明对于每个节点X，其左子树节点的值都小于X对应的值，右子树节点的值都大于X对应的值 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;iostream&gt;#include &lt;stdio.h&gt;template &lt;typename T&gt;class BinarySearchTree&#123;public: BinarySearchTree() : root_(nullptr) &#123;&#125; BinarySearchTree(const BinarySearchTree &amp;rhs) &#123; root_ = clone(rhs.root_); &#125; ~BinarySearchTree() &#123; makeEmpty(); &#125; const T &amp;findMin() const &#123; BinaryNode *t = findMin(root_); return t ? t-&gt;element_ : T(); &#125; const T &amp;findMax() const &#123; BinaryNode *t = findMax(root_); return t ? t-&gt;element_ : T(); &#125; bool contains(const T &amp;x) const &#123; return contains(x, root_); &#125; bool isEmpty() const &#123; return root_ == nullptr; &#125; void printTree() const &#123; printTree(root_); &#125; void makeEmpty() &#123; makeEmpty(root_); &#125; void insert(const T &amp;x) &#123; insert(x, root_); &#125; void remove(const T &amp;x) &#123; remove(x, root_); &#125; const BinarySearchTree &amp;operator=(const BinarySearchTree &amp;rhs) &#123; if(this != &amp;rhs) &#123; makeEmpty(); root_ = clone(rhs.root_); &#125; return *this; &#125;private: struct BinaryNode &#123; T element_; BinaryNode *left_; BinaryNode *right_; BinaryNode(const T &amp;ele, BinaryNode *l, BinaryNode *r) : element_(ele), left_(l), right_(r) &#123;&#125; &#125;; BinaryNode *root_; BinaryNode *findMin(BinaryNode *t) const &#123; if(!t) return nullptr; if(!t-&gt;left_) return t; return findMin(t-&gt;left_); &#125; BinaryNode *findMax(BinaryNode *t) const &#123; if(t) &#123; while(t-&gt;right_) t = t-&gt;right_; &#125; return t; &#125; bool contains(const T &amp;x, BinaryNode *t) const &#123; if(!t) return false; else if(x &lt; t-&gt;element_) return contains(x, t-&gt;left_); else if(t-&gt;element_ &lt; x) return contains(x, t-&gt;right_); return true; //match &#125; void insert(const T &amp;x, BinaryNode *&amp;t) const &#123; if(!t) t = new BinaryNode(x, nullptr, nullptr); else if(x &lt; t-&gt;element_) insert(x, t-&gt;left_); else if(t-&gt;element_ &lt; x) insert(x, t-&gt;right_); else std::cout &lt;&lt; \"already has node :\" &lt;&lt; x &lt;&lt; std::endl; &#125; void remove(const T &amp;x, BinaryNode *&amp;t) const &#123; if(!t) return; // can not find item else if(x &lt; t-&gt;element_) remove(x, t-&gt;left_); else if(t-&gt;element_ &lt; x) remove(x, t-&gt;right_); else if(t-&gt;left_ &amp;&amp; t-&gt;right_) //has two children &#123; //策略：将当前节点的值设为右子树最小节点的值 //并删除右子树最小节点 t-&gt;element_ = findMin(t-&gt;right_)-&gt;element_; remove(t-&gt;element_, t-&gt;right_); &#125; else &#123; //没有或只有一个子节点的情况 //若t没有子节点，删除后t置为空 //若t只有右子节点，删除后t置为其右子节点 //若t只有左子节点，删除后t置为其左子节点 BinaryNode *oldNode = t; t = t-&gt;left_ ? t-&gt;left_ : t-&gt;right_; delete oldNode; &#125; &#125; void makeEmpty(BinaryNode *&amp;t) &#123; if(t) &#123; makeEmpty(t-&gt;left_); makeEmpty(t-&gt;right_); delete t; &#125; t = nullptr; &#125; void printTree(BinaryNode *t) const &#123; if(!t) return; printTree(t-&gt;left_); std::cout &lt;&lt; t-&gt;element_ &lt;&lt; std::endl; printTree(t-&gt;right_); &#125; BinaryNode *clone(BinaryNode *t) &#123; if(!t) return nullptr; return new BinaryNode(t-&gt;element_, clone(t-&gt;left_), clone(t-&gt;right_)); &#125;&#125;;int main()&#123; BinarySearchTree&lt;int&gt; btree; btree.insert(5); btree.insert(3); btree.insert(6); btree.insert(2); btree.insert(1); btree.insert(7); btree.printTree(); btree.remove(2); auto tree2 = btree; tree2.printTree(); return 0;&#125; 散列说明以常数平均时间执行插入、删除和查找的技术。 分离链接法将所有散列到同一个值的所有元素保存到一个链表中。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;string&gt;//判断素数bool isPrime(int num)&#123; if(num &lt;= 1) return false; else if(num == 2) return true; for(int i = 2; i &lt;= num / 2; ++i) if(num % i == 0) return false; return true;&#125;//这里设包含自身，即如果num为101则返回101int nextPrime(int num)&#123; while(!isPrime(num)) num++; return num;&#125;//使用书中第三种hash方法int hash(const std::string &amp;key)&#123; int hashVal = 0; for(const char &amp;c : key) hashVal = 37 * hashVal + c; return hashVal;&#125;template &lt;typename HashedObj&gt;class HashTable&#123;public: HashTable(int size = 101) : currentSize_() &#123; theLists_.resize(nextPrime(size)); &#125; bool contains(const HashedObj &amp;x) const; void makeEmpty(); bool insert(const HashedObj &amp;x); bool remove(const HashedObj &amp;x);private: std::vector&lt;std::list&lt;HashedObj&gt;&gt; theLists_; int currentSize_; void rehash(); int myhash(const HashedObj &amp;x) const;&#125;;template &lt;typename HashedObj&gt;int HashTable&lt;HashedObj&gt;::myhash(const HashedObj &amp;x) const&#123; int hashVal = hash(x); hashVal %= theLists_.size(); if(hashVal &lt; 0) hashVal += theLists_.size(); return hashVal;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::contains(const HashedObj &amp;x) const&#123; const std::list&lt;HashedObj&gt; &amp;lst = theLists_[myhash(x)]; return find(lst.begin(), lst.end(), x) != lst.end();&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::makeEmpty()&#123; for(auto &amp;lst : theLists_) lst.clear();&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::insert(const HashedObj &amp;x)&#123; std::list&lt;HashedObj&gt; &amp;lst = theLists_[myhash(x)]; if(find(lst.begin(), lst.end(), x) != lst.end()) return false; lst.push_back(x); if(++currentSize_ &gt; theLists_.size()) rehash();&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::remove(const HashedObj &amp;x)&#123; std::list&lt;HashedObj&gt; &amp;lst = theLists_[myhash(x)]; auto itr = find(lst.begin(), lst.end(), x); if(itr == lst.end()) return false; //not found lst.erase(itr); --currentSize_; return true;&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::rehash()&#123; auto oldLists = theLists_; theLists_.resize(nextPrime(2 * oldLists.size())); for(auto &amp;lst : theLists_) lst.clear(); currentSize_ = 0; for(const auto &amp;lst : oldLists) &#123; auto itr = lst.begin(); while(itr != lst.end()) insert(*itr++); &#125;&#125; 测试1234567891011121314151617181920212223242526272829class Employee&#123;public: explicit Employee(std::string name=\"\") : name_(name) &#123;&#125; const std::string &amp;getName() const &#123; return name_;&#125; bool operator==(const Employee &amp;rhs) const &#123; return getName() == rhs.getName(); &#125; bool operator!=(const Employee &amp;rhs) const &#123; return !(*this == rhs); &#125;private: std::string name_; double salary_;&#125;;int hash(const Employee &amp;x)&#123; return hash(x.getName());&#125;int main()&#123; HashTable&lt;Employee&gt; htable; Employee ea(\"kdb\"); Employee eb(\"fff\"); Employee ec(\"ddd\"); htable.insert(ea); htable.insert(eb); htable.insert(ec); printf(\"%d\\n\", htable.contains(ea));&#125; 探测散列表方法解决冲突的办法：当冲突发生时，尝试选择另外一个单元，直到找到另外一个单元。 即通过h0(x),h1(x)…一依次试选，其中hi(x) = (hash(x) + f(i)) mod TableSize,且f(0) = 0。 这里就有线性探测f(i) = i，和平方探测f(i) = i*i两种啦。书中以平方探测举例 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//平方探测法template &lt;typename HashedObj&gt;class HashTable&#123;public: explicit HashTable(int size = 101); enum EntryType &#123;ACTIVE, EMPTY, DELETED&#125;; bool contains(const HashedObj &amp;x) const; void makeEmpty(); bool insert(const HashedObj &amp;x); bool remove(const HashedObj &amp;x);private: struct HashEntry &#123; HashedObj element_; EntryType info_; HashEntry(const HashedObj &amp;e=HashedObj(), EntryType type=EMPTY) : element_(e), info_(type) &#123;&#125; &#125;; std::vector&lt;HashEntry&gt; array_; int currentSize_; int findPos(const HashedObj &amp;x) const; bool isActive(int pos) const; void rehash(); int myhash(const HashedObj &amp;x) const;&#125;;template &lt;typename HashedObj&gt;HashTable&lt;HashedObj&gt;::HashTable(int size) : array_(nextPrime(size))&#123; makeEmpty();&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::makeEmpty()&#123; currentSize_ = 0; for(auto &amp;entry : array_) entry.info_ = EMPTY;&#125;template&lt;typename HashedObj&gt;int HashTable&lt;HashedObj&gt;::myhash(const HashedObj &amp;x) const&#123; int hashVal = hash(x); hashVal %= array_.size(); if(hashVal &lt; 0) hashVal += array_.size(); return hashVal;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::contains(const HashedObj &amp;x) const&#123; return isActive(findPos(x));&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::isActive(int pos) const&#123; return array_[pos].info_ == ACTIVE;&#125;template &lt;typename HashedObj&gt;int HashTable&lt;HashedObj&gt;::findPos(const HashedObj &amp;x) const&#123; int offset = 1; int currentPos = myhash(x); while(array_[currentPos].info_ != EMPTY &amp;&amp; array_[currentPos].element_ != x) &#123; //f(i) = f(i - 1) + 2i - 1 currentPos += offset; offset += 2; if(currentPos &gt;= array_.size()) currentPos -= array_.size(); &#125; return currentPos;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::insert(const HashedObj &amp;x)&#123; int pos = findPos(x); if(isActive(pos)) return false; array_[pos] = HashEntry(x, ACTIVE); //这里注意大于表大小一半的时候，就需要rehash了 if(++currentSize_ &gt; array_.size()/2) rehash(); return true;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::remove(const HashedObj &amp;x)&#123; int pos = findPos(x); if(!isActive(pos)) return false; array_[pos].info = DELETED; return true;&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::rehash()&#123; std::vector&lt;HashEntry&gt; oldArray = array_; array_.resize(nextPrime(2 * array_.size())); for(auto &amp;entry : array_) entry.info_ = EMPTY; currentSize_ = 0; for(auto &amp;entry : oldArray) &#123; if(entry.info_ = ACTIVE) insert(entry.element_); &#125;&#125; 测试与分离链接法相同 优先队列（堆）一种特殊的队列，包括以下操作 insert，类似于入队操作 deleteMin，找出，返回，删除队列中的最小元素（或者最大元素） 实现通过binary heap(二叉堆)实现。特点 通过数组表示的完全二叉树 首元素索引为1，当节点索引为i时，左儿子索引为2i，右儿子索引为2i+1,父节点索引i/2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;exception&gt;template &lt;typename T&gt;class BinaryHeap&#123;public: BinaryHeap(int capacity = 100); BinaryHeap(const std::vector&lt;T&gt; &amp;items); bool empty() const &#123; return currentSize_ == 0;&#125; const T &amp;findMin() const; void insert(const T &amp;x); void deleteMin(); void deleteMin(T &amp; minItem); void makeEmpty();private: int currentSize_; std::vector&lt;T&gt; array_; void buildHeap(); void percolateDown(int hole);&#125;;template &lt;typename T&gt;BinaryHeap&lt;T&gt;::BinaryHeap(int capacity) : array_(capacity), currentSize_(0) &#123;&#125;template &lt;typename T&gt;BinaryHeap&lt;T&gt;::BinaryHeap(const std::vector&lt;T&gt; &amp;items) : array_(items.size() + 10), currentSize_(items.size())&#123; for(int i = 0; i &lt; items.size(); ++i) array_[i + 1] = items[i]; buildHeap();&#125;template &lt;typename T&gt;const T &amp;BinaryHeap&lt;T&gt;::findMin() const&#123; if(empty()) throw std::underflow_error(\"under flow\"); return array_[1];&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::insert(const T &amp;x)&#123; if(currentSize_ == array_.size() - 1) array_.resize(array_.size() * 2); //percolate up 上滤 int hole = ++currentSize_; //array[hole/2]为父节点的值 //如果当前节点的值小于父节点的值，则交换 for(; hole &gt; 1 &amp;&amp; x &lt; array_[hole / 2]; hole /= 2) array_[hole] = array_[hole / 2]; array_[hole] = x;&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::deleteMin()&#123; if(empty()) throw std::underflow_error(\"under flow\"); array_[1] = array_[currentSize_--]; percolateDown(1);&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::deleteMin(T &amp;minItem)&#123; if(empty()) throw std::underflow_error(\"under flow\"); minItem = array_[1]; array_[1] = array_[currentSize_--]; percolateDown(1);&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::makeEmpty()&#123; currentSize_ = 0;&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::buildHeap()&#123; for(int i = currentSize_ / 2; i &gt;= 1; --i) percolateDown(i);&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::percolateDown(int hole)&#123; T tmp = array_[hole]; int child; for(; hole * 2 &lt;= currentSize_; hole = child) &#123; //左子节点为 2*hole child = hole * 2; //右子节点为2*hole+1，注意要先判断右子节点是否存在 if(child != currentSize_ &amp;&amp; array_[child + 1] &lt; array_[child]) ++child; if(array_[child] &lt; tmp) array_[hole] = array_[child]; else break; &#125; array_[hole] = tmp;&#125; 测试1234567891011121314151617int main()&#123; std::vector&lt;int&gt; array&#123;3, 1&#125;; BinaryHeap&lt;int&gt; heap(array); printf(\"min:%d\\n\", heap.findMin()); heap.deleteMin(); printf(\"min:%d\\n\", heap.findMin()); heap.deleteMin(); try &#123; heap.deleteMin(); &#125; catch(std::underflow_error &amp;e) &#123; printf(\"catch exception :%s\\n\", e.what()); &#125;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"常见排序算法C++实现","date":"2017-12-30T09:23:51.000Z","path":"2017/12/30/常见排序算法C++实现/","text":"先写出简单的交换两个值的swap函数123456void swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125; 各种排序算法的原理及实现冒泡排序原理已升序为例，依次比较相邻两个数，大数放后。则一轮排序后最后一个值已为最大值。此时再以同样的方法比较前(size - 1)个数。 实现1234567891011121314151617//冒泡排序void bubbleSort(int *array, int size)&#123; for(int i = 0; i &lt; size - 1; ++i) &#123; int swapped = false; for(int j = 0; j &lt; size - i - 1; ++j) &#123; if(array[j] &gt; array[j+1])&#123; swap(array[j], array[j + 1]); swapped = true; &#125; &#125; if(!swapped) break; &#125;&#125; 说明： 此为升序排列，若要降序，则将{array[j] &gt; array[j+1]}改为{array[j] &lt; array[j+1]}即可 swapped标志量的说明：如果该标志量为false，表示某一次循环，每一个a[j]都小于等于a[j + 1]，即已经是排序好的，所以跳出循环 鸡尾酒排序原理冒泡排序的改进，进行双向排序，大数往后放，小数往前放（像摇晃的鸡尾酒） 实现12345678910111213141516//鸡尾酒排序void cocktailSort(int *array, int size)&#123; int begin = 0, end = size - 1; while(begin &lt; end) &#123; for(int i = begin; i &lt; end; ++i) if(array[i] &gt; array[i + 1]) swap(array[i], array[i + 1]); --end;//最后一个已排序好 for(int i = end; i &gt; begin; --i) if(array[i] &lt; array[i - 1]) swap(array[i - 1], array[i]); ++begin;//第一个位置已排序好 &#125;&#125; 选择排序原理已升序为例 第一次从整个数组中选择最小的一个，与第1个值交换，这时第一个值已排序好 第二次从第一个之外剩下的数中选择最小的与第二个值交换，这时第二个值也排序好依次类推 实现12345678910111213141516//选择排序void selectSort(int *array, int size)&#123; for(int i = 0; i &lt; size - 1; ++i) &#123; int minIndex = i; //前i个数已排序好，而第i个值是最小基准值，所以从i + 1开始 for(int j = i + 1; j &lt; size; ++j) &#123; if(array[j] &lt; array[minIndex]) minIndex = j; &#125; if(minIndex != i) swap(array[i], array[minIndex]); &#125;&#125; 直接插入排序原理将原数组想象分为两部分，第一部分是已排序好的，第二部分是乱序的。 每次从乱序的部分取出第一个值，在已排序的部分找出一个合适的位置插入进去。 其中，第一次排序排序时，已排序的部分为一个值 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344//直接插入排序：方法1void insertSort1(int *array, int size)&#123; //未排序的部分，从1开始往后遍历 for(int i = 1; i &lt; size; ++i) &#123; //从未排序的部分取出第一个，为待比较的值 int curData = array[i]; //在第一部分中插入的索引 int insertIndex = i; //已排序的部分为前i个值 for(int j = 0; j &lt; i; ++j) &#123; if(array[j] &gt; curData) &#123; insertIndex = j; break; &#125; &#125; //第一部分从最后一个位置，到待插入的位置，统统向后移一个位置 for(int j = i; j &gt; insertIndex; --j) array[j] = array[j - 1]; //将待比较的值插入 array[insertIndex] = curData; &#125;&#125;//第一种方法稍微有点啰嗦，可以更简略一些//直接插入排序：方法2void insertSort2(int *array, int size)&#123; //未排序的部分，从1开始往后遍历 for(int i = 1; i &lt; size; ++i) &#123; //从未排序的部分取出第一个，为待比较的值 int curData = array[i]; //在第一部分中插入的索引 int j = i; //从已排序部分的最后一个往前遍历，若比标准值大，则往后移一个 for(j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; curData; --j) array[j + 1] = array[j]; array[j + 1] = curData; &#125;&#125; 归并排序原理将数组的排序拆分成小的有序数组的合并。有点抽象，举个例子 原数组有8个无序值-&gt;拆分成2组，每组4个 -&gt; 拆分成4组，每组两个 -&gt; 拆分成8组，每组1个成员。 此时每个组都是包含一个成员的有序数组，将1,2个有序组合并成2个成员的有序组A， 将第3,4个有序组合并成2个成员的有序组B，再将有序组A,B合并，如此返回 实现12345678910111213141516171819202122232425262728293031323334353637//归并排序//将起，中，止范围的数组分为两部分，将这两部分合并void merge(int *array, int p, int q, int r)&#123; //第一部分的起止 int begin1 = p, end1 = q; //第二部分的起止 int begin2 = q + 1, end2 = r; int k = 0; //临时数组，存放p到r之间排序好的数组 int *temp = new int[r - p + 1]; while(begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123; if(array[begin1] &lt; array[begin2]) temp[k++] = array[begin1++]; else temp[k++] = array[begin2++]; &#125; while(begin1 &lt;= end1) temp[k++] = array[begin1++]; while(begin2 &lt;= end2) temp[k++] = array[begin2++]; for(int i = 0; i &lt; k; ++i) array[p + i] = temp[i]; delete []temp;&#125;void mergeSort(int *array, int begin, int end)&#123; if(begin &lt; end) &#123; int mid = (begin + end)/2; mergeSort(array, begin, mid); mergeSort(array, mid + 1, end); printf(\"begin:%d, mid:%d, end:%d\\n\", begin, mid, end); merge(array, begin, mid, end); &#125;&#125; 原数组为{9, 3, 1, 7, 2, 5, 4, 10}，上述打印如下1234567begin:0, mid:0, end:1begin:2, mid:2, end:3begin:0, mid:1, end:3begin:4, mid:4, end:5begin:6, mid:6, end:7begin:4, mid:5, end:7begin:0, mid:3, end:7 可以看到大致的归并过程 优化上述在merge函数中每次去new,delete数组是非常耗时的，可以考虑在排序之前new好一个大数组，排序之后再delete一次就行了。 123456789101112131415161718192021222324252627282930313233343536373839//归并排序-临时数组优化void merge(int *array, int p, int q, int r, int *temp)&#123; //第一部分的起止 int begin1 = p, end1 = q; //第二部分的起止 int begin2 = q + 1, end2 = r; int k = 0; while(begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123; if(array[begin1] &lt; array[begin2]) temp[k++] = array[begin1++]; else temp[k++] = array[begin2++]; &#125; while(begin1 &lt;= end1) temp[k++] = array[begin1++]; while(begin2 &lt;= end2) temp[k++] = array[begin2++]; for(int i = 0; i &lt; k; ++i) array[p + i] = temp[i];&#125;void mergeSort(int *array, int begin, int end, int *temp)&#123; if(begin &lt; end) &#123; int mid = (begin + end)/2; mergeSort(array, begin, mid, temp); mergeSort(array, mid + 1, end, temp); merge(array, begin, mid, end, temp); &#125;&#125;void mergeSort(int *array, int size)&#123; int *temp = new int[size]; mergeSort(array, 0, size - 1, temp); delete []temp;&#125; 不用递归实际上递归会非常耗时的，网上的例子都是使用递归的。自己想了一下，可不可以这样呢： 还是假设数组长度为8 第一轮，待排序子数组长度都为1。(1,2),(3,4),(5,6),(7,8)分别合并。 第二轮，待排序子数组长度都为2。((1,2),(3,4)),((5,6),(7,8))分别合并。 第三轮，待排序子数组长度为4。这时只需合并((1,2,3,4),(5,6,7,8)) 下面来实现一下 123456789101112131415161718192021222324void mergeSort3(int *array, int size)&#123; //每个已排序子数组的大小 int gap = 1; int *temp = new int[size]; //循环，直到分成只有两个数组了 while(gap &lt; size) &#123; for(int i = 0; i &lt; size; i += gap*2)&#123; int begin = i, mid = i + gap - 1, end = std::min(size - 1, i + gap*2 -1); //如果中间值已经超过size，则最后一个数组已不需合并 //比如数组长度为11，begin为8，mid为11，end为15 //则(11到15)的数组已不在范围 if(mid &gt;= size - 1) continue; merge(array, begin, mid, end, temp); printf(\"begin:%d, mid:%d, end:%d\\n\", begin, mid, end); &#125; gap *= 2; &#125; delete []temp;&#125; 以8个成员的数组为例，输出如下，可参考排序的过程1234567begin:0, mid:0, end:1begin:2, mid:2, end:3begin:4, mid:4, end:5begin:6, mid:6, end:7begin:0, mid:1, end:3begin:4, mid:5, end:7begin:0, mid:3, end:7 直观上还是比较好理解这种排序的思想的，感觉就是没有分治和归并的过程了。 直接以2的次方的间隔的数组进行合并排序，类似于希尔排序了。至于具体性能如何，后面再统一讨论。 引申：将n个已排序的数组合并成一个有序数组注：不能使用std的list等类型 先定义一些初始化的值，假设需要合并8个有序数组12345678910111213141516171819int array1[] = &#123;1, 3, 5&#125;;int array2[] = &#123;2, 4, 7, 9&#125;;int array3[] = &#123;8, 10, 11, 19, 23, 56&#125;;int array4[] = &#123;0, 3&#125;;int array5[] = &#123;13&#125;;int array6[] = &#123;32, 42, 52, 79, 86, 111, 222, 333&#125;;int array7[] = &#123;23, 25, 27&#125;;int array8[] = &#123;-10, -1, 7, 10&#125;;//存放n个数组的数组，因为每个数组大小不一定一样，所以不能使用2维数组int *arrays[] = &#123;array1, array2, array3, array4, array5, array6, array7, array8&#125;;//存放每个数组size的数组int sizes[] = &#123;sizeof(array1)/sizeof(int), sizeof(array2)/sizeof(int), sizeof(array3)/sizeof(int), sizeof(array4)/sizeof(int), sizeof(array5)/sizeof(int), sizeof(array6)/sizeof(int), sizeof(array7)/sizeof(int), sizeof(array8)/sizeof(int) &#125;;//数组的个数int size = sizeof(arrays)/sizeof(int*); 方法一：两两合并即第一个和第二个合并，合并好的大数组和第三个合并，以此类推。 这种方法比较好想，但是也比较效率低。就和排序的时候第1,2个数先排序， 再和第三个数排序一样。 实现123456789101112131415161718192021222324252627282930313233343536373839404142//函数功能：合并两个已排序数组//其中array2足够大，可以存放两个数组中的全部元素。void mergeTwoArray(int *array1, int size1, int *array2, int size2)&#123; int i = 0, j = 0, k = 0; int *temp = new int[size1 + size2]; while(i &lt; size1 &amp;&amp; j &lt; size2) &#123; if(array1[i] &lt; array2[j]) temp[k++] = array1[i++]; else temp[k++] = array2[j++]; &#125; while(i &lt; size1) temp[k++] = array1[i++]; while(j &lt; size2) temp[k++] = array2[j++]; for(int i = 0; i &lt; k; ++i) array2[i] = temp[i]; delete []temp;&#125;void mergeArrays(int *arrays[], int size, int sizes[])&#123; int totalSize = 0; for(int i = 0; i &lt; size; ++i) &#123; totalSize += sizes[i]; &#125; int *totalArray = new int[totalSize]; int currentSize = 0; for(int i = 0; i &lt; size; ++i) &#123; mergeTwoArray(arrays[i], sizes[i], totalArray, currentSize); currentSize += sizes[i]; &#125; for(int i = 0; i &lt; totalSize; ++i) printf(\"%d \", totalArray[i]); delete []totalArray;&#125; 其中合并两个数组的方法可以优化成如下12345678910111213141516171819202122//反过来想，从最后一个元素往前遍历//参考http://blog.csdn.net/f81892461/article/details/8583983void mergeTwoArray(int *array1, int size1, int *array2, int size2)&#123; //第一个数组的最后一个元素 int i = size1 - 1; //第二个数组的最后一个元素 int j = size2 - 1; //合成新数组的最后一个元素 int k = size1 + size2 - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; //从后往前遍历 if(array1[i] &gt; array2[j]) array2[k--] = array1[i--]; else array2[k--] = array2[j--]; &#125; while(i &gt;= 0) array2[k--] = array1[i--]; //注意这里不需要再遍历array2中的元素，因为他们已经在array2中&#125; 方法二：利用分治归并的思想网上有例子是用链表做的 http://www.cnblogs.com/TenosDoIt/p/3673188.html https://leetcode.com/problems/merge-k-sorted-lists/ 123456789101112131415161718192021222324252627//合并两个有序链表（这里设head节点不是数据节点）void merge2list(Node *head1, Node *head2)&#123; if(!head1 || !head1-&gt;next_ || !head2 || !head2-&gt;next_) return; Node node(0), *tail = &amp;node; Node *p = head1-&gt;next_, *q = head2-&gt;next_; while(p &amp;&amp; q) &#123; if(p-&gt;key_ &lt;= q-&gt;key_) &#123; tail-&gt;next_ = p; p = p-&gt;next_; &#125; else &#123; tail-&gt;next_ = q; q = q-&gt;next_; &#125; tail = tail-&gt;next_; &#125; if(p) tail-&gt;next_ = p; else if(q) tail-&gt;next_ = q; head1-&gt;next_ = node.next_;&#125; 然后按照下面的思路(以8个链表为例) L0和L1合并到L0，L2和L3合并到L2，L4和L5合并到L4，L6和L7合并到L6 再将L0和L2合并到L0，L4和L6合并到L4 再将L0和L4合并到L012345678910111213//结果保存在lists[0]中void mergeKList(std::vector&lt;Node*&gt; &amp;lists)&#123; int size = lists.size(); int gap = 1; while(gap &lt; size) &#123; for(int i = 0; i &lt; size - gap; i += 2 * gap)&#123; merge2list(lists[i], lists[i + gap]); &#125; gap *= 2; &#125;&#125; 用数组应该也能做，只是每个数组的空间是固定的，不是太好扩充。 快速排序原理依然是分治的思想 将原数组分为3部分，(begin, X - 1), X, (X + 1, end)。其中(begin, X - 1)部分的每个值都比X对应的值要小，(X + 1, end)对应的每个值都比X对应的值要大 对左右两部分数组再进行如上类似操作，进行分治 关键的问题是要找到X的位置，分治还是比较简单的。 对了，好像快速排序是各种库里默认的排序算法。 实现目前看到两种实现 第一种只设置一个向后移动的索引 1234567891011121314151617181920void qsort1(int *array, int begin, int end)&#123; if(begin &gt;= end) return; //记录的就是X对应的位置 //即last左边的都比last对应的值小，last右边的都比last对应的值大 int last = begin; //将第一个值和中间的值交换，即将中间的值作为比较值。并不是必须的。 swap(array[begin], array[(begin + end)/2]); int xData = array[begin]; //索引从第二个值往后，分别与第一个值比较 for(int i = begin + 1; i &lt;= end; ++i) if(array[i] &lt; xData) swap(array[++last], array[i]); //这里没交换之前(begin + 1, last)之间的值都比xData小 swap(array[begin], array[last]); //将begin和last值交换后，(begin, last - 1)的值都比last值小了 qsort1(array, begin, last - 1); qsort1(array, last + 1, end);&#125; 第二种设置前后两个移动的索引 123456789101112131415161718192021222324252627void qsort2(int *array, int begin, int end)&#123; if(begin &gt;= end) return; int i = begin, j = end; //依然设置第一个值为待比较值 int xData = array[begin]; while(i &lt; j) &#123; //当右边索引对应的值一直比待比较值大时，索引左移 while(i &lt; j &amp;&amp; array[j] &gt;= xData) --j; //此时若j没超过范围，则array[j]是右侧第一个比待比较值小的元素 //交换与左侧索引对应的值，并且左侧索引自增 if(i &lt; j) swap(array[i++], array[j]); //左侧索引自增，直到找到一个比待比较值大的元素 while(i &lt; j &amp;&amp; array[i] &lt;= xData) ++i; if(i &lt; j) swap(array[i], array[j--]); &#125; //跳出循环后，索引i对应的就是xData的值 array[i] = xData; qsort2(array, begin, i - 1); qsort2(array, i + 1, end);&#125; 第三种类似于第二种，参考：http://developer.51cto.com/art/201403/430986.htm 12345678910111213141516171819202122232425void qsort3(int *array, int begin, int end)&#123; if(begin &gt;= end) return; int i = begin, j = end; //依然设置第一个值为待比较值 int xData = array[begin]; while(i &lt; j) &#123; //当右边索引对应的值一直比待比较值大时，索引左移 while(i &lt; j &amp;&amp; array[j] &gt;= xData) --j; //左侧索引自增，直到找到一个比待比较值大的元素 while(i &lt; j &amp;&amp; array[i] &lt;= xData) ++i; if(i &lt; j) swap(array[i], array[j]); &#125; //此时array[i]对应的值是要比xData小的 //交换之后xData左边的值都比xData小了 swap(array[begin], array[i]); qsort2(array, begin, i - 1); qsort2(array, i + 1, end);&#125; 希尔排序原理是一种复杂的插入排序。简单插入排序是每次步长都为1的，而希尔排序选取的步进是一个递减的序列，最后一个值为1。为什么希尔排序比较快还是没搞懂，参考知乎：https://www.zhihu.com/question/24637339 实现有两种排序方法，类似12345678910111213141516void shellSort1(int *array, int size)&#123; int gap = size/2; while(gap &gt;= 1) &#123; //下面这部分逻辑和简单插入排序是类似的 for(int i = gap; i &lt; size; ++i) &#123; for(int j = i - gap; (j &gt;= 0) &amp;&amp; (array[j] &gt; array[j + gap]); j -= gap)&#123; swap(array[j + gap] ,array[j]); &#125; &#125; gap /= 2; //步进每次除2，直到步进为1则退化为简单插入排序 &#125;&#125; 123456789101112131415161718void shellSort2(int *array, int size)&#123; //int gap = size/2; int gap = 1; while(gap &gt;= 1) &#123; //下面这部分逻辑和简单插入排序是类似的 for(int i = gap; i &lt; size; ++i) &#123; int curData = array[i]; int j = 0; for(j = i - gap; j &gt;= 0 &amp;&amp; array[j] &gt; curData; j -= gap) array[j + gap] = array[j]; array[j + gap] = curData; &#125; gap /= 2; //步进每次除2，直到步进为1则退化为简单插入排序 &#125;&#125; 堆排序原理 首先什么是堆。堆是一棵完全二叉树，若任意一个节点的值不小于子节点的值，称为大根堆；若任意节点的值不大于子节点的值，称为小根堆。 堆排序的步骤，以升序为例– 将数组构造成大根堆– 交换根节点的值（最大值）与最后一个节点的值– 调整除最后一个节点之外的n-1个值为大根堆– 重复步骤2 参考：https://jingyan.baidu.com/article/5225f26b057d5de6fa0908f3.html 实现1234567891011121314151617181920212223242526272829303132333435363738394041void adjustHeap(int *array, int parent, int size)&#123; //若大于这个值，则其已没有子节点，不需要调整 if(parent &gt; (size/2 - 1)) return; //左右节点的索引 int lchild = parent * 2 + 1, rchild = parent * 2 + 2; //父，左，右三个节点最大值的索引 int max = parent; if(lchild &lt; size &amp;&amp; array[lchild] &gt; array[max]) max = lchild; if(rchild &lt; size &amp;&amp; array[rchild] &gt; array[max]) max = rchild; //最大节点不是父节点时 if(max != parent) &#123; //交换父节点与最大节点的值 swap(array[parent], array[max]); //被交换的最大节点对应的子树，可能不是一个大根堆了，所以需要调整 adjustHeap(array, max, size); &#125;&#125;void buildHeap(int *array, int size)&#123; //这里i的起始值为，非叶子节点的最后一个节点的值。 //画一个图表示一下就知道了 for(int i = size/2 - 1; i &gt;= 0; --i) adjustHeap(array, i, size);&#125;void heapSort(int *array, int size)&#123; buildHeap(array, size); for(int i = size - 1; i &gt;= 0; --i) &#123; //交换根节点和当前无序区最后一个节点的值 swap(array[0], array[i]); adjustHeap(array, 0, i); &#125;&#125; -2018-01-22更新 参考《数据结构与算法分析》所述下滤过程，可将调整堆的过程写为如下，不用递归:123456789101112131415161718192021inline int leftchild(int i)&#123; return 2 * i + 1;&#125;void percolateDown(std::vector&lt;int&gt; &amp;array, int index, int size)&#123; int temp; int child; for(temp = array[index]; leftchild(index) &lt; size; index = child) &#123; child = leftchild(index); if(child != size - 1 &amp;&amp; array[child] &lt; array[child + 1]) child++; if(array[child] &gt; temp) array[index] = array[child]; else break; &#125; array[index] = temp;&#125; 性能比较与总结使用srand和rand函数生成10万个随机数，分别使用以上的各种排序算法，进行排序。 并使用GetTickCount函数计算函数运行时间，结果如下 1234567891011121314bubbleSort elapse time: 55422 mscocktailSort elapse time: 47234 msselectSort elapse time: 20250 msinsertSort1 elapse time: 18141 msinsertSort2 elapse time: 10969 msmergeSort1 elapse time: 46 msmergeSort2 elapse time: 32 msmergeSort3 elapse time: 31 msqsort1 elapse time: 31 msqsort2 elapse time: 16 msqsort3 elapse time: 31 msshellSort1 elapse time: 47 msshellSort2 elapse time: 11516 msheapSort elapse time: 46 ms 可以看出归并排序，快速排序，希尔排序，堆排序，真的是很快。 （希尔排序的第二种写法可以放弃了） 膜拜各位发明算法的大神。 上面这些排序算法，虽然都用代码实现了，但没有图表示，有些还是比较难理解的。后面有时间的话补上。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++常用知识点","date":"2017-12-24T09:23:51.000Z","path":"2017/12/24/C++常用知识点/","text":"使用C++实现单链表操作SingleList.h 123456789101112131415161718192021222324252627282930#ifndef SINGLELIST_H#define SINGLELIST_H#include \"stdio.h\"class SingleList&#123;public: SingleList(); ~SingleList() &#123; clear(); &#125; void print(); int length(); void insert(int pos, int data); void append(int data); void remove(int pos); void reverse();private: struct Node &#123; int data; Node *next; Node(int d) : data(d), next(nullptr) &#123;&#125; ~Node() &#123; printf(\"node released. data:%d\\n\", data); &#125; &#125;; void clear(); int len; Node *head;&#125;;#endif // !SINGLELIST_H SingleList.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include \"stdafx.h\"#include \"SingleList.h\"SingleList::SingleList()&#123; len = 0; head = new Node(0);&#125;void SingleList::clear()&#123; Node *p = head, *q; while (p) &#123; q = p-&gt;next; delete p; p = q; &#125;&#125;int SingleList::length()&#123; return len;&#125;void SingleList::append(int data)&#123; insert(length(), data);&#125;void SingleList::insert(int pos, int data)&#123; if (pos &lt; 0 || pos &gt; len) &#123; printf(\"insert pos:%d is not valid.\\n\", pos); return; &#125; Node *p = head; while (pos) &#123; pos--; p = p-&gt;next; &#125; Node *q = new Node(data); q-&gt;next = p-&gt;next; p-&gt;next = q; len++;&#125;void SingleList::print()&#123; Node *p = head-&gt;next; if (!p) &#123; printf(\"List is null\\n\"); return; &#125; int i = 0; while (p) &#123; printf(\"Node(%d):%d\\n\", i++, p-&gt;data); p = p-&gt;next; &#125;&#125;void SingleList::remove(int pos)&#123; if (pos &lt; 0 || pos &gt;= len) &#123; printf(\"insert pos:%d is not valid.\\n\", pos); return; &#125; Node *p = head, *q; if (pos == 0) &#123; q = p-&gt;next; head-&gt;next = q-&gt;next; delete q; len--; return; &#125; while (pos) &#123; p = p-&gt;next; pos--; &#125; q = p-&gt;next; p-&gt;next = q-&gt;next; delete q; len--;&#125;void SingleList::reverse()&#123; if (len == 0 || len == 1) return; Node *p = head-&gt;next, *q = head-&gt;next-&gt;next, *t; p-&gt;next = nullptr; while (q) &#123; t = q-&gt;next; q-&gt;next = p; p = q; q = t; &#125; head-&gt;next = p;&#125; 使用多态时的注意点 待继承的函数必须为virtual 父类的引用或指针才能实现多态，变量不行 1234567891011121314151617181920212223class A&#123;public: //必须是virtual virtual void print() &#123; printf(\"this is A\\n\"); &#125;;class B : public A&#123;public: void print() &#123; printf(\"this is B\\n\"); &#125;&#125;;int main()&#123; A &amp;a = B(); a.print(); //或者 // A *a = new B() // a-&gt;print() // 若使用A a = B(),则不能实现多态 return 0;&#125; 汉诺塔问题123456789101112131415161718192021222324252627282930313233void move(int num, char from, char to)&#123; printf(\"move %d from %c to %c\\n\", num, from, to);&#125;//正常答案//n:深度, from:起始，to:终止，mid:借助的中间void hannoi(int depth, char from, char mid, char to)&#123; if(depth == 1) move(1, from, to); else &#123; hannoi(depth-1, from, to, mid); move(depth, from, to); hannoi(depth-1, mid, from, to); &#125;&#125;//我一开始理解成只能相邻两个之间移动时的做法//即不能从A-&gt;C,只能A-&gt;B-&gt;Cvoid func(int depth, char from, char to)&#123; if(depth &lt;= 0 || from == to) &#123; return; &#125; else &#123; func(depth-1, from, to); move(depth, from, 'B'); func(depth-1, to, from); move(depth, 'B', to); func(depth-1, from, to); &#125; &#125; 重载输入输出流12345678910111213141516171819202122232425262728293031323334353637//必须声明为友元函数,这样就能不创建对象而直接调用函数。class Fruit&#123;public: Fruit(string name, string color) &#123; name_ = name; color_ = color; &#125; friend istream&amp; operator&gt;&gt;(istream &amp;, Fruit &amp;); friend ostream&amp; operator&lt;&lt;(ostream &amp;, Fruit &amp;); private: string name_; string color_;&#125;;istream&amp; operator&gt;&gt;(istream &amp;in, Fruit &amp;fruit)&#123; in &gt;&gt; fruit.color_ &gt;&gt; fruit.name_; if(!in) cerr &lt;&lt; \"Wrong input\" &lt;&lt; endl; return in;&#125;ostream&amp; operator&lt;&lt;(ostream &amp;out, Fruit &amp;fruit)&#123; out &lt;&lt; fruit.color_ &lt;&lt; \" \" &lt;&lt; fruit.name_ &lt;&lt; endl; return out;&#125;int main()&#123; Fruit apple(\"\", \"\"); cin &gt;&gt; apple; cout &lt;&lt; apple; return 0;&#125; 读写文件读取文件12345678910111213141516171819202122232425262728293031323334void readfile()&#123; char *fname = \"log.txt\"; ifstream inFile(fname); if(!inFile) &#123; printf(\"open file %s file failed\\n\", fname); return; &#125; //逐个读取 /*char ch; while(!inFile.eof()) &#123; inFile.read(&amp;ch, 1); cout &lt;&lt; ch; &#125;*/ //逐行读取 char line[1024]; while(!inFile.eof()) &#123; inFile.getline(line, 100); cout &lt;&lt; line &lt;&lt; endl; &#125; inFile.close(); //以空格为分隔符，将数据读到数组中 /*std::vector&lt;int&gt; array; int data; while(!inFile.eof()) &#123; inFile &gt;&gt; data; array.push_back(data); &#125;*/ &#125; 写文件12345678910void writeFile()&#123; ofstream out(\"out.txt\"); if (out.is_open()) &#123; out &lt;&lt; \"This is a line.\\n\"; out &lt;&lt; \"This is another line.\\n\"; out.close(); &#125; &#125; 指向常量的指针和常指针12345678910const int constData = 15;//指向常量的指针，或者int const *ptr = &amp;constData;const int *ptr = &amp;constData;*ptr = 10; //编译错误ptr = nullptr; //okint data = 10;int *const ptr2 = &amp;data;*ptr2 = 5; //okptr2 = nullptr; // 编译错误 指针数组与数组指针123456789int array[3] = &#123;1, 3, 5&#125;;//数组指针，指向数组的指针int (*arrayPtr)[3];arrayPtr = &amp;array;printf(\"data 0 :%d\\n\", **arrayPtr);//指针数组，每一个元素都是指针char *arrayPtr2[3] = &#123;\"I\", \"Love\", \"China\"&#125;;printf(\"data 1 :%s\\n\", arrayPtr2[1]); 函数指针指向函数的指针1234567891011int func(int in)&#123; return in + 10;&#125;void testFuncPtr()&#123; int (*funcPtr)(int); funcPtr = func; printf(\"%d\\n\", (*funcPtr)(5));&#125; 类的静态成员需要在类外初始化，即使是private1234567891011121314class Object&#123;public: static int shareData() &#123; return shareData_; &#125;private: static int shareData_;&#125;;//不加会报unresolved externalsint Object::shareData_ = 0;void testStaticMember()&#123; printf(\"%d\\n\", Object::shareData());&#125; 求最大公约数1234567891011void gcd(int numA, int numB)&#123; int temp; while(numB) &#123; temp = numB; numB = numA % numB; numA = temp; &#125; printf(\"gcd is %d\\n\", numA);&#125; 数组定义及初始化定义 静态12345678910111213141516171819//静态一维数组int array1[100]; //定义int array2[2] = &#123;1, 3&#125;; //定义并初始化int array3[] = &#123;1, 3, 5, 7&#125;; //可以不指定长度//静态二维数组int array4[10][10];int array5[3][2] = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;int array6[][3] = &#123;&#123;1, 2, 3&#125;, &#123;2, 3, 4&#125;&#125;; //第一个维度可以不指定//动态一数组int *array7 = new int[5]; delete[] array7; //定义int *array8 = new int[3]&#123;1, 3, 5&#125;; delete []array8;//定义并初始化//动态二维数组int (*array10)[2] = new int[3][2]; delete []array10;int (*array11)[2] = new int[3][2]&#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;delete []array11;//变长动态二维数组int **array = new int*[n];for(int i = 0; i &lt; n; ++i) array[i] = new int[n]; 参数传递12345void func1(int *array)&#123;&#125;void func2(int array[])&#123;&#125;void func3(int array[][10])&#123;&#125;void func4(int (*array)[2])&#123;&#125;void func5(int **array)&#123;&#125; 使用std::min时报错添加了windows.h和algorithm头文件时，如下使用报错12int a = 1, b = 2;int c = std::min(a, b); error C2589: ‘(‘: illegal token on right side of ‘::’ 可以修改成如下，解决错误1(std::min)(a, b) 参考：http://www.cppblog.com/matrix/archive/2010/08/05/122329.html 递归的性能到底有多差来看下面计算斐波那契数列时递归和非递归的差距1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;windows.h&gt;long fib_recurisive(int n)&#123; if(n &lt;= 0) &#123; printf(\"error num:%d\\n\", n); return 0; &#125; else if(n &lt;= 2) return n; else return fib_recurisive(n - 1) + fib_recurisive(n - 2);&#125;long fib_normal(int n)&#123; if(n &lt;= 0) &#123; printf(\"error num:%d\\n\", n); &#125; else if(n &lt;= 2) return n; long temp[2] = &#123;1, 2&#125;; for(int i = 3; i &lt;= n; ++i) &#123; int t = temp[0]; temp[0] = temp[1]; temp[1] += t; &#125; return temp[1];&#125;int main()&#123; long begin, end, result; begin = GetTickCount(); result = fib_recurisive(45); end = GetTickCount(); printf(\"fib_recurisive(%d):%ld elapse time :%ld ms\\n\", 45, result, end - begin); begin = GetTickCount(); result = fib_normal(45); end = GetTickCount(); printf(\"fib_normal(%d):%ld elapse time :%ld ms\\n\", 45, result, end - begin); return 0;&#125; 输出12fib_recurisive(45):1836311903 elapse time :9062 msfib_normal(45):1836311903 elapse time :0 ms 以后还是能不用递归就不用递归吧。 求解序列的最大子序列和比如{-2, 11, -4, 13, -5, -2}的最大子序列和为20 1234567891011121314//最大子序列和void maxSubSum(int *array, int size)&#123; int thisSum = 0, maxSum = 0; for(int i = 0; i &lt; size; ++i) &#123; thisSum += array[i]; if(thisSum &gt; maxSum) maxSum = thisSum; else if(thisSum &lt; 0) thisSum = 0; &#125; printf(\"maxSum : %d\\n\", maxSum);&#125; 字符串逆序 方法一123456789101112void reverse(char *str)&#123; int len = strlen(str); //分别指向第一个和最后一个字符 char *p = str, *q = str + len -1; while(p &lt; q) &#123; char t = *p; *p++ = *q; *q-- = t; &#125;&#125; 需要注意的是，不能像下面这么调用12char *str = \"hello, world\";reverse(str)； 这么调用编译可以通过，但是运行会崩溃，因为这里的str其实应该是const char*，值是不可更改的。可以像下面这么调用12char str[] = \"hello, world\";reverse(str)； 方法二1234567891011121314char *reverse2(const char *src)&#123; const int size = strlen(src); char *dst = new char[size + 1]; //指向原数组最后一个字符 const char *p = src + size - 1; //指向目标数组 char *q = dst; int len = size; while(len--) *q++ = *p--; *q = '\\0'; return dst;&#125; 注意额外分配的内存，用完后需要释放的 奶牛生子问题描述：一只刚出生的奶牛，第4年开始生一只奶牛，以后每年生一只。现在给你一只刚出生的奶牛，求20年后有多少奶牛？ 方法一123456789101112//递归最简单int cowCount(int year)&#123; if(year &lt; 0) return 0; if(year == 1 || year == 2 || year == 3) return 1; if(year == 4) return 2; //前一年的数量，加上4年前生产的小牛数量（因为4年后小牛也开始生产了） return cowCount(year - 1) + cowCount(year - 4);&#125; 打印N*N矩阵1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//输入长度n，打印矩阵，格式为螺旋型如下（n为4时）// 1 2 3 4// 12 13 14 5// 11 16 15 6// 10 9 8 7//想法是将矩阵数据先保存到二维数组中，然后统一打印。//保存的方法上将整个矩阵分解成一层一层嵌套的正方形。//比如上面的矩阵可以分解成(1~12)和(13~16)的两个正方形//其中每个正方形的数据又可以分为四条边的数据void printMatrix(int n)&#123; std::vector&lt;std::vector&lt;int&gt;&gt; array(n, std::vector&lt;int&gt;(n)); //每个正方形最左上角开始的值 int start = 1; //最多有(n+1)/2 个正方形 for(int i = 0; i &lt; (n + 1) / 2; ++i) &#123; //正方形的宽度，每层递减2 int width = n - 2 * i; //宽度小于1，异常了退出 if(width &lt; 1) break; //宽度为1，最中心的一个点，特殊处理 if(width == 1) array[i][i] = n*n; //这里开始计算每条边的数据 //注意为了防止重复计算，每条边只计算(width-1)个数据 for(int j = 0; j &lt; width - 1; ++j) &#123; //上边，横坐标为i，因为第一个正方形横坐标为0，第二个正方形横坐标为1.. //纵坐标同样要加上初始值i，理由同上 array[i][j + i] = start + j; //右边 array[j + i][n - 1 - i] = start + j + width- 1; //下边 array[n - 1 - i][ width + i - 1 - j] = start + j + 2 * width - 2; //左边 array[width + i - 1 - j][i] = start + j + 3 * width - 3; &#125; start += 4 * width - 4; &#125; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; printf(\"%3d \", array[i][j]); &#125; printf(\"\\n\"); &#125;&#125; 算法2123456789101112131415161718192021222324252627282930void printMatrix2(int n) &#123; std::vector&lt;std::vector&lt;int&gt;&gt; array(n, std::vector&lt;int&gt;(n)); int i, j, round=0; int m = 1; //这里不设置的话，n为1时不正确 array[0][0] = 1; for(i=n-1;i&gt;=n/2;i--) &#123; //上边（注意每个边只计算k-1个值，这样四条边正好可以首尾连接起来） for(j = round; j &lt; i; ++j) array[round][j] = m++; //右边 for(j = round; j&lt; i; j++) array[j][i] = m++; //下边 for(j = i; j &gt; round; --j) array[i][j] = m++; //左边 for(j = i; j &gt; round; --j) array[j][round] = m++; round++; &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) printf(\"%3d\",array[i][j]); printf(\"\\n\"); &#125;&#125; 找出两个数中的大者，不用判断1int max = ((a + b) + abs(a - b))/2 各种字符串操作原型strcpy原型12345678910char *strcpy(char *dst, char *src)&#123; if(!dst || !src) return nullptr; if(dst == src) return dst; char *tmp = dst; while((*dst++ = *src++) != '\\0'); return tmp;&#125; strcat原型123456789101112131415char *mystrcat(char *dst, const char *src)&#123; if(!dst || !src) return dst; char *p = dst; while(*++p); while((*p++ = *src++) != '\\0'); return dst;&#125;void test()&#123; char dst[50] = \"i love \"; const char *src = \"China\"; printf(\"%s\\n\", mystrcat(dst, src));&#125; strcmp原型123456789101112131415161718int strcmp(const char *left, const char *right)&#123; assert(left != nullptr &amp;&amp; right != nullptr); while(*left &amp;&amp; *right &amp;&amp; (*left == *right)) &#123; ++left; ++right; &#125; return *left - *right;&#125;void test()&#123; char *s1 = \"#\"; char *s2 = \"#\"; printf(\"%d\\n\", strcmp(s1, s2)); //0 //这里要注意 printf(\"%d\\n\", s1 == \"#\"); //false&#125; 判断单链表有环定义指针slow和fast，slow每次移动一格，fast每次移动两格，如果有环，则两者必然重逢。 这就像圆形跑道，跑的快的一定会和跑的跑的慢点相逢，只要时间够长1234567891011121314bool checkHasLoop(Node *head)&#123; if(!head) return false; Node *slow = head, *fast = head-&gt;next_; while(fast &amp;&amp; fast-&gt;next_) &#123; slow = slow-&gt;next_; fast = fast-&gt;next_-&gt;next_; if(slow == fast) return true; &#125; return false;&#125; 求解整数二进制数中1的个数123456789101112int getCountOf1(unsigned int n)&#123; int count = 0; //n为0时则没有1了 while(n) &#123; ++count; //清除最右边的1 n = n &amp; (n - 1); &#125; return count;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++智能指针","date":"2017-12-18T12:23:51.000Z","path":"2017/12/18/C++智能指针/","text":"定义智能指针是在 标头文件中的 std 命名空间中定义的。 C++标准库智能指针 测试对象定义1234567891011121314151617181920212223class Object&#123;public: Object(string name) &#123; name_ = name; &#125; ~Object() &#123; cout &lt;&lt; \"~Object\" &lt;&lt; endl; &#125; void print() &#123; cout &lt;&lt; \"hello \" &lt;&lt; name_ &lt;&lt; endl; &#125; void setChild(shared_ptr&lt;Object&gt; child) &#123; child_ = child; &#125;private: shared_ptr&lt;Object&gt; child_; string name_;&#125;; unique_ptr只允许基础指针的一个所有者 创建123456//使用指针直接创建，不推荐auto unique1 = unique_ptr&lt;Object&gt;(new Object(\"kdb\"));unique1-&gt;print();//使用make_unique创建，推荐auto unique2 = make_unique&lt;Object&gt;(\"kdb\");unique2-&gt;print(); 赋值12345678910111213auto unique1 = make_unique&lt;Object&gt;(\"kdb\");auto unique2 = unique1; //编译错误auto unique1 = make_unique&lt;Object&gt;(\"kdb\");unique_ptr&lt;Object&gt; unique2(unique1); //编译错误//使用同一裸指针定义多个unique_ptr，会导致崩溃。//因为裸指针指向的内存会被删除多次Object *rawPtr = new Object(\"kdb\");unique_ptr&lt;Object&gt; unique1(rawPtr);unique1-&gt;print();unique_ptr&lt;Object&gt; unique2(rawPtr);unique2-&gt;print();//调用完成之后崩溃 移动1234auto unique1 = make_unique&lt;Object&gt;(\"kdb\"); auto unique2 = move(unique1); unique2-&gt;print(); //OK unique1-&gt;print(); //崩溃，原unique_ptr已无效 示例：向量中使用unique_ptr123456789vector&lt;unique_ptr&lt;Object&gt;&gt; objects;objects.push_back(make_unique&lt;Object&gt;(\"123\"));objects.push_back(make_unique&lt;Object&gt;(\"334\"));objects.push_back(make_unique&lt;Object&gt;(\"567\"));//主要这里不使用引用会导致编译错误for(auto const &amp;object : objects)&#123; object-&gt;print();&#125; 示例，创建指向数组的unique_ptr123456789101112//裸指针方式//int *array = new int[5];//unique_ptr方式auto array = make_unique&lt;int[]&gt;(5);for(int i = 0; i &lt; 5; i++)&#123; array[i] = i;&#125;for(int i = 0; i &lt; 5; i++)&#123; cout &lt;&lt; array[i] &lt;&lt; endl;&#125; 总结而言：可移动，但不可复制 shared_ptr采用引用计数的智能指针。 创建12345678910//推荐auto shared1 = make_shared&lt;Object&gt;(\"kdb\");shared1-&gt;print();//传入裸指针，不推荐auto shared2 = shared_ptr&lt;Object&gt;(new Object(\"kdb\"));shared2-&gt;print();//声明和初始化需要分开时，传入nullptrshared_ptr&lt;Object&gt; shared3(nullptr);shared3 = make_shared&lt;Object&gt;(\"kdb\");shared3-&gt;print(); 复制与C++对象类似123456auto shared1 = make_shared&lt;Object&gt;(\"kdb\");auto shared2 = shared1;auto shared3(shared1);shared1-&gt;print();shared2-&gt;print();shared3-&gt;print(); 存在问题：嵌套引用时导致内存泄漏123456auto shared1 = make_shared&lt;Object&gt;(\"kdb\");auto shared2 = make_shared&lt;Object&gt;(\"233\");shared1-&gt;setChild(shared2);shared2-&gt;setChild(shared1);cout &lt;&lt; \"shared1 count:\" &lt;&lt; shared1.use_count() &lt;&lt; endl; //2cout &lt;&lt; \"shared2 count:\" &lt;&lt; shared2.use_count() &lt;&lt; endl; //2 weak_ptr结合 shared_ptr 使用的特例智能指针。 weak_ptr 提供对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。 将类中的成员变量类型改成weak_ptr类型，则上述嵌套引用导致的内存泄漏不存在了 再来看一个循环引用的例子12345678910111213141516171819202122232425//双向链表struct Node&#123; Node(int data) :data_(data) &#123;&#125; ~Node() &#123; printf(\"Node deconstructor, data:%d\\n\", data_); &#125; int data_; shared_ptr&lt;Node&gt; prev_; shared_ptr&lt;Node&gt; next_;&#125;;void testDoubleList()&#123; auto node1 = make_shared&lt;Node&gt;(1); auto node2 = make_shared&lt;Node&gt;(2); node1-&gt;next_ = node2; node2-&gt;prev_ = node1; //引用计数为2导致资源泄漏 printf(\"node1 count:%d\\n\", node1.use_count()); //2 printf(\"node2 count:%d\\n\", node2.use_count()); //2&#125; 修改Node中的成员为weak_ptr则可以解决该问题123456789101112131415161718192021222324252627//双向链表struct Node&#123; Node(int data) :data_(data) &#123;&#125; ~Node() &#123; printf(\"Node deconstructor, data:%d\\n\", data_); &#125; int data_; weak_ptr&lt;Node&gt; prev_; weak_ptr&lt;Node&gt; next_; //shared_ptr&lt;Node&gt; prev_; //shared_ptr&lt;Node&gt; next_;&#125;;void testDoubleList()&#123; auto node1 = make_shared&lt;Node&gt;(1); auto node2 = make_shared&lt;Node&gt;(2); node1-&gt;next_ = node2; node2-&gt;prev_ = node1; //资源释放 printf(\"node1 count:%d\\n\", node1.use_count()); //1 printf(\"node2 count:%d\\n\", node2.use_count()); //1&#125; weak_ptr本身没有重载operator*和-&gt;，所以不具有普通指针的行为 lock函数可以获得一个可用的shared_ptr，从而操作资源。 参考 C++中智能指针的学习 智能指针（现代 C++） 创建和使用 unique_ptr 实例 创建和使用 shared_ptr 实例 创建和使用共享 weak_ptr 实例 shared_ptr造成的循环引用","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"大话设计模式笔记","date":"2017-12-06T12:23:51.000Z","path":"2017/12/06/大话设计模式/","text":"以下为使用C++实现《大话设计模式》中的各种设计模式 简单工厂模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;class Operation&#123;public: virtual ~Operation() &#123; cout &lt;&lt; \"~Operation\" &lt;&lt; endl; &#125; void setNum1(double num) &#123; num1_ = num; &#125; void setNum2(double num) &#123; num2_ = num; &#125; virtual double getResult() &#123; return 0.0; &#125;protected: double num1_; double num2_;&#125;;class OperationAdd : public Operation&#123;public: ~OperationAdd() &#123; cout &lt;&lt; \"~OperationAdd\" &lt;&lt; endl; &#125; double getResult() &#123; return num1_ + num2_; &#125;&#125;;class OperationSub : public Operation&#123;public: ~OperationSub() &#123; cout &lt;&lt; \"~OperationSub\" &lt;&lt; endl; &#125; double getResult() &#123; return num1_ - num2_; &#125;&#125;;class OperationMulti : public Operation&#123;public: ~OperationMulti() &#123; cout &lt;&lt; \"~OperationMulti\" &lt;&lt; endl; &#125; double getResult() &#123; return num1_ * num2_; &#125;&#125;;class OperationDiv : public Operation&#123;public: ~OperationDiv() &#123; cout &lt;&lt; \"~OperationDiv\" &lt;&lt; endl; &#125; double getResult() &#123; if(fabs(num2_) &lt; 1e-15) &#123; cout &lt;&lt; \"div num cannot be zero\" &lt;&lt; endl; return 0.0; &#125; else &#123; return num1_ / num2_; &#125; &#125;&#125;;unique_ptr&lt;Operation&gt; opFactory(string op)&#123; if(op == \"+\") return make_unique&lt;OperationAdd&gt;(); else if(op == \"-\") return make_unique&lt;OperationSub&gt;(); else if(op == \"*\") return make_unique&lt;OperationMulti&gt;(); else if(op == \"/\") return make_unique&lt;OperationDiv&gt;(); else &#123; cout &lt;&lt; \"unsupported operation:\" &lt;&lt; op &lt;&lt; endl;; return nullptr; &#125;&#125;int main()&#123; double num1, num2; string op_s; cout &lt;&lt; \"please input num1:\"; cin &gt;&gt; num1; cout &lt;&lt; \"please input num2:\"; cin &gt;&gt; num2; cout &lt;&lt; \"please input operation:\"; cin &gt;&gt; op_s; auto op = opFactory(op_s); op-&gt;setNum1(num1); op-&gt;setNum2(num2); cout &lt;&lt; \"result:\" &lt;&lt; op-&gt;getResult() &lt;&lt; endl; return 0;&#125; 策略模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Strategy&#123;public: virtual ~Strategy() &#123; cout &lt;&lt; \"~Strategy\" &lt;&lt; endl; &#125; virtual void AlgorithmInterface() = 0;&#125;;class ConcreteStrategyA : public Strategy&#123;public: ~ConcreteStrategyA() &#123; cout &lt;&lt; \"~ConcreteStrategyA\" &lt;&lt; endl; &#125; void AlgorithmInterface() &#123; cout &lt;&lt; \"Algorithm A called\" &lt;&lt; endl; &#125;&#125;;class ConcreteStrategyB : public Strategy&#123;public: ~ConcreteStrategyB() &#123; cout &lt;&lt; \"~ConcreteStrategyB\" &lt;&lt; endl; &#125; void AlgorithmInterface() &#123; cout &lt;&lt; \"Algorithm B called\" &lt;&lt; endl; &#125;&#125;;class Context&#123;public: Context(shared_ptr&lt;Strategy&gt; strategy) &#123; strategy_ = strategy; &#125; ~Context() &#123; cout &lt;&lt; \"~Context\" &lt;&lt; endl; &#125; void ContextInterface() &#123; strategy_-&gt;AlgorithmInterface(); &#125;private: shared_ptr&lt;Strategy&gt; strategy_;&#125;;int main()&#123; auto algo = make_shared&lt;ConcreteStrategyA&gt;(); auto ctx = make_unique&lt;Context&gt;(algo); ctx-&gt;ContextInterface(); return 0;&#125; 示例（与简单工厂结合）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class CashSuper&#123;public: virtual ~CashSuper() &#123; cout &lt;&lt; \"~CashSuper\" &lt;&lt; endl; &#125; virtual double getCash(double money) = 0;&#125;;class CashNormal : public CashSuper&#123;public: ~CashNormal() &#123; cout &lt;&lt; \"~CashNormal\" &lt;&lt; endl; &#125; double getCash(double money)&#123; return money; &#125;&#125;;class CashSale : public CashSuper&#123;public: CashSale(double rate) : rate_(rate) &#123;&#125; ~CashSale() &#123; cout &lt;&lt; \"~CashSale\" &lt;&lt; endl; &#125; double getCash(double money)&#123; return money * rate_;&#125;private: double rate_;&#125;;class CashFullCut : public CashSuper&#123;public: CashFullCut(int full, int ret) : full_(full), ret_(ret) &#123;&#125; ~CashFullCut() &#123; cout &lt;&lt; \"~CashFullCut\" &lt;&lt; endl; &#125; double getCash(double money) &#123; for(int i = 0; i &lt; int(money/full_); i++) money -= ret_; return money; &#125;private: int full_; int ret_;&#125;;class CashContext&#123;public: CashContext(int type) &#123; switch (type) &#123; case 0: cashSuper_ = make_unique&lt;CashNormal&gt;(); break; case 1: cashSuper_ = make_unique&lt;CashSale&gt;(0.9); break; case 2: cashSuper_ = make_unique&lt;CashFullCut&gt;(200, 10); break; default: cashSuper_ = nullptr; break; &#125; &#125; ~CashContext() &#123; cout &lt;&lt; \"~CashContext\" &lt;&lt; endl; &#125; double getResult(double money) &#123; if(cashSuper_) return cashSuper_-&gt;getCash(money); return 0.0; &#125;private: unique_ptr&lt;CashSuper&gt; cashSuper_;&#125;;int main()&#123; int num; double unitPrice; int type; double sum = 0; cout &lt;&lt; \"please input num :\" &lt;&lt; endl; cin &gt;&gt; num; cout &lt;&lt; \"please input unitPrice:\" &lt;&lt; endl; cin &gt;&gt; unitPrice; cout &lt;&lt; \"please input price type:\" &lt;&lt; endl; cin &gt;&gt; type; CashContext ctx(type); cout &lt;&lt; \"sum : \" &lt;&lt; ctx.getResult(num*unitPrice) &lt;&lt; endl; return 0;&#125; 装饰模式原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Component&#123;public: virtual void Operation() = 0;&#125;;class ConcreteComponent : public Component&#123;public: void Operation() &#123; cout &lt;&lt; \"operation of concrete object\" &lt;&lt; endl; &#125;&#125;;class Decorator : public Component&#123;public: Decorator() &#123; component_ = nullptr; &#125; void setComponent(Component *component) &#123; component_ = component; &#125; void Operation() &#123; if(component_) component_-&gt;Operation(); &#125;protected: Component *component_;&#125;;class ConcreteDecoratorA : public Decorator&#123;public: void Operation() &#123; Decorator::Operation(); addedState_ = \"New State\"; cout &lt;&lt; \"decorator a\" &lt;&lt; endl; &#125;private: string addedState_;&#125;;class ConcreteDecoratorB : public Decorator&#123;public: void Operation() &#123; Decorator::Operation(); addedOperation(); cout &lt;&lt; \"decorator b\" &lt;&lt;endl; &#125; void addedOperation() &#123; cout &lt;&lt; \"added operation\" &lt;&lt; endl; &#125;&#125;;void test6()&#123; ConcreteComponent c; ConcreteDecoratorA decoratorA; ConcreteDecoratorB decoratorB; decoratorA.setComponent(&amp;c); decoratorB.setComponent(&amp;decoratorA); decoratorB.Operation();&#125; 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Person&#123;public: Person()&#123;&#125; Person(string name) &#123; name_ = name; &#125; virtual void show() &#123; cout &lt;&lt; name_ &lt;&lt; endl; &#125;private: string name_;&#125;;class Finary : public Person&#123;public: Finary() &#123; person_ = nullptr; &#125; void Decorate(Person *person) &#123; person_ = person; &#125; void show() &#123; if(person_) person_-&gt;show(); &#125;private: Person *person_;&#125;;class TShirt : public Finary&#123;public: void show() &#123; cout &lt;&lt; \"wear TShirts \"; Finary::show(); &#125;&#125;;class Suite : public Finary&#123;public: void show() &#123; cout &lt;&lt; \"wear suite \"; Finary::show(); &#125;&#125;;void test6()&#123; Person kongdb(\"kongdb\"); TShirt tshirt; Suite suite; tshirt.Decorate(&amp;kongdb); suite.Decorate(&amp;tshirt); suite.show();&#125; 代理模式原型12345678910111213141516171819202122232425262728293031323334353637class Subject&#123;public: virtual void request() = 0;&#125;;class ReadSubject : public Subject&#123;public: void request() &#123; cout &lt;&lt; \"real request\" &lt;&lt; endl; &#125;&#125;;class Proxy : public Subject&#123;public: Proxy() &#123; realSubj_ = nullptr; &#125; void request() &#123; if(!realSubj_) realSubj_ = new ReadSubject; realSubj_-&gt;request(); &#125;private: ReadSubject *realSubj_;&#125;;void test7()&#123; Proxy proxy; proxy.request();&#125; 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class GiveGift&#123;public: virtual void giveDolls() = 0; virtual void giveFlowers() = 0; virtual void giveChocolate() = 0; &#125;;class SchoolGirl&#123;public: SchoolGirl(string name) &#123; name_ = name; &#125; string name()&#123; return name_; &#125;private: string name_;&#125;;class Persuit : public GiveGift&#123;public: Persuit(SchoolGirl *mm) &#123; mm_ = mm; &#125; void giveDolls() &#123; cout &lt;&lt; \"give dolls for \" &lt;&lt; mm_-&gt;name() &lt;&lt; endl; &#125; void giveFlowers() &#123; cout &lt;&lt; \"give flowers for \" &lt;&lt; mm_-&gt;name() &lt;&lt; endl; &#125; void giveChocolate() &#123; cout &lt;&lt; \"give chocolate for \" &lt;&lt; mm_-&gt;name() &lt;&lt; endl; &#125;private: SchoolGirl *mm_;&#125;;class Proxy : public GiveGift&#123;public: Proxy(SchoolGirl *mm) &#123; persuit_ = new Persuit(mm); &#125; ~Proxy() &#123; delete persuit_; &#125; void giveDolls() &#123; persuit_-&gt;giveDolls(); &#125; void giveFlowers() &#123; persuit_-&gt;giveFlowers(); &#125; void giveChocolate() &#123; persuit_-&gt;giveChocolate(); &#125;private: Persuit *persuit_;&#125;;void test7()&#123; SchoolGirl mm(\"jiaojiao\"); Proxy proxy(&amp;mm); proxy.giveDolls(); proxy.giveFlowers(); proxy.giveChocolate();&#125; 工厂模式示例：加减法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Operation&#123;public: virtual ~Operation() &#123; cout &lt;&lt; \"~Operation\" &lt;&lt; endl; &#125; void setNumA(double num) &#123; numA_ = num; &#125; void setNumB(double num) &#123; numB_ = num; &#125; virtual double getResult() = 0;protected: double numA_; double numB_;&#125;;class OperationAdd : public Operation&#123;public: ~OperationAdd() &#123; cout &lt;&lt; \"~OperationAdd\" &lt;&lt; endl; &#125; double getResult() &#123; return numA_ + numB_; &#125;&#125;;class OperationSub : public Operation&#123;public: ~OperationSub() &#123; cout &lt;&lt; \"~OperationSub\" &lt;&lt; endl; &#125; double getResult() &#123; return numA_ - numB_; &#125;&#125;;class IFactory&#123;public: virtual ~IFactory() &#123; cout &lt;&lt; \"~IFactory\" &lt;&lt; endl; &#125; virtual unique_ptr&lt;Operation&gt; getOperation() = 0;&#125;;class AddFactory : public IFactory&#123;public: ~AddFactory() &#123; cout &lt;&lt; \"~AddFactory\" &lt;&lt; endl; &#125; unique_ptr&lt;Operation&gt; getOperation() &#123; return make_unique&lt;OperationAdd&gt;(); &#125;&#125;;class SubFactory : public IFactory&#123;public: ~SubFactory() &#123; cout &lt;&lt; \"~SubFactory\" &lt;&lt; endl; &#125; unique_ptr&lt;Operation&gt; getOperation() &#123; return make_unique&lt;OperationSub&gt;(); &#125;&#125;;int main()&#123; auto factoy = make_unique&lt;AddFactory&gt;(); auto operation = factoy-&gt;getOperation(); operation-&gt;setNumA(10); operation-&gt;setNumB(30); cout &lt;&lt; operation-&gt;getResult() &lt;&lt; endl; return 0;&#125; 原型模式C++中的拷贝构造函数和operator=编译器会生成默认的拷贝构造函数和operator=函数，对于只包含数据成员的类就够了（浅拷贝）1234567891011121314151617181920212223class People&#123;public: People(int age) :age_(age) &#123;&#125; int age()&#123; return age_; &#125;private: int age_;&#125;;int main()&#123; People peopleA(20); //copy constuctor People peopleB(peopleA); cout &lt;&lt; \"people B age:\" &lt;&lt; peopleB.age() &lt;&lt; endl; //20 People peopleC(30); //operator= peopleC = peopleA; cout &lt;&lt; \"people C age:\" &lt;&lt; peopleC.age() &lt;&lt; endl; //20 return 0;&#125; 但是对于包含指针成员的类，仅有默认构造函数就不够了，还会导致崩溃 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class People&#123;public: People(int age, char *name) :age_(age) &#123; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125; ~People() &#123; delete name_; &#125; int age()&#123; return age_; &#125; char *name() &#123; return name_; &#125; void setName(char *name) &#123; if(name_) &#123; cout &lt;&lt; \"release previous name\" &lt;&lt; endl; delete name_; &#125; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125;private: char *name_; int age_;&#125;;int main()&#123; People peopleA(20, \"kongdb\"); People peopleB(peopleA); People peopleC(30, \"fdg\"); peopleC = peopleA; cout &lt;&lt; peopleB.name() &lt;&lt; endl; cout &lt;&lt; peopleC.name() &lt;&lt; endl; peopleA.setName(\"other\"); cout &lt;&lt; peopleA.name() &lt;&lt; endl; //other cout &lt;&lt; peopleB.name() &lt;&lt; endl; //crash, peopleB's name_ point memory has released cout &lt;&lt; peopleC.name() &lt;&lt; endl; //crash return 0;&#125; 此时必须重载默认拷贝构造函数和operator=（深拷贝）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class People&#123;public: People(int age, char *name) :age_(age) &#123; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125; People(const People &amp;other) &#123; cout &lt;&lt; \"copy constructor\" &lt;&lt; endl; age_ = other.age_; int len = strlen(other.name_) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, other.name_); &#125; People &amp;operator=(const People &amp;rhs) &#123; cout &lt;&lt; \"operator =\" &lt;&lt; endl; if(this == &amp;rhs) return *this; delete name_; age_ = rhs.age_; int len = strlen(rhs.name_) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, rhs.name_); return *this; &#125; ~People() &#123; delete name_; &#125; int age()&#123; return age_; &#125; char *name() &#123; return name_; &#125; void setName(char *name) &#123; if(name_) &#123; cout &lt;&lt; \"release previous name\" &lt;&lt; endl; delete name_; &#125; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125;private: char *name_; int age_;&#125;;int main()&#123; People peopleA(20, \"kongdb\"); People peopleB(peopleA); People peopleC(30, \"fdg\"); peopleC = peopleA; cout &lt;&lt; peopleB.name() &lt;&lt; endl; cout &lt;&lt; peopleC.name() &lt;&lt; endl; peopleA.setName(\"otherA\"); cout &lt;&lt; peopleA.name() &lt;&lt; endl; //other cout &lt;&lt; peopleB.name() &lt;&lt; endl; //kongdb cout &lt;&lt; peopleC.name() &lt;&lt; endl; //kongdb return 0;&#125; 为什么有了拷贝构造函数，还需要prototype参考：https://www.zhihu.com/question/52610176陈硕：Prototype 的意义在于，你拿到一个 Base* ，它指向某个 Derived 对象，你想克隆出 Derived 对象，但代码中不写出 Derived 的具体类型，因为有很多派生类，这种情况下你用构造函数是搞不定的，type-switch 是 bad smells 。另外，这里考虑 virtual 的性能损失是主次不分，构造对象需要分 配内存，这开销比一次虚函数调用大多了。Prorobuf Message 就采用了 prototype 模式，你可以参考一下。 例子1234567891011121314151617181920212223242526class Base&#123;public: virtual ~Base() &#123; printf(\"~Base\\n\");&#125;&#125;;class DerivedA : public Base&#123;public: ~DerivedA() &#123; printf(\"~DerivedA\\n\");&#125;&#125;;class DerivedB : public Base&#123;public: ~DerivedB() &#123; printf(\"~DerivedB\\n\");&#125;&#125;;int main()&#123; unique_ptr&lt;Base&gt; basePtr = make_unique&lt;DerivedA&gt;(); //很多其他的代码处理 //到了这里已经不知道basePtr的具体类型，通过typeid等方法很差 DerivedA da(*basePtr); //编译错误 return 0;&#125; 如何实现对于原型模式同样存在浅拷贝、深拷贝的问题。 1234567891011121314151617181920212223242526272829303132class Base&#123;public: virtual ~Base() &#123; printf(\"~Base\\n\");&#125; virtual void print() &#123; printf(\"this is Base\\n\");&#125;; virtual unique_ptr&lt;Base&gt; clone() &#123; return unique_ptr&lt;Base&gt;(new Base(*this)); &#125;&#125;;class Derived : public Base&#123;public: ~Derived() &#123; printf(\"~Derived\\n\");&#125; void print()&#123; printf(\"this is Derived\\n\");&#125; //上面链接的知乎大神把这里返回值设为unique&lt;Derived&gt;，不明白为什么 unique_ptr&lt;Base&gt; clone() &#123; //调用拷贝构造，若是深拷贝，还需重载拷贝函数 return unique_ptr&lt;Base&gt;(new Derived(*this)); &#125;&#125;;int main()&#123; unique_ptr&lt;Base&gt; basePtr = make_unique&lt;Derived&gt;(); //很多其他的代码处理 auto basePtr2 = basePtr-&gt;clone(); basePtr2-&gt;print();// print:this is derived return 0;&#125; 模板方法模式需要注意与建造者模式的不同，参考 建造者模式中指挥者类的作用 模板方法模式VS建造者模式 原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class AbstractClass&#123;public: virtual ~AbstractClass() &#123; printf(\"~AbstractClass\\n\");&#125; virtual void PrimitiveOperation1() = 0; virtual void PrimitiveOperation2() = 0; void TemplateMethod() &#123; PrimitiveOperation1(); PrimitiveOperation2(); &#125;&#125;;class ConcreteClassA : public AbstractClass&#123;public: ~ConcreteClassA() &#123; printf(\"~ConcreteClassA\\n\");&#125; void PrimitiveOperation1() &#123; printf(\"operation 1 of class A\\n\"); &#125; void PrimitiveOperation2() &#123; printf(\"operation 2 of class A\\n\"); &#125;&#125;;class ConcreteClassB : public AbstractClass&#123;public: ~ConcreteClassB() &#123; printf(\"~ConcreteClassB\\n\");&#125; void PrimitiveOperation1() &#123; printf(\"operation 1 of class B\\n\"); &#125; void PrimitiveOperation2() &#123; printf(\"operation 2 of class B\\n\"); &#125;&#125;;int main()&#123; auto classA = make_unique&lt;ConcreteClassA&gt;(); classA-&gt;TemplateMethod(); auto classB = make_unique&lt;ConcreteClassB&gt;(); classB-&gt;TemplateMethod(); return 0;&#125; 示例123456789101112131415161718192021222324252627282930313233343536class Paper&#123;public: virtual ~Paper() &#123; printf(\"~Paper\\n\");&#125; void question() &#123; printf(\"question is balabala, answer is %s\\n\", answer().c_str()); &#125; virtual string answer() = 0;&#125;;class StudentA : public Paper&#123;public: ~StudentA() &#123; printf(\"~StudentA\\n\");&#125; string answer() &#123; return \"A\"; &#125;&#125;;class StudentB : public Paper&#123;public: ~StudentB() &#123; printf(\"~StudentB\\n\");&#125; string answer() &#123; return \"B\"; &#125;&#125;;int main()&#123; StudentA stuA; stuA.question(); StudentB stuB; stuB.question(); return 0;&#125; 外观模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class SubSystemOne&#123;public: ~SubSystemOne()&#123;printf(\"~SubSystemOne\\n\");&#125; void methodOne() &#123; printf(\"method one\\n\"); &#125;&#125;;class SubSystemTwo&#123;public: ~SubSystemTwo()&#123;printf(\"~SubSystemTwo\\n\");&#125; void methodTwo() &#123; printf(\"method two\\n\"); &#125;&#125;;class SubSystemThree&#123;public: ~SubSystemThree()&#123;printf(\"~SubSystemThree\\n\");&#125; void methodThree() &#123; printf(\"method three\\n\"); &#125;&#125;;class SubSystemFour&#123;public: ~SubSystemFour()&#123; printf(\"~SubSystemFour\\n\");&#125; void methodFour() &#123; printf(\"method four\\n\"); &#125;&#125;;class Facade&#123;public: Facade() &#123; sysOne_ = make_unique&lt;SubSystemOne&gt;(); sysTwo_ = make_unique&lt;SubSystemTwo&gt;(); sysThree_ = make_unique&lt;SubSystemThree&gt;(); sysFour_ = make_unique&lt;SubSystemFour&gt;(); &#125; ~Facade()&#123;printf(\"~Facade\\n\");&#125; void methodA() &#123; sysOne_-&gt;methodOne(); sysFour_-&gt;methodFour(); &#125; void methodB() &#123; sysTwo_-&gt;methodTwo(); sysThree_-&gt;methodThree(); &#125;private: unique_ptr&lt;SubSystemOne&gt; sysOne_; unique_ptr&lt;SubSystemTwo&gt; sysTwo_; unique_ptr&lt;SubSystemThree&gt; sysThree_; unique_ptr&lt;SubSystemFour&gt; sysFour_;&#125;;int main()&#123; auto facade = make_unique&lt;Facade&gt;(); facade-&gt;methodA(); facade-&gt;methodB(); return 0;&#125; 建造者模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class Product&#123;public: ~Product()&#123; printf(\"~Product\\n\");&#125; void addParts(string part) &#123; parts_.push_back(part); &#125; void show() &#123; auto i = parts_.begin(); while(i != parts_.end()) &#123; printf(\"%s\\n\", i-&gt;c_str()); i++; &#125; &#125;private: list&lt;string&gt; parts_;&#125;;class Builder&#123;public: virtual ~Builder() &#123;printf(\"~Builder\\n\");&#125; virtual void stepA() = 0; virtual void stepB() = 0; virtual void getResult() = 0;protected: &#125;;class ConcreteBuilderA : public Builder&#123;public: ConcreteBuilderA() &#123; product_ = make_unique&lt;Product&gt;(); &#125; ~ConcreteBuilderA() &#123;printf(\"~ConcreteBuilderA\\n\");&#125; void stepA() &#123; product_-&gt;addParts(\"parts A\"); &#125; void stepB() &#123; product_-&gt;addParts(\"parts B\"); &#125; void getResult() &#123; product_-&gt;show(); &#125;private: unique_ptr&lt;Product&gt; product_;&#125;;class ConcreteBuilderB : public Builder&#123;public: ConcreteBuilderB() &#123; product_ = make_unique&lt;Product&gt;(); &#125; ~ConcreteBuilderB() &#123;printf(\"~ConcreteBuilderB\\n\");&#125; void stepA() &#123; product_-&gt;addParts(\"parts X\"); &#125; void stepB() &#123; product_-&gt;addParts(\"parts Y\"); &#125; void getResult() &#123; product_-&gt;show(); &#125;private: unique_ptr&lt;Product&gt; product_;&#125;;class Director&#123;public: ~Director()&#123; printf(\"~Director\\n\");&#125; void Construct(unique_ptr&lt;Builder&gt; &amp;builder) &#123; builder-&gt;stepA(); builder-&gt;stepB(); &#125;&#125;;int main()&#123; auto director = make_unique&lt;Director&gt;(); unique_ptr&lt;Builder&gt; builderA = make_unique&lt;ConcreteBuilderA&gt;(); director-&gt;Construct(builderA); builderA-&gt;getResult(); unique_ptr&lt;Builder&gt; builderB = make_unique&lt;ConcreteBuilderB&gt;(); director-&gt;Construct(builderB); builderB-&gt;getResult(); return 0;&#125; 观察者模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Observer&#123;public: virtual ~Observer() &#123; printf(\"~Observer\\n\");&#125; virtual void update() = 0;&#125;;class Subject&#123;public: virtual ~Subject()&#123; printf(\"~Subject\\n\");&#125; void attach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.push_back(observer); &#125; void detach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.remove(observer); &#125; void notify() &#123; for(auto &amp;observer : observers_) observer-&gt;update(); &#125;private: list&lt;shared_ptr&lt;Observer&gt;&gt; observers_;&#125;;class ConcreteSubject : public Subject&#123;public: void setState(string state) &#123; state_ = state; &#125; const char *state() &#123; return state_.c_str(); &#125;private: string state_;&#125;;class ConcreteObserver : public Observer&#123;public: ConcreteObserver(shared_ptr&lt;ConcreteSubject&gt; sub, string name) &#123; sub_ = sub; name_ = name; &#125; void update() &#123; printf(\"observer %s new state is:%s\\n\", name_.c_str(), sub_.lock()-&gt;state()); &#125;private: weak_ptr&lt;ConcreteSubject&gt; sub_; string name_;&#125;;int main()&#123; auto sub = make_shared&lt;ConcreteSubject&gt;(); sub-&gt;attach(make_shared&lt;ConcreteObserver&gt;(sub, \"X\")); sub-&gt;attach(make_shared&lt;ConcreteObserver&gt;(sub, \"Y\")); sub-&gt;attach(make_shared&lt;ConcreteObserver&gt;(sub, \"Z\")); sub-&gt;setState(\"abc\"); sub-&gt;notify(); return 0;&#125; 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101class Observer;class Subject&#123;public: virtual ~Subject()&#123; printf(\"~Subject\\n\");&#125; virtual void attach(shared_ptr&lt;Observer&gt;) = 0; virtual void detach(shared_ptr&lt;Observer&gt;) = 0; virtual void notify() = 0; virtual void setState(string) = 0; virtual const char *state() = 0;&#125;;class Observer&#123;public: Observer(string name, shared_ptr&lt;Subject&gt; sub) &#123; name_ = name; sub_ = sub; &#125; virtual ~Observer()&#123; printf(\"~Observer\\n\");&#125; virtual void update() = 0;protected: string name_; weak_ptr&lt;Subject&gt; sub_;&#125;;class Boss : public Subject&#123;public: ~Boss()&#123; printf(\"~Boss\\n\");&#125; void attach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.push_back(observer); &#125; void detach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.remove(observer); &#125; void notify() &#123; auto i = observers_.begin(); while(i != observers_.end()) &#123; (*i)-&gt;update(); ++i; &#125; &#125; void setState(string state)&#123; state_ = state;&#125; const char *state()&#123; return state_.c_str();&#125;private: string state_; list&lt;shared_ptr&lt;Observer&gt;&gt; observers_;&#125;;class StockObserver : public Observer&#123;public: StockObserver(string name, shared_ptr&lt;Subject&gt; sub) :Observer(name, sub) &#123;&#125; ~StockObserver()&#123; printf(\"~StockObserver\\n\");&#125; void update() &#123; printf(\"%s, %s close stock \\n\", sub_.lock()-&gt;state(), name_.c_str()); &#125;&#125;;class NBAObserver : public Observer&#123;public: NBAObserver(string name, shared_ptr&lt;Subject&gt; sub) :Observer(name, sub) &#123;&#125; ~NBAObserver()&#123; printf(\"~NBAObserver\\n\");&#125; void update() &#123; printf(\"%s, %s close NBA \\n\", sub_.lock()-&gt;state(), name_.c_str()); &#125;&#125;;int main()&#123; auto huhansan = make_shared&lt;Boss&gt;(); auto kdb = make_shared&lt;StockObserver&gt;(\"kdb\", huhansan); auto fxdpig = make_shared&lt;NBAObserver&gt;(\"fxdpig\", huhansan); huhansan-&gt;attach(kdb); huhansan-&gt;attach(fxdpig); huhansan-&gt;detach(fxdpig); huhansan-&gt;setState(\"I'm back\"); huhansan-&gt;notify(); return 0;&#125; 观察者模式使用的还是很多的，比如/chromium/ash/system/tray/system_tray_notifier.cc 抽象工厂模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class AbstractProductA&#123;public: virtual ~AbstractProductA() &#123; printf(\"~AbstractProductA\\n\");&#125;&#125;;class AbstractProductB&#123;public: virtual ~AbstractProductB() &#123; printf(\"~AbstractProductB\\n\");&#125;&#125;;class AbstractFactory&#123;public: virtual ~AbstractFactory() &#123; printf(\"~AbstractFactory\\n\");&#125; virtual unique_ptr&lt;AbstractProductA&gt; createProductA() = 0; virtual unique_ptr&lt;AbstractProductB&gt; createProductB() = 0;&#125;;class ProductA1 : public AbstractProductA&#123;public: ProductA1()&#123;printf(\"ProductA1 constructed\\n\");&#125; ~ProductA1() &#123; printf(\"~ProductA1\\n\");&#125;&#125;;class ProductA2 : public AbstractProductA&#123;public: ProductA2()&#123;printf(\"ProductA2 constructed\\n\");&#125; ~ProductA2() &#123; printf(\"~ProductA2\\n\");&#125;&#125;;class ProductB1 : public AbstractProductB&#123;public: ProductB1()&#123;printf(\"ProductB1 constructed\\n\");&#125; ~ProductB1() &#123; printf(\"~ProductB1\\n\");&#125;&#125;;class ProductB2 : public AbstractProductB&#123;public: ProductB2()&#123;printf(\"ProductB2 constructed\\n\");&#125; ~ProductB2() &#123; printf(\"~ProductB2\\n\");&#125;&#125;;class ConcreteFactory1 : public AbstractFactory&#123;public: ~ConcreteFactory1() &#123; printf(\"~ConcreteFactory1\\n\");&#125; unique_ptr&lt;AbstractProductA&gt; createProductA() &#123; return make_unique&lt;ProductA1&gt;(); &#125; unique_ptr&lt;AbstractProductB&gt; createProductB() &#123; return make_unique&lt;ProductB1&gt;(); &#125;&#125;;class ConcreteFactory2 : public AbstractFactory&#123;public: ~ConcreteFactory2() &#123; printf(\"~ConcreteFactory2\\n\");&#125; unique_ptr&lt;AbstractProductA&gt; createProductA() &#123; return make_unique&lt;ProductA2&gt;(); &#125; unique_ptr&lt;AbstractProductB&gt; createProductB() &#123; return make_unique&lt;ProductB2&gt;(); &#125;&#125;;int main()&#123; auto factory1 = make_unique&lt;ConcreteFactory1&gt;(); factory1-&gt;createProductA(); factory1-&gt;createProductB(); auto factory2 = make_unique&lt;ConcreteFactory2&gt;(); factory2-&gt;createProductA(); factory2-&gt;createProductB(); return 0;&#125; 状态模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;memory&gt;class Context;class State&#123;public: virtual ~State()&#123;&#125; virtual void handle(Context *ctx) = 0; virtual const char *name() const = 0;&#125;;class Context&#123;public: Context(std::shared_ptr&lt;State&gt; state) : state_(state) &#123;&#125; ~Context()&#123;&#125; void request() &#123; state_-&gt;handle(this); &#125; void setState(std::shared_ptr&lt;State&gt; state) &#123; state_ = state; printf(\"state change to %s\\n\", state_-&gt;name()); &#125;private: std::shared_ptr&lt;State&gt; state_;&#125;;class ConcreteStateA : public State&#123;public: ~ConcreteStateA()&#123;&#125; const char *name() const &#123; return \"StateA\";&#125; void handle(Context *ctx);&#125;;class ConcreteStateB : public State&#123;public: ~ConcreteStateB()&#123;&#125; const char *name() const &#123; return \"StateB\";&#125; void handle(Context *ctx);&#125;;void ConcreteStateA::handle(Context *ctx)&#123; if(ctx) ctx-&gt;setState(std::make_shared&lt;ConcreteStateB&gt;());&#125;void ConcreteStateB::handle(Context *ctx)&#123; if(ctx) ctx-&gt;setState(std::make_shared&lt;ConcreteStateA&gt;());&#125;int main()&#123; Context ctx(std::make_shared&lt;ConcreteStateA&gt;()); ctx.request(); ctx.request(); ctx.request(); return 0;&#125; 适配器模式原型1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;memory&gt;class Target&#123;public: virtual ~Target()&#123;&#125; void request() &#123; printf(\"normal request\\n\");&#125;&#125;;class Adaptee&#123;public: void specifiedRequest() &#123; printf(\"specified request\\n\");&#125;&#125;;class Adapter : public Target&#123;public: Adapter() &#123; adaptee_ = std::make_unique&lt;Adaptee&gt;(); &#125; void request() &#123; adaptee_-&gt;specifiedRequest(); &#125;private: std::unique_ptr&lt;Adaptee&gt; adaptee_;&#125;;int main()&#123; auto target = std::make_unique&lt;Adapter&gt;(); target-&gt;request(); return 0;&#125; 备忘录模式原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;memory&gt;struct Memento&#123; int state_;&#125;;class Originator&#123;public: ~Originator()&#123;printf(\"~Originator\\n\");&#125; std::shared_ptr&lt;Memento&gt; createMemento() &#123; auto memento = std::make_shared&lt;Memento&gt;(); memento-&gt;state_ = state_; return memento; &#125; void resetMemento(const std::shared_ptr&lt;Memento&gt; &amp;memento) &#123; state_ = memento-&gt;state_; &#125; void setState(int state) &#123; state_ = state;&#125; int state() &#123; return state_; &#125;private: int state_;&#125;;class Caretaker&#123;public: void setMemento(std::shared_ptr&lt;Memento&gt; memento) &#123; memento_ = memento; &#125; std::shared_ptr&lt;Memento&gt; getMemento() &#123; return memento_; &#125;private: std::shared_ptr&lt;Memento&gt; memento_;&#125;;int main()&#123; Originator origin; Caretaker taker; taker.setMemento(origin.createMemento()); origin.setState(5); origin.resetMemento(taker.getMemento()); return 0;&#125; 书上Memento是写成类的，但我觉得因为备忘录纯粹为了存储数据，或许用结构体更合适。只有Caretaker类是否需要，根据实际情况而定。 实例以memento为关键字搜索chromium源码，找到如下示例 12345678BrotliBitReaderState memento;BrotliBitReaderSaveState(br, &amp;memento);//保存数据if (!SafeReadSymbol(type_tree, br, &amp;block_type)) return BROTLI_FALSE;if (!SafeReadBlockLength(s, &amp;s-&gt;block_length[tree_type], len_tree, br)) &#123; s-&gt;substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_NONE; BrotliBitReaderRestoreState(br, &amp;memento);//重置数据 return BROTLI_FALSE;&#125; 其中BrotliBitReaderState声明如下123456typedef struct &#123; reg_t val_; uint32_t bit_pos_; const uint8_t* next_in; size_t avail_in;&#125; BrotliBitReaderState; 组合模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;list&gt;class Component&#123;public: Component(std::string name) : name_(name) &#123;&#125; virtual ~Component() &#123;printf(\"~Component\\n\");&#125; virtual void add(std::shared_ptr&lt;Component&gt;) = 0; virtual void remove(std::shared_ptr&lt;Component&gt;) = 0; virtual void display(int depth) = 0;protected: std::string name_;&#125;;class Leaf : public Component&#123;public: Leaf(std::string name) : Component(name) &#123;&#125; ~Leaf() &#123; printf(\"~Leaf\\n\");&#125; void add(std::shared_ptr&lt;Component&gt;) &#123; printf(\"Leaf do not support add\\n\");&#125; void remove(std::shared_ptr&lt;Component&gt;) &#123; printf(\"Leaf do not support remove\\n\");&#125; void display(int depth) &#123; for(int i = 0; i &lt; depth; ++i) printf(\"-\"); printf(\"%s\\n\", name_.c_str()); &#125;&#125;;class Composite : public Component&#123;public: Composite(std::string name) : Component(name) &#123;&#125; ~Composite() &#123;printf(\"~Composite\\n\");&#125; void add(std::shared_ptr&lt;Component&gt; comp) &#123; components_.push_back(comp); &#125; void remove(std::shared_ptr&lt;Component&gt; comp) &#123; components_.remove(comp); &#125; void display(int depth) &#123; for(int i = 0; i &lt; depth; ++i) printf(\"-\"); printf(\"%s\\n\", name_.c_str()); for(auto i : components_) i-&gt;display(depth + 1); &#125;private: std::list&lt;std::shared_ptr&lt;Component&gt;&gt; components_;&#125;;int main()&#123; auto bj = std::make_shared&lt;Composite&gt;(\"beijing\"); bj-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); bj-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); auto sh = std::make_shared&lt;Composite&gt;(\"shanghai\"); bj-&gt;add(sh); sh-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); sh-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); auto nj = std::make_shared&lt;Composite&gt;(\"nanjing\"); nj-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); nj-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); auto hz = std::make_shared&lt;Composite&gt;(\"hangzhou\"); hz-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); hz-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); sh-&gt;add(nj); sh-&gt;add(hz); bj-&gt;display(0); return 0;&#125; 迭代器模式感觉没啥用，不如直接用stl里的 单例模式原型123456789101112131415161718192021222324#include &lt;stdio.h&gt;class Singleton&#123;public: static Singleton *instance() &#123; if(instance_ == nullptr) instance_ = new Singleton; return instance_; &#125; void display()&#123;printf(\"this is Singleton\\n\");&#125;private: static Singleton *instance_; Singleton() &#123; printf(\"Singleton constructor\\n\");&#125;&#125;;Singleton *Singleton::instance_ = nullptr;int main()&#123; Singleton::instance()-&gt;display(); return 0;&#125; 多线程时的单例模式如果两个线程同时调用instance()函数，极有可能导致Singleton被初始化两次。违背了单例模式的意图。可通过双重锁定解决这种问题 1234567891011121314#include &lt;mutex&gt;static Singleton *instance()&#123; if(instance_ == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if(instance_ == nullptr) &#123; instance_ = new Singleton; &#125; &#125; return instance_;&#125; 《C++并发编程实战》中说这种双重锁是声名狼藉的，也就是不好的。没有完全理解为什么这么说。 桥接模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Implementor&#123;public: virtual ~Implementor() &#123; printf(\"~Implementor\\n\");&#125; virtual void operation() = 0;&#125;;class Abstraction&#123;public: virtual ~Abstraction() &#123; printf(\"~Abstraction\\n\");&#125; void setImpl(std::shared_ptr&lt;Implementor&gt; impl) &#123; impl_ = impl; &#125; virtual void operation() = 0;protected: std::shared_ptr&lt;Implementor&gt; impl_;&#125;;class RedifinedAbstraction : public Abstraction&#123;public: ~RedifinedAbstraction() &#123; printf(\"~RedifinedAbstraction\\n\");&#125; void operation() &#123; if(impl_) impl_-&gt;operation(); &#125;&#125;;class ConcreteImplementorA : public Implementor&#123;public: ~ConcreteImplementorA() &#123; printf(\"~ConcreteImplementorA\\n\");&#125; void operation() &#123; printf(\"operation A called\\n\");&#125;&#125;;class ConcreteImplementorB : public Implementor&#123;public: ~ConcreteImplementorB() &#123; printf(\"~ConcreteImplementorB\\n\");&#125; void operation() &#123; printf(\"operation B called\\n\");&#125;&#125;;int main()&#123; auto caller = std::make_unique&lt;RedifinedAbstraction&gt;(); auto implA = std::make_shared&lt;ConcreteImplementorA&gt;(); auto implB = std::make_shared&lt;ConcreteImplementorB&gt;(); caller-&gt;setImpl(implA); caller-&gt;operation(); caller-&gt;setImpl(implB); caller-&gt;operation(); return 0;&#125; 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;memory&gt;class App&#123;public: virtual ~App() &#123; printf(\"~App\\n\");&#125; virtual void run() = 0;&#125;;class Phone&#123;public: Phone() : app_(nullptr) &#123;&#125; virtual ~Phone() &#123; printf(\"~Phone\\n\");&#125; void setApp(std::shared_ptr&lt;App&gt; app) &#123; app_ = app; &#125; virtual void run() = 0;protected: std::shared_ptr&lt;App&gt; app_;&#125;;class WangZheRongYao : public App&#123;public: ~WangZheRongYao() &#123; printf(\"~WangZheRongYao\\n\");&#125; void run() &#123; printf(\"run wang zhe rong yao\\n\");&#125;&#125;;class ZhiFuBao : public App&#123;public: ~ZhiFuBao() &#123; printf(\"~ZhiFuBao\\n\");&#125; void run() &#123; printf(\"run zhi fu bao\\n\");&#125;&#125;;class HuaWei : public Phone&#123;public: ~HuaWei() &#123; printf(\"~HuaWei\\n\");&#125; void run() &#123; if(app_) &#123; printf(\"current phone is huawei, \"); app_-&gt;run(); &#125; &#125;&#125;;class XioMi : public Phone&#123;public: ~XioMi() &#123; printf(\"~XioMi\\n\");&#125; void run() &#123; if(app_) &#123; printf(\"curren phone is xioami, \"); app_-&gt;run(); &#125; &#125;&#125;;int main()&#123; auto huawei = std::make_unique&lt;HuaWei&gt;(); auto xiaomi = std::make_unique&lt;XioMi&gt;(); auto wzry = std::make_shared&lt;WangZheRongYao&gt;(); auto zfb = std::make_shared&lt;ZhiFuBao&gt;(); huawei-&gt;setApp(wzry); huawei-&gt;run(); huawei-&gt;setApp(zfb); huawei-&gt;run(); xiaomi-&gt;setApp(wzry); xiaomi-&gt;run(); xiaomi-&gt;setApp(zfb); xiaomi-&gt;run(); return 0;&#125; 命令模式原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Receiver&#123;public: virtual ~Receiver() &#123; printf(\"~Receiver\\n\");&#125; void action() &#123; printf(\"recver action\\n\");&#125;&#125;;class Command&#123;public: explicit Command(std::shared_ptr&lt;Receiver&gt; recver) : recver_(recver) &#123;&#125; virtual ~Command () &#123; printf(\"~Command\\n\");&#125; virtual void execute() = 0;protected: std::shared_ptr&lt;Receiver&gt; recver_;&#125;;class ConcreteCommand : public Command&#123;public: explicit ConcreteCommand(std::shared_ptr&lt;Receiver&gt; recver) : Command(recver) &#123;&#125; ~ConcreteCommand() &#123; printf(\"~ConcreteCommand\\n\");&#125; void execute() &#123; if(recver_) recver_-&gt;action(); &#125;&#125;;class Invoker&#123;public: void setCommand(std::shared_ptr&lt;Command&gt; cmd) &#123; cmd_ = cmd; &#125; void notify() &#123; if(cmd_) cmd_-&gt;execute(); &#125;private: std::shared_ptr&lt;Command&gt; cmd_;&#125;;int main()&#123; Invoker invoker; auto recver = std::make_shared&lt;Receiver&gt;(); auto cmd = std::make_shared&lt;ConcreteCommand&gt;(recver); invoker.setCommand(cmd); invoker.notify(); return 0;&#125; 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;memory&gt;#include &lt;list&gt;class Barbecuer&#123;public: ~Barbecuer() &#123; printf(\"~Barbecuer\\n\");&#125; void bakeMutton() &#123; printf(\"bake mutton\\n\");&#125; void bakeChicken() &#123; printf(\"bake chicken\\n\");&#125;&#125;;class Command&#123;public: explicit Command(std::shared_ptr&lt;Barbecuer&gt; recver) : recver_(recver) &#123;&#125; virtual ~Command() &#123; printf(\"~Command\\n\");&#125; virtual void execute() = 0;protected: std::shared_ptr&lt;Barbecuer&gt; recver_;&#125;;class MuttonCommand : public Command&#123;public: explicit MuttonCommand(std::shared_ptr&lt;Barbecuer&gt; recver) : Command(recver) &#123;&#125; ~MuttonCommand() &#123; printf(\"~MuttonCommand\\n\");&#125; void execute() &#123; if(recver_) recver_-&gt;bakeMutton(); &#125;&#125;;class ChickedCommand : public Command&#123;public: explicit ChickedCommand(std::shared_ptr&lt;Barbecuer&gt; recver) : Command(recver) &#123;&#125; ~ChickedCommand() &#123; printf(\"~ChickedCommand\\n\");&#125; void execute() &#123; if(recver_) recver_-&gt;bakeChicken(); &#125;&#125;;class Waiter&#123;public: void addOrder(std::shared_ptr&lt;Command&gt; cmd) &#123; cmds_.push_back(cmd); &#125; void cancelOrder(std::shared_ptr&lt;Command&gt; cmd) &#123; cmds_.remove(cmd); &#125; void notify() &#123; for(auto &amp; cmd : cmds_) cmd-&gt;execute(); &#125;private: std::list&lt;std::shared_ptr&lt;Command&gt;&gt; cmds_;&#125;;int main()&#123; Waiter mm; auto gg = std::make_shared&lt;Barbecuer&gt;(); auto muttonCmd = std::make_shared&lt;MuttonCommand&gt;(gg); auto chickenCmd = std::make_shared&lt;ChickedCommand&gt;(gg); mm.addOrder(muttonCmd); mm.addOrder(chickenCmd); mm.cancelOrder(muttonCmd); mm.notify();&#125; 职责连模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;memory&gt;class Handler&#123;public: virtual ~Handler() &#123; printf(\"~Handler\\n\");&#125; virtual void handleRequest(int level) = 0; void setSuccessor(std::shared_ptr&lt;Handler&gt; successor) &#123; successor_ = successor; &#125;protected: std::shared_ptr&lt;Handler&gt; successor_;&#125;;class ConcreteHandlerA : public Handler&#123;public: ~ConcreteHandlerA() &#123; printf(\"~ConcreteHandlerA\\n\");&#125; void handleRequest(int level) &#123; if(level &lt; 10) printf(\"request handle by A\\n\"); else if(successor_) successor_-&gt;handleRequest(level); &#125;&#125;;class ConcreteHandlerB : public Handler&#123;public: ~ConcreteHandlerB() &#123; printf(\"~ConcreteHandlerB\\n\");&#125; void handleRequest(int level) &#123; printf(\"request handle by B\\n\"); &#125;&#125;;int main()&#123; auto handlerA = std::make_shared&lt;ConcreteHandlerA&gt;(); auto handlerB = std::make_shared&lt;ConcreteHandlerB&gt;(); handlerA-&gt;setSuccessor(handlerB); handlerA-&gt;handleRequest(5); handlerA-&gt;handleRequest(20);&#125; 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081struct Request&#123; std::string type; int num;&#125;;class Manager&#123;public: Manager() : super_(nullptr) &#123;&#125; virtual ~Manager() &#123; printf(\"~Manager\\n\");&#125; void setSuperior(std::shared_ptr&lt;Manager&gt; super) &#123; super_ = super; &#125; virtual void handleRequest(const Request &amp;req) = 0;protected: std::shared_ptr&lt;Manager&gt; super_;&#125;;class Jinli : public Manager&#123;public: ~Jinli() &#123; printf(\"~Jinli\\n\");&#125; void handleRequest(const Request &amp;req) &#123; if(req.type == \"qingjia\" &amp;&amp; req.num &lt;= 10) printf(\"qingjia %d day passed by Jinli\\n\", req.num); else if(super_) super_-&gt;handleRequest(req); &#125;&#125;;class ZongJinli : public Manager&#123;public: ~ZongJinli() &#123; printf(\"~Zongjinli\\n\");&#125; void handleRequest(const Request &amp;req) &#123; if(req.type == \"qingjia\" &amp;&amp; req.num &lt;= 100) printf(\"qingjia %d day passed by ZongJinli\\n\", req.num); else if(super_) super_-&gt;handleRequest(req); &#125;&#125;;class Boss : public Manager&#123;public: ~Boss() &#123; printf(\"~Boss\\n\");&#125; void handleRequest(const Request &amp;req) &#123; if(req.type == \"qingjia\") printf(\"qingjia %d day passed by Boss\\n\", req.num); else if(req.type == \"zhanggongzi\" &amp;&amp; req.num &lt;= 1000) printf(\"zhanggongzi %d yuan passed by Boss\\n\", req.num); else if(req.type == \"zhanggongzi\" &amp;&amp; req.num &gt; 1000) printf(\"shao nian zai deng deng ba\\n\"); &#125;&#125;;int main()&#123; auto jinli = std::make_shared&lt;Jinli&gt;(); auto zongjinli = std::make_shared&lt;ZongJinli&gt;(); auto boss = std::make_shared&lt;Boss&gt;(); jinli-&gt;setSuperior(zongjinli); zongjinli-&gt;setSuperior(boss); Request req; req.type = \"qingjia\"; req.num = 3; jinli-&gt;handleRequest(req); req.type = \"qingjia\"; req.num = 20; jinli-&gt;handleRequest(req); req.type = \"qingjia\"; req.num = 365; jinli-&gt;handleRequest(req); req.type = \"zhanggongzi\"; req.num = 500; jinli-&gt;handleRequest(req); req.type = \"zhanggongzi\"; req.num = 10000; jinli-&gt;handleRequest(req);&#125; 中介者模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;memory&gt;class Colleague;class Mediator&#123;public: virtual ~Mediator() &#123; printf(\"~Mediator\\n\");&#125; virtual void send(const Colleague *, const std::string &amp;) const = 0;&#125;;class Colleague&#123;public: explicit Colleague(std::shared_ptr&lt;Mediator&gt; mediator) : mediator_(mediator) &#123;&#125; virtual ~Colleague() &#123; printf(\"~Colleague\\n\");&#125; virtual void sendMsg(const std::string &amp;msg) const = 0; virtual void notify(const std::string &amp;msg) const = 0;protected: std::shared_ptr&lt;Mediator&gt; mediator_;&#125;;class ConcreteColleagueA : public Colleague&#123;public: explicit ConcreteColleagueA(std::shared_ptr&lt;Mediator&gt; mediator) : Colleague(mediator) &#123;&#125; ~ConcreteColleagueA() &#123; printf(\"~ConcreteColleagueA\\n\");&#125; void sendMsg(const std::string &amp;msg) const &#123; printf(\"colleague A send msg:%s\\n\", msg.c_str()); mediator_-&gt;send(this, msg); &#125; void notify(const std::string &amp;msg) const &#123; printf(\"colleague A get msg:%s\\n\", msg.c_str()); &#125;&#125;;class ConcreteColleagueB : public Colleague&#123;public: explicit ConcreteColleagueB(std::shared_ptr&lt;Mediator&gt; mediator) : Colleague(mediator) &#123;&#125; ~ConcreteColleagueB() &#123; printf(\"~ConcreteColleagueB\\n\");&#125; void sendMsg(const std::string &amp;msg) const &#123; printf(\"colleague B send msg:%s\\n\", msg.c_str()); mediator_-&gt;send(this, msg); &#125; void notify(const std::string &amp;msg) const &#123; printf(\"colleague B get msg:%s\\n\", msg.c_str()); &#125;&#125;;class ConcreteMediator : public Mediator&#123;public: ~ConcreteMediator() &#123; printf(\"~ConcreteMediator\\n\");&#125; void setColleagueA(ConcreteColleagueA *ca) &#123; colleagueA_ = ca; &#125; void setColleagueB(ConcreteColleagueB *cb) &#123; colleagueB_ = cb; &#125; void send(const Colleague *colleague, const std::string &amp;msg) const &#123; if(colleague == colleagueA_) colleagueB_-&gt;notify(msg); else if(colleague == colleagueB_) colleagueA_-&gt;notify(msg); &#125;private: ConcreteColleagueA *colleagueA_; ConcreteColleagueB *colleagueB_;&#125;;int main()&#123; auto mediator = std::make_shared&lt;ConcreteMediator&gt;(); auto colleagueA = std::make_unique&lt;ConcreteColleagueA&gt;(mediator); auto colleagueB = std::make_unique&lt;ConcreteColleagueB&gt;(mediator); mediator-&gt;setColleagueA(colleagueA.get()); mediator-&gt;setColleagueB(colleagueB.get()); colleagueA-&gt;sendMsg(\"How are you!\"); colleagueB-&gt;sendMsg(\"Fine, thank you, and you!\"); return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"统计超大文件中字符串出现次数","date":"2017-11-25T11:50:17.000Z","path":"2017/11/25/统计超大文件中字符串出现次数/","text":"背景：有一个超大的文件，需要统计里面某个字符串出现的次数 注：下文中的log.txt为500万行左右 Python实现逐行读取方式（单线程）1234567891011count = 0def getCountInFile(fname, s): global count with open(fname, 'rb') as f: for line in f: count += line.count(s)if __name__ == '__main__': getCountInFile('log.txt', b'kongdb') print('total count is:%d' % count) 使用Ipython timeit命令得出时间大概在2.8s 123456%timeit %run single_thread_1.pytotal count is:884736total count is:884736total count is:884736total count is:8847361 loop, best of 3: 2.78 s per loop 逐块读取方式（单线程）1234567891011121314151617181920import oscount = 0#逐块读取，每块的大小CHUNK_SIZE = 500000def getCountInFile(fname, s): global count #先获取文件总大小 total_size = os.path.getsize(fname) with open(fname, 'rb') as f: #分块 piece_count = int(total_size/CHUNK_SIZE) + 1 for i in range(piece_count): content = f.read(CHUNK_SIZE) count += content.count(s)if __name__ == '__main__': getCountInFile('log.txt', b'kongdb') print('total count is:%d' % count) 使用Ipython timeit命令得出时间大概在80ms 1234567%timeit %run single_thread_2.pytotal count is:884736total count is:884736...total count is:884736total count is:88473610 loops, best of 3: 79.3 ms per loop 不过我想了一下，这样分块可能会存在这样一个问题。 比如第n块的最后一个字母是’k’，而第n+1块的前几个字母是’ongdb’，即分的块正好把待查询的子块切割了。这样就会导致子块遗漏了。 想了以下的解决办法，可能不是太好。 123456789...current_pos = 0for i in range(piece_count): content = f.read(CHUNK_SIZE) count += content.count(s) #每次读完一个子块之后，位置向后退\"子串长度减1\"个字符 current_pos += CHUNK_SIZE - len(s) + 1 f.seek(current_pos)... 逐行读取方式（多线程）尝试使一个线程从某一个固定行开始读取，但是因为Python没有从某一行开始读取的方法。只能使用next(f)这种方法来跳过前n行。但这样并不能使时间减少。放弃 也有可能是我使用的方法不对。 逐块读取方式（多线程）Python有seek方法来跳过前n个字符。所以思路就是： 每个线程都有一个start属性 先跳过前start个字符 读取一个固定大小的块，并计算count 合并各个线程的结果 123456789101112131415161718192021222324252627282930313233import osimport threadingg_lock = threading.Lock()count = 0#逐块读取，每块的大小CHUNK_SIZE = 500000def getCountInFile(fname, start, s): with open(fname, 'rb') as f: f.seek(start) content = f.read(CHUNK_SIZE + len(s) -1) if not content: return with g_lock: global count count += content.count(s)#线程列表threads = []if __name__ == '__main__': fname = 'log.txt' #先获取文件总大小 total_size = os.path.getsize(fname) for i in range(int(total_size/CHUNK_SIZE) + 1): t = threading.Thread(target=getCountInFile, args=(fname, i*CHUNK_SIZE, b'kongdb')) threads.append(t) for t in threads: t.start() for t in threads: t.join() print('total count is:%d' % count) 想法很天真，然鹅 1234567%timeit %run multithread_thread_1.pytotal count is:884736total count is:884736...total count is:884736total count is:88473610 loops, best of 3: 105 ms per loop 时间并没有实际缩短，还增加了大约20ms，汗。 是因为Python的GIL限制了呢，还是我的使用方法不正确呢。 C++实现C++ std里的读写文件用的不是很多，但理所当然的觉得C++肯定要比Python快吧 然而结果好像并不是这样的。 先实现统计子串次数的函数 123456789101112131415161718#include \"stdafx.h\"#include &lt;string&gt;#include &lt;stdio.h&gt;//统计子串出现次数int getStrCount(const char *src, const char *sub)&#123; int len = strlen(sub); if (src == nullptr || sub == nullptr || strlen(src) == 0 || len == 0) return 0; int num = 0; while (src = strstr(src, sub)) &#123; num++; src += len; &#125; return num;&#125; 逐行读取方式（单线程）12345678910111213141516171819202122#include &lt;fstream&gt;#include&lt;windows.h&gt;static int count = 0;void getCountInFile(const char *fname, const char *sub)&#123; std::ifstream f(fname); while (!f.eof()) &#123; char line[51] = \"\\0\"; f.getline(line, 50); count += getStrCount(line, sub); &#125;&#125;int main()&#123; int start = GetTickCount(); getCountInFile(\"log.txt\", \"kongdb\"); int end = GetTickCount(); printf(\"time elapse:%d\\n\", end - start); printf(\"total count is:%d\\n\", count); return 0;&#125; 其中使用GetTickCount函数来计算性能 结果如下 time elapse:8531total count:884736 大约是8.5s，竟然比Python的逐行读取慢这么多，不科学啊。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python数据分析与展示笔记","date":"2017-11-17T11:50:17.000Z","path":"2017/11/17/Python数据分析与展示笔记/","text":"IPython常用命令 常用命令 说明 ? 查看变量名函数名 %run 执行某个python文件 %magic 显示所有魔术命令 %hist IPython命令的输入历史 %pdb 异常发生后自动进入调试器 %reset 删除当前命名空间中的全部变量和名称 %who 显示当前命名空间中已经定义的变量 %time 给出代码的执行时间 %timeit 多次执行代码，计算综合平均执行时间 NumPy库一般导入方法 1import numpy as np ndarray类型**数组对象可以去掉元素间运算所需的循环，使一维向量更像单个数据 123a = np.array([1, 3, 5])b = np.array([2, 4, 6])c = a**2 + b**3 **设置专门的数组对象，经过优化，可以提升运算速度 **数组对象采用相同的数据类型，有助于节省运算和存储空间 ndarray是一个多维数组对象，由两部分组成 实际的数据 描述这些数据的元数据（数据维度、数据类型等） ndarray对象的属性 属性 说明 ndim 秩，即轴的数量或维度的数量 shape 对象的尺度，对于矩阵，n行m列 size 对象元素的个数，相当于shape的n*m dtype 对象的元素类型 itemsize 对象中每个元素的大小，以字节为单位 ndarray的元素类型 数据类型 说明 bool True或False intc 与C语言中的int类型一致，一般是int32或int64 intp 用于索引的整数 int8 字节字节长度的整数[-128, 127] int16,int32,int64 对应长度类型的整数 uint8,uint16,uint32,uint32,uint64 对应长度的无符号整数 float16 1位符号位，5位指数，10位尾数 float32 1位符号位，8位指数，23位尾数 float64 1位符号位，11位指数，52位尾数 complex64 实部虚部都是32位浮点数 complex128 实部虚部都是64位浮点数 ndarray数组的创建方法 从Python的列表，元祖等类型创建 12a = np.array([1, 2, 3])b = np.array((4, 5.2), dtype=np.float32) 使用NumPy的函数创建ndarray数组，如arrange,ones,zeros 函数 说明 np.arrange(n) 类似range函数，返回ndarray类型，从0到n-1 np.ones(shape) 根据shape生成全1的数组，如np.ones((3, 5)) np.zeros(shape) 类似，全0数组 np.full(shape, val) 类似，数据全为val np.eyes(shanpe) 类似，对角线为1，其他为0 np.ones_like(a) 根据数组a生成全1的数组 np.zeros_like(a) 类似，全0 np.full_like(a, val) 类似，全val np.linspace() 根据起止数据等间距地填充数据 np.concatenate() 将两个或多个数组合并 例子 123456In: a = np.linspace(1, 10, 4)Out: array([1., 4., 7., 10.])In: b = np.linspace(1, 10, 4, endpoint=False)Out: array([1., 3.25, 5.5, 7.75])In: c = np.concatenate((a, b))Out: array([1., 4., 7., 10., 1., 3.25, 5.5, 7.75]) ndarray数组的维度变换 方法 说明 reshape(shape) 不改变数组元素，返回一个shape形状的数组，原数组不变 resize(shape) 与reshape一致，但修改原数组 swapaxes(ax1, ax2) 将数组n维度中的2个维度互换 flatten() 对数组进行将为，返回1维数组，原数组不变 ndarray数组的类型变换 1b = a.astype(new_type) astype会创建新数组，原数组不变 ndarray数组向列表转换 1ls = a.tolist() 从字节流（raw bytes）中创建 从文件中读取特定格式 数组的索引和切片一维数组的索引和切片与Python的列表一致 123456In: a = np..array([9, 8, 7, 6, 5])In: a[2]Out: 7In: a[1:4:2]Out: array([8, 6]) 多维数组的索引 1234In: a = np.arange(24).reshape((2, 3, 4))In: a[1, 2, 3] #逗号分隔Out: 23In: a[:, 1:3, :] #每个维度类似1维数组[起:止:间隔] ndarray数组的运算 数组与标量之间的运算作用于每一个元素 NumPy一元函数，元素级的运算 函数 说明 np.abs(x) np.fabs(x) 计算各元素的绝对值 np.sqrt(x) 计算各元素的平方根 np.square(x) 计算各元素的评分 np.log(x) np.log10(x) np.log2(x) 计算各元素的自然对数，10底对数，2底对数 np.ceil(x) np.floor(x) 计算各元素的celling和floor值 np.rint(x) 计算各元素四舍五入值 np.modf(x) 返回小数和整数部分两个数组 np.cos/sin/cosh/sinh/tan/tanh 三角函数值 np.exp(x) 各元素的指数值 np.sign(x) 各元素的符号值 Numpy的二元函数 函数 说明 + - / * 两个数组各元素运算 np.maximum(x, y) np.fmax() 两个数组逐个元素比较，返回较大元素组成的数组 np.minimum(x, y) np.fmin() 两个数组逐个元素比较，返回较小元素组成的数组 np.mod(x, y) 元素级的模运算 np.copysign(x, y) 将y数组各元素的符号值赋值给x &gt; &lt; &gt;= &lt;= == != 算术比较，返回bool型数组 CSV文件读写1,2维数据读写np.savetxt(frame, array, fmt=’%.18e’, delimiter=None) 12a = np.arange(100).reshape(5, 20)np.savetxt('a.csv', a, fmt='%d', delimiter=',') np.loadtxt(frame, dtype=np.float, delimiter=None, unpack=False) 1b = np.loadtxt('a.csv', dtype=np.int, delimiter=',') 多维数据的读写a.tofile(frame, sep=’’, format=’%s’) 123a = np.arange(100).reshape(5, 10, 2)a.tofile('a.bat', sep=',', format='%d')#不指定sep则保存为二进制 a.fromfile(frame, dtype=float, count=-1, sep=’’) 1b = np.fromfile('a.bat', dtype=np.int, sep=',') 便捷文件存取np.save(fname, array) np.savez(fname, array) fname以npy/npz结尾 np.load(fname) 123a = np.arange(100).reshape(5, 10, 2)np.save('a.npy', a)b = np.load('a.npy') Numpy的随机数函数np.random的随机数函数 函数 说明 rand(d0, d1,…dn) 根据d0-dn的shape创建随机数数组，[0, 1)均匀分布 randn(d0, d1,…dn) 根据d0-dn的shape创建随机数数组，标准正态分布 randint(low, high, shape) 根据shape创建随机数组，范围[low, high) seeds(s) 随机数种子 shuffle(a) 根据数组啊的第一轴进行随机排列，改变数组a permutation(a) 同上，但生成新数组，不改变原数组 choice(a[,size,replace,p]) 从一维数组a中以概率p抽取元素，形成size形状新数组；replace表示是否可以重用元素，默认False uniform(loc, scale, size) 产生具有均匀分布的数组 normal(low, high, size) 产生具有正态分布的数组， loc均值，scale标准差 poisson(lam, size) 产生具有泊松分布的数组，lam随机事件发生概率 NumPy的统计函数 函数 说明 sum(a, axis=None) 根据给定轴计算数组啊相关元素和 mean(a, axis=None) 期望 average(a, axis, weights=None) 加权平均值 std(a, axis=None) 标准差 var(a, axis=None) 方差 min(a) max(a) 求最小/大值 argmin(a) argmax(a) 最小/大值降一维后下标 unravel_index(index, shape) 根据shape将一维下标转换成多维下标 ptp(a) 最大值最小值的差 median(a) 中位数 Numpy的梯度函数 函数 说明 gradient(a) 计算数组a中元素的梯度，a为多维时，返回每个维度的梯度 梯度：连续值之间的变化率，即斜率 xy坐标轴连续3个x坐标对应的y值为：a，b，c，其中b的梯度为(c-a)/2 图像的数组表示123456789101112from PIL import Imageimport numpy as np#获得图像数组im = np.array(Image.open('1.jpg'))#运算并修改数组b = [255, 255, 255] -im#获取新图片im = Image.fromarray(b.astype(np.uint8))#保存图片im.save('new.jpg') 数据展示matplotlibmatplotlib库较复杂，类似于matlab。可以使用matplotlib.pyploy 123456import matplotlib.pyplot as pltplt.plot([3, 1, 4, 5, 2])plt.ylabel('grade')#保存图片plt.savefig('test', dpi=600)plt.show() 1234567#同时指定x,y值plt.plot([0, 2, 4, 6, 8],[3, 1, 4, 5, 2])#xmin,xmax,ymin,ymaxplt.axis([-1, 10, 0, 6])plt.ylabel('grade')#plt.savefig('test', dpi=600)plt.show() pyplot的绘图区域plt.subplot(nrows, ncols, plot_num) 123456789a = np.arange(0, 5, 0.02)#两行一列绘图区域的上半部分plt.subplot(2, 1, 1)plt.plot(a, np.exp(-a) * np.cos(2*np.pi*a))#两行一列绘图区域的下半部分plt.subplot(2, 1, 2)plt.plot(a, np.cos(np.pi*a))plt.show() plot函数plt.plot(x, y, format_string, **kwargs) x,y:列表或数组 format_string:控制曲线的格式字符串,由颜色，风格，标记字符组成 颜色字符 说明 ‘b’ 蓝色 ‘g’ 绿色 ‘r’ 红色 ‘c’ 青绿色 ‘#008000’ RGB的某种颜色 ‘m’ 洋红色 ‘y’ 黄色 ‘k’ 黑色 ‘w’ 白色 ‘0.8’ 灰度值 风格字符 说明 ‘-‘ 实线 ‘–’ 破折线 ‘-.’ 点划画线 ‘:’ 虚线 ‘’ ‘ ‘ 无线条 标记字符 说明 ‘.’ 点标记 ‘,’ 像素标记（极小点） ‘o’ 实心圈标记 ‘v’ 倒三角标记 ‘^’ 上三角标记 ‘&gt;’ 右三角标记 ‘&lt;’ 左三角标记 ‘1’ 下花三角标记 ‘2’ 上花三角标记 ‘3’ 左花三角标记 ‘4’ 右花三角标记 ‘s’ 实心方形标记 ‘p’ 实心五角标记 ‘*’ 星形标记 ‘h’ 竖六边形标记 ‘H’ 横六边形标记 ‘+’ 十字标记 ‘x’ x标记 ‘D’ 菱形标记 ‘d’ 瘦菱形标记 ‘ ‘ 垂直线标记 **kwargs:第二组或更多的(x, y, format_string) color:控制颜色，color=’green’ linestyle: 控制颜色，linestyle=’dashed’ marker:标记风格，marker=’o’ markerfacecolor:标记颜色，markerfacecolor=’blue’ markersize:标记尺寸,markersize=20 pyplot的中文显示 方法一：使用rcParams修改默认字体 123import matplotlibmatplotlib/rcParams['font.family'] = 'SimHei'y.tlabel('纵轴') rcParams的属性 属性 说明 ‘font.family’ 字体，’SimHei’黑体，’Kaiti’楷体，’LiSu’隶书，’Fangsong’仿宋，’YouYuan’幼圆，’STSong’华文宋体等 ‘font.style’ 字体风格，如normal,italic ‘font.szie’ 字体大小，数字或large,x-small等 方法二：使用属性fontproperties 1plt.ylabel('横轴', fontproperties='SimHei', fontsize=20) pyplot的文本显示 函数 说明 plt.xlabel() x轴标签 plt.ylabel() y轴标签 plt.title() 图形整体增加标签 plt.text() 任意位置增加文本 plt.annotate() 图形中增加带箭头的注解 详细切分绘图区域 subplot2grid 1plt.subplot2grid((3, 3), (1, 0), colspan=2) gridspec 123from matplotlib import gridspecgs = gridspec.GridSpec(3, 3)ax1 = plt.subplot(gs[0, :]) pyplot基础图表函数 函数 说明 plt.plot(x,y,fmt,…) 坐标图 plt.boxplot(data,notah,position) 箱形图 plt.bar(left,height,width,bottom) 条形图 plt.barh(width, bottom, left,height) 横向条形图 plt.polar(theta,r) 极坐标图 plt.pie(data, explode) 饼图 plt.psd(x,NFFT=256,pad_to,Fs) 功率谱密度图 plt.specgram(x,NFFT=256,pad_to,F) 谱图 plt.cohere(x,y,NFFT=256,Fs) x-y相关性函数 plt.scatter(x,y) 散点图 plt.step(x,y,where) 步阶图 plt.hist(x,bins,normed) 直方图 plt.contour(x,y,z,n) 等值图 plt.vlines() 垂直图 plt.stem(x,y,linefmt,markerfmt) 柴火图 plt.plot_date() 数据日期 饼图1234567891011#饼图labels = ['Frogs', 'Hogs', 'Dogs', 'Logs']sizes = [15, 30, 45, 10]#突出第二块explode = (0, 0.1, 0, 0)plt.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=False, startangle=90)#使得画出正圆形plt.axis('equal')plt.show() 直方图1234567#直方图np.random.seed(0)mu, sigma = 100, 20a = np.random.normal(mu, sigma, size=100)#第二个参数bin代表直方的个数（划分的区间，y为每个区间中元素的个数（normed=1）或概率(normed=1)）plt.hist(a, 40, normed=1, histtype='stepfilled', facecolor='b')plt.show() 极坐标散点图12345#散点图fig, ax = plt.subplots()#scatterax.plot(10*np.random.randn(100), 10*np.random.randn(100), 'o')plt.show() pandas库Series类型由一组数据及与之相关的索引组成 1pd.Series([9, 8, 7, 6], index=['a', 'b', 'c', 'd']) Series创建 从标量创建 1pd.Series(25, index=['a', 'b']) 从字典类型创建 1pd.Series(&#123;'a':8, 'b':7&#125;) 从ndarray创建 1pd.Seriess(np.arange(5)) 从列表创建 1pd.Series([9, 8], index=['a', 'b']) Series的基本操作索引切片等类似numpy Series的name属性对象和索引都有name属性 123b = pd.Series([9, 8], index=['a', 'b'])b.name='Series对象'b.index.name='索引列' DataFrame类型表格型数据类型 创建 二维ndarray对象 1pd.DataFrame(np.arange(10).reshape(2, 5)) 一维ndarray对象字典(或直接字典)创建123d = &#123;'one': pd.Series([1, 3, 5, 7], index=['a', 'b', 'c', 'd']), 'two': pd.Series([2, 4, 6, 8], index=['a', 'b', 'c', 'd'])&#125;p = pd.DataFrame(d) 索引行：d[]，列:d.ix[] 获取0轴索引：d.index 获取1轴索引: d.columns 索引的常用方法 append(idx) 连接另一个index对象，产生新的索引 diff(idx) 差集，并返回 intersection(idx) 交集 union(idx) 并集 delete(loc) 删除loc位置的元素 insert(loc, c) 在loc位置增加索引 数据类型操作 重新索引reindex 12345d = pd.DataFrame(&#123;'c1':[1, 3, 5], 'c2':[2, 4, 6]&#125;, index=['i1', 'i2', 'i3'])#改变行顺序d.reindex(index=['i3', 'i2', 'i1'])#改变列顺序d.reindex(columns=['c2', 'c1']) 参数– index,columns :新的行列自定义索引– fill_value : 填充缺失位置的值– method : 填充方法，ffill向前填充，bfill向后填充– limit: 最大填充量– copy : 默认True，生成新对象，为False时不复制 删除指定索引drop1234#删除0轴d.drop(['i1'])删除1轴d.drop(['c1'], axis=1) Pandas的排序根据索引进行排序sort_index(axix=0, ascending=True) 在指定轴上根据数据进行排序sort_values(by, axix=0, ascending=True) by： axis轴上的某个索引，或索引列表 NaN统一放到排序末尾 Pandas的统计分析 函数 说明 sum 计算数据综合，按0轴，下同 count 非Nan的数量 mean median 算术平均，算术中位数 var std 方差，标准差 min max 最小，最大 argmin argmax Series用，返回最值所在位置的索引（自动索引） idmin idmax 同上，返回自定义索引 describe 对0轴进行统计汇总","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python中使用IRR与XIRR","date":"2017-09-27T12:19:52.000Z","path":"2017/09/27/Python中使用IRR与XIRR/","text":"使用IRR函数可直接调用Numpy中的库函数，直接使用即可 1print(np.irr([30000, -5100, -5100, -5100, -5100, -5100, -5100])) 使用XIRR函数很遗憾，不知道为什么Numpy中没有提供该函数。 参考网上的大神：https://stackoverflow.com/questions/8919718/financial-python-library-that-has-xirr-and-xnpv-function 12345678910111213141516171819202122232425def xirr(transactions): years = [(ta[0] - transactions[0][0]).days / 365.0 for ta in transactions] residual = 1 step = 0.05 guess = 0.05 epsilon = 0.0001 limit = 10000 while abs(residual) &gt; epsilon and limit &gt; 0: limit -= 1 residual = 0.0 for i, ta in enumerate(transactions): residual += ta[1] / pow(guess, years[i]) if abs(residual) &gt; epsilon: if residual &gt; 0: guess += step else: guess -= step step /= 2.0 return guess-1from datetime import datetas = [ (date(2010, 12, 29), -10000), (date(2012, 1, 25), 20), (date(2012, 3, 8), 10100)]print(xirr(tas)) #0.0100612640381","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python常用知识点","date":"2017-09-07T02:03:03.000Z","path":"2017/09/07/Python常用知识点/","text":"删除重复字符1234567891011import re# s:输入字符串# n:重复几个的时候删除， n&gt;=2def removeSameCh(s, n): # (.)表示任意一个字符，并且组成一个分组1 # \\1表示匹配出的分组 # &#123;%d,&#125;表示重复，例如n为3的时候，则重复2次及以上 pat = r'(.)\\1&#123;%d,&#125;' % (int(n)-1) while re.search(pat, s) is not None: s = re.sub(pat, r'\\1', s) return s 读写文件123with open(fName, 'r') as f: for line in f.readlines(): print(line) 如果报错UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x80 in position 84: illegal multibyte sequence 则将open函数修改为： 1open(fName, 'r', encoding='UTF-8') 或者使用二进制读取1open(fName, 'rb')","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"利用Python进行数据分析","date":"2017-08-22T23:32:21.000Z","path":"2017/08/23/利用Python进行数据分析/","text":"","tags":[]},{"title":"MySQL基础知识","date":"2017-08-15T13:17:50.000Z","path":"2017/08/15/深入浅出MySQL/","text":"常用命令可以通过[？CONTENTS]命令查询所有命令 DDL数据定义语言 命令作用 命令格式 创建数据库 CREATE DATABASE newdb; 显示数据库 SHOW DATABASES; 选择数据库 USE newdb; 显示表 SHOW TABLES; 删除数据库 DROP DATABASE newdb; 创建表 CREATE TABLE emp(ename VARCHAR(20), hiredata DATE, deptno INT(2)); 查看表信息 DESC emp; 查看更全面的表定义信息 SHOW CREATE TABLE emp\\G; 删除表 DROP TABLE emp; 修改表字段类型 ALTER TABLE emp MODIFY ename VARCHAR(30); 增加表字段 ALTER TABLE emp ADD age INT(5) [AFTER ename]; 删除表字段 ALTER TABLE emp DROP COLUMN age; 修改字段名字 ALTER TABLE emp CHANGE age newage INT(10); 修改字段排列顺序(ADD/CHANGE/MODIFY ) ALTER TABLE emp MODIFY newage INT(2) AFTER ename; 修改表名 ALTER TABLE emp RENAME emp2; DML数据库操作语言 命令作用 命令格式 插入记录 INSERT INTO emp (ename, hiredate, deptno) VALUES(‘kongdb’, ‘1991-05-16’, 1),(‘sss’, ‘1992-01-01’, 2); 更新记录 UPDATE emp SET ename=’new’ WHERE deptno=2; 更新多表 UPDATE emp a, dept b SET a.sal=a.sal*b.deptno WHERE a.deptno=b.deptno; 删除记录 DELETE FROM emp WHERE ename=’new’; 删除多表 DELETE a, b FROM emp a, dept b WHERE a.deptno=b.deptno AND a.deptno=1; 查询记录 SELECT * FROM emp; 查询不重复的记录 SELECT DISTINCT deptno FROM emp; 条件查询(=,&lt;,&gt;,&lt;=,&gt;=,!=,AND,OR) SELECT * FROM emp WHERE sal&gt;4000 AND deptno=4; 查询排序 SELECT * FROM emp ORDER BY sal [DESC]; 查询限制 SELECT * FROM emp LIMIT 1; 聚合操作(COUNT,SUM,MAX,MIN) SELECT [field1,field2,……fieldn] fun_nameFROM tablename[WHERE where_contition][GROUP BY field1,field2,……fieldn[WITH ROLLUP]][HAVING where_contition] 统计某个值出现次数 SELECT deptno, COUNT(1) FROM emp GROUP BY deptno; 对聚合结果再进行汇总WITH ROLLUP SELECT deptno, COUNT(1) FROM emp GROUP BY deptno WITH ROLLUP; 对统计结果再进行过滤HAVING SELECT deptno, COUNT(1) FROM emp GROUP BY deptno HAVING COUNT(1)&gt;1; 求和、最大值、最小值 SELECT SUM(sal), MAX(sal), MIN(sal) FROM emp; 内连接 SELECT ename, deptname FROM emp, dept WHERE emp.deptno=dept.deptno; 外连接（左连接）包含左边所有记录，即使右边没有 SELECT ename, deptname FROM emp LEFT JOIN dept ON emp.deptno=dept.deptno; 外连接（右连接）包含右边所有记录，即使左边没有 SELECT ename, deptname FROM emp RIGHT JOIN dept ON emp.deptno=dept.deptno; 子查询（查询所用到的条件是另一个select语句的结果）IN,NOT IN,=,!=,EXISTS,NOT EXISTS SELECT * FROM emp WHERE deptno IN (SELECT deptno FROM dept); 记录联合（UNION ALL） SELECT deptno FROM empUNION ALLSELECT deptno FROM dept; 记录联合（UNION）为[UNION ALL]再DISTINCT后的结果 SELECT deptno FROM empUNIONSELECT deptno FROM dept; DCL数据库管理语言 命令作用 命令格式 创建用户 CREATE USER ‘usr1’@’localhost’; 增加权限（GRANT） GRANT SELECT, INSERT ON newdb.* TO ‘usr1’@’localhost’; 解除权限（REVOKE） REVOKE INSERT ON newdb.* FROM ‘usr1’@’localhost’; MySQL支持的数据类型数值类型 整数类型 字节 最小值 最大值 TINYINT 1 有符号-128无符号 0 有符号 127无符号 255 SMALLINT 2 有符号-32768无符号 0 有符号 32767无符号 65535 MEDIUMINT 3 有符号-8388608无符号 0 有符号 8388607无符号 1677215 INT、INTEGER 4 有符号-2147483648无符号 0 有符号 2147483647无符号 4294967295 BIGINT 8 有符号-9223372036854775808无符号 0 有符号 9223372036854775807无符号 18446744073709551615 浮点数类型 字节 最小值 最大值 FLOAT 4 ±1.175494351E-38 ±3.402823466E+38 DOUBLE 8 ±2.2250738585072014E-308 ±1.7976931348623157E+308 定点数类型 字节 描述 DEC(M,D)，DECIMAL(M,D) M+2 最大取值范围与DOUBLE 相同，给定DECIMAL 的有效取值范围由M 和D决定 浮点数类型 字节 最小值 最大值 BIT(M) 1～8 BIT(1) BIT(64) 整数类型指定显示宽度1CREATE TABLE t1(id INT(5)); 则id的宽度指定为5（不指定时默认为INT(11)） 1ALTER TABLE t1 MODIFY id INT(5) ZEROFILL; 设置ZEROFILL则宽度不足时自动补0，指定ZEROFILL时会为该列自动添加UNSIGNED属性 AUTO_INCREMENT属性可利用此属性设置某列为自增 设置方法 123CREATE TABLE t2(id INT AUTO_INCREMENT NOT NULL PRIMARY KEY);CREATE TABLE t2(id INT AUTO_INCREMENT NOT NULL, PRIMARY KEY(id));CREATE TABLE t2(id INT AUTO_INCREMENT NOT NULL, UNIQUE(id)); 定点数（M,D）M表示所有数字位数（整数+小数），D表示小数位数字 DECIMAL不指定精度时，默认为(10,0) BIT(M)类型M为1到64，不写则默认为1 SELECT结果默认看不到BIT类型，可用BIN(二进制格式)，HEX(16进制格式)进行读取 1SELECT BIN(id), HEX(id) FROM t2; 日期时间类型常见类型 日期和时间类型 字节 最小值 最大值 DATE 4 1000-01-01 9999-12-31 DATETIME 8 1000-01-01 00:00:00 9999-12-31 23:59:59 TIMESTAMP 4 19700101080001 2038 年的某个时刻 TIME 3 -838:59:59 838:59:59 YEAR 1 1901 2155 TIME_STAMP 系统默认给该列创建CURRENT_TIMESTAMP默认值 和时区相关，当插入日期时，会先转换为本地时区后存放；而从数据库里面取出时，也同样需要将日期转换为本地时区后显示。 超过取值范围会被置为0000-00-00 00:00:00 YEARMySQL 以YYYY 格式检索和显示YEAR 值，范围是1901～2155。当使用两位字符串表示年份时，其范围为“00”到“99”。 “00”到“69”范围的值被转换为2000～2069 范围的YEAR 值 “70”到“99”范围的值被转换为1970～1999 范围的YEAR 值。 DATETIME合法的格式有 1234INSERT INTO t VALUES('1991-05-16 12:21:10');INSERT INTO t VALUES('91/05/16 12:21:10');INSERT INTO t VALUES('910516122110');INSERT INTO t VALUES(910516122110); 字符串类型 字符串类型 字节 描述及字符串存储需求 CHAR（M） M M 为0～255 之间的整数 VARCHAR（M） M 为0～65535 之间的整数，值的长度+1 个字节 TINYBLOB 允许长度0～255 字节，值的长度+1 个字节 BLOB 允许长度0～65535 字节，值的长度+2 个字节 MEDIUMBLOB 允许长度0～167772150 字节，值的长度+3 个字节 LONGBLOB 允许长度 0～4294967295 字节，值的长度+4 个字节 TINYTEXT 允许长度0～255 字节，值的长度+2 个字节 TEXT 允许长度0～65535 字节，值的长度+2 个字节 MEDIUMTEXT 允许长度0～167772150 字节，值的长度+3 个字节 LONGTEXT 允许长度 0～4294967295 字节，值的长度+4 个字节 VARBINARY（M） 允许长度0～M 个字节的变长字节字符串，值的长度+1 个字节 BINARY（M） M 允许长度0～M 个字节的定长字节字符串 CHAR和VARCHAR用来保存较短的字符串，CHAR的长度为声明的长度，VARCHAR为可变长 BINARY 和VARBINARY保存二进制字符串，对于BINARY定长类型，长度不够时填充’\\0’ ENUM枚举类型，值范围需要在创建表时通过枚举方式显式指定。最多允许有65535 个成员。 示例： 12CREATE TABLE t (e ENUM('M','F'));INSERT INTO t VALUES('M'),('F'),(NULL); 注：在MySQL5.7.19上插入不存在的ENUM中的值时，提示“Data truncated for column” SET可以保护0~64个成员，一次可以选取多个成员 示例 12CREATE TABLE t (s SET('A','B','C','D'));INSERT INTO t VALUES('A,B,A'),('D,A'),('C'); MySQL运算符算术运算符 运算符 作用 + 加法 - 减法 * 乘法 /，DIV 除法，返回商 %，MOD 除法，返回余数 比较运算符 运算符 作用 = 等于 &lt;&gt;或!= 不等于 &lt;=&gt; NULL 安全的等于(NULL-safe) &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 存在与指定范围 IN 存在于指定集合 IS NULL 为NULL IS NOT NULL 不为NULL LIKE 通配符匹配 REGEXP 或RLIKE 正则表达式匹配 &lt;=&gt;运算符[NULL &lt;=&gt; NULL]的结果为1 BETWEEN运算符[10 BETWEEN 10 AND 20]的结果为1，，等价于a&gt;=min and a&lt;=max LIKE和REGEXP[123456 LIKE ‘123%’]的结果为1 格式为[str REGEXP str_pat]，当str 字符串中含有str_pat相匹配的字符串时，则返回值为1 逻辑运算符 运算符 作用 NOT 或！ 逻辑非 AND 或&amp;&amp; 逻辑与 OR 或 \\ \\ 逻辑或 XOR 逻辑异或 位运算符 运算符 作用 &amp; 位与（位AND） \\ 位或 （位OR ） ^ 位异或（位 XOR） ~ 位取反 &gt;&gt; 位右移 &lt;&lt; 位左移 常用函数字符串函数 函数 功能 CANCAT(S1,S2,…Sn) 连接S1,S2,…Sn 为一个字符串 INSERT(str,x,y,instr) 将字符串str 从第x 位置开始，y 个字符长的子串替换为字符串instr LOWER(str) 将字符串str 中所有字符变为小写 UPPER(str) 将字符串str 中所有字符变为大写 LEFT(str ,x) 返回字符串str 最左边的x 个字符 RIGHT(str,x) 返回字符串str 最右边的x 个字符 LPAD(str,n ,pad) 用字符串pad 对str 最左边进行填充，直到长度为n 个字符长度 RPAD(str,n,pad) 用字符串pad 对str 最右边进行填充，直到长度为n 个字符长度 LTRIM(str) 去掉字符串str 左侧的空格 RTRIM(str) 去掉字符串str 行尾的空格 REPEAT(str,x) 返回str 重复x 次的结果 REPLACE(str,a,b) 用字符串b 替换字符串str 中所有出现的字符串a STRCMP(s1,s2) 比较字符串s1 和s2 TRIM(str) 去掉字符串行尾和行头的空格 SUBSTRING(str,x,y) 返回从字符串str x 位置起y 个字符长度的字串 数值函数 函数 功能 ABS(x) 返回x 的绝对值 CEIL(x) 返回大于x 的最大整数值 FLOOR(x) 返回小于x 的最大整数值 MOD(x，y) 返回x/y 的模 RAND() 返回0 到1 内的随机值 ROUND(x,y) 返回参数x 的四舍五入的有y 位小数的值 TRUNCATE(x,y) 返回数字x 截断为y 位小数的结果 日期和时间函数 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前的日期和时间 UNIX_TIMESTAMP(date) 返回日期date 的UNIX 时间戳 FROM_UNIXTIME 返回UNIX 时间戳的日期值 WEEK(date) 返回日期date 为一年中的第几周 YEAR(date) 返回日期date 的年份 HOUR(time) 返回time 的小时值 MINUTE(time) 返回time 的分钟值 MONTHNAME(date) 返回date 的月份名 DATE_FORMAT(date,fmt) 返回按字符串fmt 格式化日期date 值 DATE_ADD(date,INTERVAL expr type) 返回一个日期或时间值加上一个时间间隔的时间值 DATEDIFF(expr,expr2) 返回起始时间expr 和结束时间expr2 之间的天数 DATE_FORMAT(date,fmt)函数按字符串fmt 格式化日期date 值 示例 12SELECT DATE_FORMAT(NOW(), '%M,%D,%Y');-&gt; August,20th,2017 日期的格式 格式符 格式说明 %S,%s 两位数字形式的秒（00,01,…,59） %i 两位数字形式的分（00,01,…,59） %H 两位数字形式的小时，24 小时（00,01,…,23） %h,%I 两位数字形式的小时，12 小时（01,02,…,12） %k 数字形式的小时，24 小时（0,1,…,23） %l 数字形式的小时，12 小时（1,2,…,12） %T 24 小时的时间形式（hh:mm:ss） %r 12 小时的时间形式（hh:mm:ssAM 或hh:mm:ssPM） %p AM 或PM %W 一周中每一天的名称（Sunday,Monday,…,Saturday） %a 一周中每一天名称的缩写（Sun,Mon,…,Sat） %d 两位数字表示月中的天数（00,01,…,31） %e 数字形式表示月中的天数（1,2，…,31） %D 英文后缀表示月中的天数（1st,2nd,3rd,…） %w 以数字形式表示周中的天数（0=Sunday,1=Monday,…,6=Saturday） %j 以3 位数字表示年中的天数（001,002,…,366） %U 周（0,1,52），其中Sunday 为周中的第一天 %u 周（0,1,52），其中Monday 为周中的第一天 %M 月名（January,February,…,December） %b 缩写的月名（January,February,…,December） %m 两位数字表示的月份（01,02,…,12） %c 数字表示的月份（1,2,…,12） %Y 4 位数字表示的年份 %y 两位数字表示的年份 %% 直接值“%” DATE_ADD(date,INTERVAL expr type)函数返回与所给日期date 相差INTERVAL 时间段的日期。 示例 121分1秒后的时间SELECT DATE_ADD(NOW(), INTERVAL '1:1' MINUTE_SECOND); 表达式类型 描述 格式 HOUR 小时 hh MINUTE 分 mm SECOND 秒 ss YEAR 年 YY MONTH 月 MM DAY 日 DD YEAR_MONTH 年和月 YY-MM DAY_HOUR 日和小时 DD hh DAY_MINUTE 日和分钟 DD hh:mm DAY_ SECOND 日和秒 DD hh:mm:ss HOUR_MINUTE 小时和分 hh:mm HOUR_SECOND 小时和秒 hh:ss MINUTE_SECOND 分钟和秒 mm:ss 流程函数 函数 功能 IF(value,t f) 如果value 是真，返回t；否则返回f IFNULL(value1,value2) 如果value1 不为空返回value1，否则返回value2 CASE WHEN [value1]THEN[result1]…ELSE[default]END 如果value1 是真，返回result1，否则返回default CASE [expr] WHEN [value1]THEN[result1]…ELSE[default]END 如果expr 等于value1，返回result1，否则返回default 其他常用函数 函数 功能 DATABASE() 返回当前数据库名 VERSION() 返回当前数据库版本 USER() 返回当前登录用户名 INET_ATON(IP) 返回IP 地址的数字表示 INET_NTOA(num) 返回数字代表的IP 地址 PASSWORD(str) 返回字符串str 的加密版本 MD5() 返回字符串str 的MD5 值 INET_ATON(IP)函数返回IP 地址的网络字节序表示 示例 12SELECT INET_ATON('192.168.0.1');-&gt; 3232235521 INET_NTOA(num)函数返回网络字节序代表的IP 地址 示例 12SELECT INET_NTOA(3232235521);-&gt; 192.168.0.1 MD5(str)函数返回字符串str 的MD5 值，常用来对应用中的数据进行加密。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"IRR与XIRR","date":"2017-08-13T12:43:51.000Z","path":"2017/08/13/IRR与XIRR/","text":"IRR函数说明一系列现金流的内部收益率，现金流数额不必相等，但是必须是定期出现的（如每周或每月） 语法IRR(values, [guess]) 参数说明如下 Values 必需。 数组或单元格的引用，这些单元格包含用来计算内部收益率的数字。 Values 必须包含至少一个正值和一个负值，以计算返回的内部收益率。 IRR 使用值的顺序来说明现金流的顺序。 一定要按您需要的顺序输入支出值和收益值。 如果数组或引用包含文本、逻辑值或空白单元格，这些数值将被忽略。 Guess 可选。 对函数 IRR 计算结果的估计值。 Microsoft Excel 使用迭代法计算函数 IRR。 从 guess 开始，IRR 不断修正计算结果，直至其精度小于 0.00001%。 如果 IRR 运算 20 次，仍未找到结果，则返回 错误值 #NUM!。 多数情况下，不必为 IRR 计算提供 guess 值。 如果省略 guess，则假定它为 0.1 (10%)。 如果 IRR 返回 错误值 #NUM!，或结果不接近您预期的值，可用另一个 guess 值重试。 示例1、一开始投入一笔资金，每年取得一定收入，计算收益率 数据 说明 -70000 成本费用 12000 第一年净收入 15000 第二年净收入 18000 第三年净收入 21000 第四年净收入 26000 第五年净收入 8.66% 五年后的内部收益率( =IRR(A2:A7) ) 2、一开始借了一笔钱，每月还一部分，计算借款实际利率 比如和银行借了30000元，每月还5100，分6个月还 时间 现金流 - 30000 第一个月 -5100 第二个月 -5100 第三个月 -5100 第四个月 -5100 第五个月 -5100 第六个月 -5100 每月利率（=IRR(B2:B8)） 0.57% 年化利率 （=(1+IRR(B2:B8))^12-1） 7.04% 3、每月定投一笔钱，一段时间后计算平均收益 时间 定投资金 第一个月初 -10000 第二个月初 -10000 第三个月初 -10000 第四个月初 -10000 第五个月初 -10000 第六个月初 -10000 第六个月末余额 63000 每月利率（=IRR(B2:B8)） 1.4% 年化利率 （=(1+IRR(B2:B8))^12-1） 18.1% 哇塞，实际年化好吓人 XIRR函数说明用于计算不一定定期发生的现金流的内部收益率 语法XIRR(values, dates, [guess]) 参数说明如下 值 必需。 与 dates 中的支付时间相对应的一系列现金流。 首期支付是可选的，并与投资开始时的成本或支付有关。 如果第一个值是成本或支付，则它必须是负值。 所有后续支付都基于 365 天/年贴现。 值系列中必须至少包含一个正值和一个负值。 日期 必需。 与现金流支付相对应的支付日期表。 日期可按任何顺序排列。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题 。 Guess 可选。 对函数 XIRR 计算结果的估计值。 示例1、一开始投入一笔钱，不定期获得收益 现金流 日期 -10000 2008-1-1 2750 2008-3-1 4250 2008-10-30 3250 2009-2-15 2750 2009-4-1 年化收益率(=XIRR(A2:A6, B2:B6)) 37.34% 2、每月不定期定投 现金流 日期 -3000 2016-1-14 -3000 2016-1-10 -5000 2016-3-6 -10000 2016-8-10 -10000 2016-10-10 32850 2016-10-30 年化收益率(=XIRR(A2:A2, B2:B7)) 17.51% 参考链接微信公众号：越女事务所 IRR 官方说明： https://support.office.com/zh-CN/article/IRR-%E5%87%BD%E6%95%B0-64925EAA-9988-495B-B290-3AD0C163C1BC XIRR官方说明： https://support.office.com/zh-CN/article/XIRR-%E5%87%BD%E6%95%B0-DE1242EC-6477-445B-B11B-A303AD9ADC9D","tags":[{"name":"IRR","slug":"IRR","permalink":"http://yoursite.com/tags/IRR/"}]},{"title":"试题解答","date":"2017-08-09T12:10:02.000Z","path":"2017/08/09/试题解答/","text":"题目11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#-*- coding: utf-8 -*-import pandas as pdimport numpy as npimport os#逐块读取，每块的sizeCHUNK_SIZE = 1000#空年龄的keyNULL_KEY = -1def readDataFromFile(fName): if not os.path.exists(fName): print(\"请确认文件是否存在, 路径：%s\" % fName) return #逐块的迭代器，header=0表示忽略第一行的表头 chunker = pd.read_table(fName, sep='\\s+', header=0, chunksize=CHUNK_SIZE) #结果的列表 result = &#123;&#125; #行号 line = 0 for piece in chunker: #年龄的列表 ages = piece.age.values #年龄是否为空的列表，空则为False isEmptyAge = piece.age.isnull().values for i in range(len(ages)): line = line + 1 if isEmptyAge[i]: result[NULL_KEY] = (result[NULL_KEY] + 1 if NULL_KEY in result else 1) else: try: key = int(ages[i]) result[key] = (result[key] + 1 if key in result else 1) except: print('***错误！数据的第%d行，年龄不是整数数字***' % line) return resultdef saveResultToFile(fName, result): with open(fName, 'w') as f: f.write('年龄 人数\\n') #给年龄排个序 ages = list(result.keys()) ages.sort() for age in ages: if age == NULL_KEY: f.write('未知 %d\\n' % result[age]) else: f.write('%d %d\\n' % (age, result[age]))if __name__ == '__main__': inFile = 'E:/info.txt' outFile = 'E:/result.txt' result = readDataFromFile(inFile) if not result is None: saveResultToFile(outFile, result) 题目212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding: utf-8 -*-import unittestdef checkListFormat(lData): if not isinstance(lData, list) or len(lData) != 2: print('数据格式错误') return False for i in lData: if not isinstance(i, int): print('数据格式错误') return False if not lData[0] &lt; lData[1]: print('数据格式错误') return False return Truedef insertList(before, inData): if not checkListFormat(inData): return if not isinstance(before, list): return for i in before: if not checkListFormat(i): return n = len(before) startIndex = n endIndex = n for i in range(n): if inData[0] &gt; before[i][1]: continue startIndex = i break for i in range(n): if inData[1] &gt; before[i][0]: continue endIndex = i - 1 break #startIndex为n说明待插入值的最小值都比原列表发最后一个值大 newBegin = (inData[0] if startIndex == n else min(inData[0], before[startIndex][0])) newEnd = 0 if endIndex == -1: #待插入值的最大值都比原列表第一个值大 newEnd = inData[1] elif endIndex == n: #需要比较两个列表最后一个值 newEnd = max(inData[1], before[n-1][1]) else: newEnd = max(inData[1], before[endIndex][1]) for i in range(startIndex, min(endIndex+1, n)): before.pop(startIndex) before.insert(startIndex, [newBegin, newEnd]) return beforeclass TestInsert(unittest.TestCase): def test_insertList(self): self.assertEqual(insertList([[1, 3], [6, 9]], [2, 5]), [[1, 5], [6, 9]]) self.assertEqual(insertList([[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], [4, 9]), [[1, 2], [3, 10], [12, 16]]) self.assertEqual(insertList([[6, 9], [10, 11]], [1, 3]), [[1, 3], [6, 9], [10, 11]]) self.assertEqual(insertList([[6, 9], [10, 11]], [19, 32]), [[6, 9], [10, 11], [19, 32]]) self.assertEqual(insertList([[6, 9], [10, 13]], [3, 8]), [[3, 9], [10, 13]]) self.assertEqual(insertList([[6, 9], [10, 13]], [12, 17]), [[6, 9], [10, 17]]) self.assertEqual(insertList([[6, 9], [10, 13]], [11, 12]), [[6, 9], [10, 13]])if __name__ == '__main__': unittest.main()","tags":[]},{"title":"Python金融大数据分析学习笔记","date":"2017-07-26T13:49:28.000Z","path":"2017/07/26/Python金融大数据分析学习笔记/","text":"Python常用工具IPython Notebook说明: 本地Web短编写调试Python代码 安装方法: pip install juputer 运行: jupyter notebook Python quant-platform说明: Web浏览器的金融分析和协作平台，环境已经配置好 地址: http://analytics.quant-platform.com Anaconda说明: 拥有科学计算的Python发行版，提供了包管理和环境管理功能，可以方便地解决多版本Python共存的问题 数据类型和结构基本数据类型浮点数精确地存储12c = 0.5c.as_integer_ratio() decimal 模块1234567import decimalfrom decimal import Decimald = Decimal(1) / Decimal(11) #28位decimal.getcontext().prec = 50d = Decimal(1) / Decimal(11) #50位 函数式编程filter,map,reduce12345def even(x): return x % 2 == 0a = map(even, range(10)) #迭代器[x for x in a] #[True, False, True, False, True, False, True, False, True, False] 使用lamda函数 1map(lamda x: x ** 2, ) filter:筛选匹配函数布尔值的元素 12a = filter(even, range(10))[x for x in a] #[0, 2, 4, 6, 8] reduce:归纳列表 求列表和的例子12from functools import reducereduce(lambda x, y: x+ y, range(15)) Python 字符串逆序12s = \"123你好世界def\"s[::-1] str[begin:end:step] step 默认值为1 深层拷贝deepcopy的运用1234a = [0.5, 1]b = aa[0] = 3b #[3, 1] 12345from copy import deepcopya = [0.5, 1]b = deepcopy(a)a[0] = 3b #[0.5, 1] 参考：https://iaman.actor/blog/2016/04/17/copy-in-python","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python安装MySQL-Python库","date":"2017-07-22T11:48:05.000Z","path":"2017/07/22/Python安装MySQL-Python库/","text":"Python2.7安装MySQL-Python直接执行pip命令1pip2 install MySQL-Python 报错_mysql.c(42) : fatal error C1083: Cannot open include file: ‘config-win.h’: No such file or directory 安装mysql-connector-curl: https://dev.mysql.com/downloads/connector/c/6.0.html 下载相应的版本，比如64位的windows则下载： mysql-connector-c-6.0.2-winx64.msi 默认安装即可 再次执行pip命令还是同样的错误，去mysql-connector-c的安装目录下查找，config-win.h文件确实已经有了。 奇怪，把目录设到环境变量Path中也不行。既然是编译的时候报错了，是不是驾驶INCLUDE目录就行了呢？ 设置编译INCLUDE和LIB目录cmd输入 12SET INCLUDE=C:\\Program Files\\MySQL\\MySQL Connector C 6.0.2\\includeSET LIB=C:\\Program Files\\MySQL\\MySQL Connector C 6.0.2\\lib\\opt 再次执行pip，安装成功 Python3安装MySQL-Python安装上面同样的方法之后，还是报错 mysqlclient.lib中函数undefined，暂时不知道怎么解决。","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Python核心编程学习笔记","date":"2017-07-12T14:08:46.000Z","path":"2017/07/12/Python核心编程学习笔记/","text":"正则表达式常见正则表达式符号和字符 表示法 描述 示例 literal 匹配字符串字面值 re.match(‘foo’, ‘food’) re1 re2 匹配正则表达式re1或者re2 re.match(‘ab\\ cd’, ‘abd’) . 匹配任何字符（除了\\n之外） re.match(‘.e’, ‘de’) ^ 匹配字符串起始部分 re.match(‘^Dear’, ‘Dear my baby’) $ 匹配字符串的终止部分 re.search(‘baby$’, ‘Dear my baby’) * 匹配0次或多次前面出现的正则表达式 re.search(‘ba*b’, ‘Dear my baby’) + 匹配1次或多次前面出现的正则表达式 re.search(‘\\w+.com’, ‘http://ww.baidu.com‘) ? 匹配0次或1次前面出现的正则表达式 re.search(r’b\\w?.com’, ‘http://ww.ba.com‘) {n} 匹配n次前面出现的正则表达式 re.search(r’[0-9]{3}’, ‘87a45b775c’) {m, n} 匹配m到n次前面出现的正则表达式 re.search(r’[0-9]{2,3}’, ‘87a45b775c’) [x-y] 匹配x~y范围内的任意”单一字符” re.search(‘[a-z]’, ‘123ACFdGH’) [^…] 不匹配此字符集中出现的任意字符 re.search(‘[^A-Z]’, ‘ASDG1KL’) (…) 匹配封闭的正则表达式，并另存为子组 re.search(‘([A-Z]{3}).([0-9]{3})’, ‘ASDG123’).group() \\d 匹配任何十进制数，同[0-9]，与\\D相反 re.search(r’\\d’, ‘ASDG123’) \\w 匹配任何字母数字下划线，同[A-Za-z0-9_]，与\\W相反 re.search(r’\\w’, ‘:”@#$a_+’) \\s 匹配任何空格字符，与[\\n\\t\\v\\f]同，与\\S相反 re.search(r’\\s’, ‘:”abc def’) \\b 匹配任何边界字符，与\\B相反 re.search(r’\\bThe\\b’, ‘:”They is not The’) \\N 匹配已保存的子组，其中N为1,2… price:\\16 \\c 匹配特殊字符 .,\\,* 网络编程TCP示例代码tcp服务器 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-from socket import *from time import ctimeHOST = ''PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)tcpSerSock = socket(AF_INET, SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: print(\"waiting for connection...\") tcpCliSock, addr = tcpSerSock.accept() print('...connected from :', addr) while True: data = tcpCliSock.recv(BUFSIZE) if not data: break #tcpCliSock.send(bytes('hello', 'utf-8')) sendData = '[%s] %s' % (ctime(), data.decode('utf-8')) tcpCliSock.send(bytes(sendData, 'utf-8')) tcpCliSock.close()tcpSerSock.close() tcp客户端 12345678910111213141516171819202122# -*- coding: utf-8 -*-from socket import *HOST = '127.0.0.1'PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)tcpClt = socket(AF_INET, SOCK_STREAM)tcpClt.connect(ADDR)while True: data = input('&gt; ') if not data: break tcpClt.send(bytes(data, 'utf-8')) data = tcpClt.recv(BUFSIZE) if not data: break print(data.decode('utf-8'))tcpClt.close() udp服务器 123456789101112131415161718from socket import *from time import ctimeHOST = ''PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)udpSerSock = socket(AF_INET, SOCK_DGRAM)udpSerSock.bind(ADDR)while True: print('waiting for message ...') data, addr = udpSerSock.recvfrom(BUFSIZE) sendData = '[%s] %s' % (ctime(), data.decode('utf-8')) udpSerSock.sendto(bytes(sendData, 'utf-8'), addr) print('...received from and returned to :', addr)udpSerSock.close() udp客户端 123456789101112131415161718from socket import *HOST = '127.0.0.1'PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)udpCltSock = socket(AF_INET, SOCK_DGRAM)while True: data = input('&gt; ') if not data: break udpCltSock.sendto(bytes(data, 'utf-8'), ADDR) data, addr = udpCltSock.recvfrom(BUFSIZE) if not data: break print(data)udpCltSock.close() Web客户端和服务器urlparse模块注：以下皆以Python3为例 urlparse 1234from urllib.parse import urlparseurlparse(\"http://www.baidu.com\")OUT: ParseResult(scheme='http', netloc='www.baidu.com', path='', params='', query='', fragment='') urlunparse 123456from urllib.parse import urlparsefrom urllib.parse import urlunparseo = urlparse(\"http://www.baidu.com\")urlunparse(o)OUT: 'http://www.baidu.com' urljoin 将两个文件结合起来，但是不包括前一个文件的末端文件名 1234from urllib.parse import urljoinurljoin(\"http://www.baidu.com/doc/faq.html\", \"test/a/1.html\")OUT: 'http://www.baidu.com/doc/test/a/1.html'","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"日常记录备忘","date":"2017-07-01T07:38:26.000Z","path":"2017/07/01/日常记录备忘/","text":"系统同时配置了py2和py3环境，运行rf脚本无反应因为ride不支持py3，只能使用py2需要将Python27\\Scripts\\pybot.bat中[python]替换为[python2] 使用uiautomatorviewer.bat时提示unable connect to adb修改前： -Dcom.android.uiautomator.bindir=%prog_dir% 修改后： -Dcom.android.uiautomator.bindir=%ANDROID_HOME%\\tools android相关命令获取已安装的应用的包名adb shell pm list packages 获取包名对应的路径adb shell pm path com.huawei.ca 其中com.huawei.ca为相应的包名 查看已安装应用的Activity先打开应用，再输入以下命令 adb shell dumpsys window w |findstr \\/ | findstr name= 或者： adb shell dumpsys window windows | findstr mFocusedApp","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python爬虫学习笔记","date":"2017-06-28T12:05:49.000Z","path":"2017/06/28/Python爬虫学习笔记/","text":"Requests库的使用安装pip3 install requests 使用获取百度首页的内容1234import requestsr = requests.get(\"http://www.baidu.com\")r.encoding = \"utf-8\"print(r.text) 主要API request “集大成者”，可构造以下的各个请求。 get 获取页面内容的接口，对应于HTTP的GET 函数完整定义如下： 123456789101112def get(url, params=None, **kwargs): r\"\"\"Sends a GET request. :param url: URL for the new :class:`Request` object. :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`. :param \\*\\*kwargs: Optional arguments that ``request`` takes. :return: :class:`Response &lt;Response&gt;` object :rtype: requests.Response \"\"\" kwargs.setdefault('allow_redirects', True) return request('get', url, params=params, **kwargs) 注释部分已将各个参数及返回值含义解释清楚。 get函数返回的Response对象包含了爬虫返回的全部内容。主要包括 属性 说明 status_code 请求的状态码，200表示连接成功，404表示连接失败 text 响应内容的字符串形式 encoding 从header中取得的内容编码方式 apparent_encoding 从内容中分析出的响应内容的编码方式 content 响应内容的二进制形式 爬取网页的一般框架 1234567891011121314import requestsdef getHTMLText(url): try: r = requests.get(url) r.raise_for_status() #非正常状态，如404时，会产生异常 r.encoding = r.apparent_encoding return r.text except: return \"产生异常\"if __name__ == \"__main__\": url = \"http://www.baidu.com\" print(getHTMLText(url)) head 获取页面头信息的接口，对应于HTTP的HEAD 优势：网络流量小 123import requestsr = requests.head(\"http://www.baidu.com\")print(r.headers) post 向网页提交POST请求的接口，对应于HTTP的POST 1234import requestspayload = &#123;\"key1\" : \"value1\", \"key2\" : \"value2\"&#125;r = requests.post(\"http://httpbin.org/post\", data=payload)print(r.text) put 向网页提交PUT请求的接口，对应于HTTP的PUT 与post类似，会将原有的数据覆盖 1234import requestspayload = &#123;\"key1\" : \"value1\", \"key2\" : \"value2\"&#125;r = requests.put(\"http://httpbin.org/put\", data=payload)print(r.text) patch 向网页提交局部修改请求的接口，对应于HTTP的PATCH delete 向网页提交删除请求的接口，对应于HTTP的DELETE","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Win10下py2和py3共存","date":"2017-06-28T11:40:53.000Z","path":"2017/06/28/Win10下py2和py3共存/","text":"安装Python2和Python3从官网分别下载Python2.x和Python3.x版本的程序进行安装。安装方法略。 并将分别将Python加入到环境变量中。安装正确的话，环境变量中应当存在以下值。 path\\to\\Python27 path\\to\\Python27\\Scripts path\\to\\Python36 path\\to\\Python36\\Scripts 将Python27根目录下的python.exe,pythonw.exe分别重命名为python2.exe,python2w.exe 将Python36根目录下的python.exe,pythonw.exe分别重命名为python3.exe,python3w.exe cmd执行命令python2和python3查看是否成功 pip2和pip3设置cmd分别执行以下命令： python3 -m pip install –upgrade pip –force-reinstall python2 -m pip install –upgrade pip –force-reinstall 安装成功之后，可通过[pip2 install xxx]和[pip3 install xxx]来安装各自的包啦！","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"vi常用命令","date":"2017-06-27T13:43:16.000Z","path":"2017/06/27/vi常用命令/","text":"三种模式vi总共有三种模式，命名方法不一，暂且命名为 默认模式 命令模式 编辑模式 三种模式之间的切换及主要功能如下图所示： *使用vi命令时，最初始进入的即为默认模式 常用命令默认模式翻页[Ctrl+u] 向前翻半屏 [Ctrl+d] 向后翻半屏 [Ctrl+f] 向前翻一屏 [Ctrl+b] 向后翻一屏 移动光标[h] 向左移动光标（类似于左键） [j] 向下移动光标（类似于下键） [k] 向上移动光标（类似于上键） [l] 向右移动光标（类似于右键） [0] 移动光标到行首（类似于Home键） [$] 移动光标到行首（类似于End键） [G] 移动光标到末行行首 [nG] 移动光标到第n行行首，n为1,2,3… [gg] 移动光标到首行行首,类似于[1G] [1+Enter] 光标向下移动n行至行首 删除文本[x] 删除光标后的一个字符（X为向前删除一个字符） [dd] 删除光标在的一整行 [ndd] 删除光标所在行在内向后的n行。n为1,2,3… 复制粘贴[yy] 复制光标所在行 [nyy] 复制光标所在行在内向后的n行。n为1,2,3… [p] 粘贴复制的内容到所在行的下一行（P为粘贴到上一行） 撤销重复[u] 撤销上次操作（类似普通编辑器常用的Ctrl+z） [.] 重复上次的操作（不论上一次是什么操作） 命令模式查找[/word] 向下查找字符串 [?word] 向上查找字符串 [n] 查找下一个，若查找命令[/]则为向下查找，若为[?]则为向上查找（N正好相反） 行号[:set number] 左侧显示行号 [:set nonumber] 左侧不显示行号 保存退出[:w] 保存文件 [:w!] 若文件为只读，强制保存文件 [:q] 离开vi，若有修改未保存，会有警告 [:q!] 强制退出vi [:wq] 保存后退出vi [:wq!] 强制保存后退出vi [:w newfilename] 另存为 编辑模式[i] 从当前光标所在处插入[a] 从当前光标的下一个字符处插入[o] 从当前光标的下一行插入","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"vi","slug":"vi","permalink":"http://yoursite.com/tags/vi/"}]},{"title":"Hello World","date":"2017-06-24T13:45:47.239Z","path":"2017/06/24/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]