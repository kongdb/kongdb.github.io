[{"title":"精通正则表达式学习笔记","date":"2019-04-03T06:23:51.000Z","path":"2019/04/03/精通正则表达式学习笔记/","text":"前言正则表达式是一个程序员必备的技能，小到查看日志时的grep/egrep，大到代码里检查字符串的合法性等，都需要依赖于正则表达式。《精通正则表达式》这本书是这方面的杰作，可能如果只是想简单用一用正则表达式，并不需要学的这么深入，但本着查根问底的精神，加上最近的兴趣又上来了，便拿起来啃了起来。 原书作者基本上基于perl来讲解，我还是对Python比较熟悉，下文的所有例子主要都是基于Python3的re库来的，部分使用centos的egrep 第1章：正则表达式入门排除型字符组的注意点， 必须匹配一个未列出的字符 他必须放在字符组首部，否则表示其字符本身的含义 12345678910#可以匹配'qb're.search(r'q[^u]', 'qb')#不可以匹配re.search(r'q[^u]', 'aq')#匹配字符'a're.search(r'[^b]', 'a')#不能匹配re.search(r'[b^]', 'a')#匹配字符'^'re.search(r'[b^]', '^') 字符组的注意点 内部的“元字符”，比如’.?*’等，仅能表示普通字符 ‘-‘只有放在开头，才能表示’-‘本身，否则表示范围 12345678910111213#可以匹配re.match(r'1[.]2', '1.2')#不能匹配re.match(r'1[.]2', '1/2')#可以匹配re.match(r'1.2', '1/2')#可以匹配re.match(r'1[-./]2', '1-2')#不能匹配re.match(r'1[.-/]2', '1-2')#误匹配，此处表示范围。'#'、','、'/'的ascii码分别为35,44,47re.match(r'1[#-/]2', '1,2') 脱字符与多选分支，可以理解成多选分支的”优先级“最低 例如四则运算里’3*4+2’，因为’+’的优先级低，结果为14；而’3*(4+2)’的结果为18 ‘^(From|Subject):’ 表示以’From’开头，然后是’:’，或者以’Subject’开头，然后是’:’ ‘^From|Subject:’ 表示以’From’开头，或者包含’Subject:’ 123456#可以匹配re.search(r'^(From|Subject):', 'Subject: helo')#不能匹配re.search(r'^(From|Subject):', 'abc Subject: helo')#可以匹配'Subject:'re.search(r'^From|Subject:', 'abc Subject: helo') 忽略大小写 egrep中使用’-i’表示 Python中使用’re.I’参数表示 12345#能够匹配'the'开头的行% egrep -i '^THE' ./1.txt#能够匹配re.match(r'cat', 'CAT', re.I) 单词分界符，用来匹配整个单词。比如不希望’cat’和’category’中的’cat’匹配时需要用到 egrep中使用’\\&lt;’和’\\&gt;’来表示 Python中使用’\\b’来表示 12345678910#只能匹配包含单词'cat'的行% egrep '\\&lt;cat\\&gt;' ./1.txt#可以匹配re.search(r'cat', 'this is a category')#不能匹配re.search(r'\\bcat\\b', 'this is a category')#可以匹配re.search(r'\\bcat\\b', 'this is a cat') 书中说”单词的开始和结束”准确说是”字母数字符号的开始和结束“（其实也就是’\\w’，写代码的时候，变量名只能用这几个字符哦），但实际测试过程中，发现Python3对于汉字的支持相当好，把汉字也当做’字母’了 123456#可以匹配re.search('\\w+', '我')#可以匹配re.search(r'\\b我们\\b', 'this is 我们 的家')#不能匹配re.search(r'\\b我们\\b', 'this is我们的家') 匹配HR标签，注意点： SIZE属性可有可无 ‘=’前后可能有任意多个空格 ‘&gt;’前面可能有任意多个空格 标签和属性可能大小写 1re.match(r'&lt;HR(\\s+SIZE\\s*=\\s*\\d+)?\\s*&gt;', '&lt;HR size = 14 &gt;', re.I) 更多的例子 匹配变量名：以字母下划线开头，然后是字母数字或者下划线 1re.search(r'[a-zA-Z_][a-zA-Z_0-9]*', 'obj2') 引号内的字符串 12#最简单的情况，不考虑转义引号，嵌套等，也不考虑匹配优先导致的问题re.search(r'\"[^\"]*\"', '\"abc\"') 美元金额（可能包含小数） 12345678#任意多位的整数，加上可选的\"点号及两位整数\"re.match(r'\\$\\d+(\\.\\d\\d)?', '$36.30')#不能匹配'$1,000','$.36'#尝试把'+'改成'*'会导致误匹配#可以匹配re.match(r'\\$\\d*(\\.\\d\\d)?', '$.30')#误匹配，因为这里的'*'和'?'都是可选的，所以“什么数字都没有”也能匹配re.match(r'\\$\\d*(\\.\\d\\d)?', '$') HTTP/HTML URL 通常是要匹配这样的结构：http://hostname/path.html 当然也可以’.htm’结尾 PS：作者那个年代可能这种静态网页很多吧，现在以这种结尾的网页显得很low啦 匹配hostname ： ‘[-a-z0-9_.]+’ 匹配path：’[-a-z0-9_:@&amp;?=+,.!/~*%$]*‘ 表示时刻的文字 12小时制，后面带am或pm表示上下午，比如’12:30 pm’ 需要注意的是一般午夜12点要用’12:00 am’而不是’00:00’ am，也就是时数不为0 24小时制，比如’13:35’ 123456#12小时制时间re.match(r'(1[012]|0?[1-9]):[0-5][0-9]\\s(am|pm)', '12:00 pm')#24小时制时间-1re.match(r'(2[0-3]|[01]?\\d):[0-5][0-9]', '13:25')#24小时制时间-2re.match(r'([012][0-3]|[01]?[4-9]):[0-5][0-9]', '13:25') 第2章：入门示例拓展匹配温度包括摄氏度和华氏度，比如’-16.0 C’、’+23.7 F’ 12#返回：('+32.23', 'F')re.match(r'^([-+]?\\d+(?:\\.\\d*)?)\\s*([CF])$', '+32.23 F', re.I).groups() 两种表示的区别 1234#匹配任意多个连续的'a'，或者任意多个连续的'b'。此处返回'a're.match(r'a*|b*', 'abab', re.I)#匹配任意多个'a'或者'b'，此处返回'abab're.match(r'(a|b)*', 'abab', re.I) 修整股票价格，参考第4章 为数值添加逗号这个问题的需求很简单，把数字格式化为人类能够看懂的格式，比如：”12345678” =&gt; “12,345,678”，这个很常见了。 想想，如果不用正则表达式，怎么解决呢？ 啊哈，Python里面提供了基本的格式化方法，参考string。 1print('&#123;:,&#125;'.format(12345678)) 如果不能使用这种Python特有 的东西呢？大概是要这样丑陋的逻辑了吧 123456def AddThousandsSeparator(s): chs = list(s) chs_len = len(chs) for i in range(chs_len - 3, 0, -3): chs.insert(i, ',') return chs.join('') 那现在我们有了正则怎么办呢？这就要用到环视啦，其实环视就是用来匹配符合正则表达式的位置。 这个算正则表达式里面比较难的概念啦，掌握了这个，基本上正则就入门了。 类型 正则表达式 匹配成功的条件 大白话 肯定逆序环视 (?&lt;=…) 子表达式能够匹配左侧文本 如果一个位置的左侧文本和正则表达式相匹配，就匹配该位置成功 否定逆序环视 (?&lt;!…) 子表达式不能匹配左侧文本 如果一个位置的左侧文本和正则表达式不相匹配，就匹配该位置成功 肯定顺序环视 (?=…) 子表达式能够匹配右侧文本 如果一个位置的右侧文本和正则表达式相匹配，就匹配该位置成功 否定顺序环视 (?!…) 子表达式不能匹配右侧文本 如果一个位置的右侧文本和正则表达式不相匹配，就匹配该位置成功 12345678#肯定逆序环视，输出'1,+2,+3're.sub(r'(?&lt;=,)', '+', '1,2,3')#否定逆序环视，输出'+1+,2+,3+'re.sub(r'(?&lt;！,)', '+', '1,2,3')#肯定顺序环视，输出'1+,2+,3're.sub(r'(?=,)', '+', '1,2,3')#否定顺序环视，输出'+1,+2,+3+'re.sub(r'(?！,)', '+', '1,2,3') 将”Jeffs”替换成”Jeff’s”的几种方法 123456re.sub(r'\\bJeffs\\b', r\"Jeff's\", 'My name is Jeffs')re.sub(r'\\b(Jeff)(s)\\b', r\"\\1'\\2\", 'My name is Jeffs')re.sub(r'\\bJeff(?=s\\b)', r\"Jeff'\", 'My name is Jeffs')#对于这种多个环视组合的情况，需要匹配的位置重合才算匹配成功re.sub(r'(?&lt;=\\bJeff)(?=s\\b)', \"'\", 'My name is Jeffs')re.sub(r'(?=s\\b)(?&lt;=\\bJeff)', \"'\", 'My name is Jeffs') 回到正题，我们的要给数字插入逗号，其实是找”左边有数字，右边数字的个数正好是3的倍数“的位置 如果没有’(?&lt;=\\d)’，当数字正好3位时，会在首位就插入一个逗号 如果没有’$’，会出现’2,9,8,4,4,4,215’这样的情况 如果数字不是出现字符串末尾，上面的表达式就失效啦，比如”the number is 1024 !“ 可能会想通过”\\b”来代替”$”，但同样不能解决”tone of 1024Hz”这样的问题，因为”\\b”表示的是单词(字母数字下划线)的分界符，他可以用环视表示为两部分 (?&lt;!\\w)(?=\\w) ：左边不是word，右边是word，表示单词起始分界符 (?&lt;=\\w)(?!\\w) ：左边是word，右边不是word，表示单词结束分界符 原问题可以通过’(?!\\d)’来解决，表示右边不是数字的位置 12#输出：tone of 1,024Hzre.sub(r'(?&lt;=\\d)(?=(?:\\d&#123;3&#125;)+(?!\\d))', ',', 'tone of 1024Hz') 不通过逆序环视，这里对于Python的sub替换函数要说明一下，他默认会替换所以匹配的位置。但是每一次匹配都是从上一次匹配结束位置开始的，这句话是我自己的理解，来看几个例子 123456789#这个很好理解，把所有的数字变成'-'，所以结果是'a-b-c-'re.sub(r'\\d', '-', 'a1b2c3')'''1、'\\d+'匹配到'123'之后，替换为'-'2、从'b'开始搜索，'\\d+'匹配到'5'，替换为'-'3、从'c'开始搜索，'\\d+'匹配到'6789'，替换为'-'所以结果为'a-b-c-''''re.sub(r'\\d+', '-', 'a123b5c6789') 环视与普通括号的区别是，它不会占用字符串。 123456789101112'''来看一下不使用逆序环视时的匹配情况1、'(\\d)'匹配到'1'，后面正好6位数字，与环视相匹配，所以'1'被替换为'1,'，原字符串变成'1,234567'2、注意环视不会占用字符串，接下来从'2'开始搜索。'(\\d)'匹配到'2'，后面5位数字，与环视不能匹配3、'(\\d)'匹配到'3'，后面4位数字与环视不能匹配4、'(\\d)'匹配到'4'，后面3位数字与环视匹配，'4'被替换为'4,'，原字符串变成'1,234,567'5、'(\\d)'匹配到'5'，后面2位数字与环视不能匹配6、'(\\d)'匹配到'6'，后面1位数字与环视不能匹配7、'(\\d)'匹配到'7'，后面没有数字与环视不能匹配8、匹配结束'''re.sub(r'(\\d)(?=(?:\\d&#123;3&#125;)+(?!\\d))', r'\\1,', '1234567') 如果连顺序环视也不使用呢 12#下面的结果是'1,234567'，以为第一次匹配时，第二个括号会占尽所有'234567'，并且不会释放，所以替换不会继续re.sub(r'(\\d)((\\d&#123;3&#125;)+(?!\\d))', r'\\1,\\2', '1234567') Text-To-HTML转换 特殊字符的转换 1234#'&amp;','&lt;','&gt;'在HTML中有其自己的编码，这些字符有特殊含义，编码不正确可能导致显示错误re.sub(r'&amp;', '&amp;amp', s) #要先替换'&amp;'re.sub(r'&lt;', '&amp;lt', s)re.sub(r'&gt;', '&amp;gt', s) 匹配空行 可以通过’^\\s$’来匹配空行，注意’\\s’是能够匹配到’\\n’的，所以这个表达式的意义就是：**寻找空行和只包括空白字符的行的结合，直白一点说就是连续空白行* 123456s = 'first line \\n \\t \\nsecond line''''注意Python中sub的原型是：re.sub(pattern, repl, string, count=0, flags=0)count为0表示全部替换，第四个参数才是flags，千万不要写成：re.sub(r'^\\s*$', '&lt;p&gt;', s, re.M)'''re.sub(r'^\\s*$', '&lt;p&gt;', s, 0, re.M) 将E-mail转换为超链接形式 12345678910111213'''需求：将jfriedl@oreilly.com转换为&lt;a href=\"mailto:jfriedl@oreilly.com\"&gt;jfriedl@oreilly.com&lt;/a&gt;'''re.sub(r''' \\b #单词分界 ( #保存到\\1 \\w[-.\\w]* #用户名 @ [-a-z0-9]+(\\.[-a-z0-9]+)*\\.(com|edu|info) #主机名 ) \\b ''', r'&lt;a href=\"mailto:\\1\"&gt;\\1&lt;/a&gt;', s, 0, re.X) 单词重复问题来看一下对这个问题的要求 能查找多个文件，挑出包含重复单词的行，高亮标记每个重复单词，显示这行文字来自哪个文件 能跨行查找，即使两个单词一个在某行末尾另一个在下一行的开头，也算重复单词 能进行不区分大小写的查找，重复单词之间可以出现任意数量的空白字符 能查找用HTML tag分隔的重复单词，如‘…it is \\very\\ very important…’ 12345678910111213141516171819202122232425262728'''python中用'\\033[7mtext\\033[m'标注高亮'''def find_duplicate(directory): for fname in os.listdir(directory): #遍历所有文件 if os.path.isdir(fname): continue with open(directory + '/' + fname, 'r') as f: content = f.read() content = re.sub(r''' \\b #匹配单词起始位置 ([a-z]+) #将单词保存到\\1 ( #空白或者可能出现的标签保存到\\2 (?: #非捕获括号 \\s #空白字符 | #或者是 &lt;[^&gt;]+&gt; #&lt;TAG&gt;形式的tag )+ #至少出现一次 ) (\\1\\b) #再次匹配第一个单词，保证重复 ''', '\\033[7m\\\\1\\033[m\\\\2\\033[7m\\\\3\\033[m', #将\\1和\\3高亮显示 content, 0, re.I | re.M | re.X) content = re.sub('^(?:[^\\033]*\\n)+', '', content, 0, re.M) #删除未匹配的行 content = re.sub(r'^', fname + ': ', content, 0, re.M) #每行开头加上文件名 print(content) 第3章：正则表达式的特性和流派概览处理正则表达式的几种方式 集成式处理：Python中不支持。perl中可以很方便的使用：$line = ~m/^Subject: (.*)/i 程序式处理：直接re.sub这样的方法 面向对象式处理：先编译再使用，r = re.compile(xxx) r.match(yyy) 正则模式与匹配模式 不区分大小写的匹配模式：re.I 或 re.IGNORECASE 或 (?i) 匹配过程中忽略大小写，需要注意的是一些不常见的字符也有大小写 1234567s = 'abc'#不能匹配re.match(r'ABC', s)#匹配：'abc're.match(r'ABC', s, re.I)#匹配re.match(r'ü', 'Ü', re.I) 宽松排列和注释模式：re.X或re.VERBOSE 让正则表达式更优雅，空格通常会被“忽略”，但不是“剔除”，比如”\\1 2”不等于”\\12” 1234a = re.compile(r\"\"\"\\d + # the integral part \\. # the decimal point \\d * # some fractional digits\"\"\", re.X)b = re.compile(r\"\\d+\\.\\d*\") 点号通配模式（单行文本模式）：re.S或re.DOTALL或(?s) 修改点号的匹配规则，从”需要特殊处理“=&gt;”不需要特殊处理“ 点号变为可以匹配换行符 12345s = '123\\n456'#结果为：'123're.match('.*', s)#结果为：'123\\n456're.match('.*', s, re.S) 增强的行锚点模式（多行文本模式）：re.M或re.MULTILINE或(?m) 修改’^’与’$’的匹配规则，从”不需要特殊处理”=&gt;”需要特殊处理“ ‘^’能够匹配内嵌文本行的开头位置 ‘$’能够匹配字符串内部的换行符 12345s = '123\\n456'#结果为空，因为'\\d'与'\\n'不匹配re.findall(r'^\\d*$', s)#结果为：['123, '456']re.findall(r'^\\d*$', s, re.M) #等同于re.MULTILINE 文字文本模式 不使用元字符，等于字符串搜索，Python中不支持\\Q和\\E这样的用法 ASCII模式：re.A或re.ASCII或(?a) Python特有的，使得\\w,\\W,\\b,\\B,\\d,\\D,\\s只匹配ascii字符，而不是unicode字符 12345s = '我爱NJ'#结果为：'我爱NJ're.search(r'\\w+', '我爱NJ')#结果为：'NJ're.search(r'\\w+', '我爱NJ', re.A) #注意这里如果用'\\w*'，结果是空哦，因为'*'可以表示什么都不匹配的 第4章：表达式的匹配原理作者生动的将正则表达式引擎类比为发动机引擎，其中DFA类比为电动机，NFA类比为汽油机；NFA又分为传统型NFA（不符合加州标准的汽油机），POSIX NFA（符合加州标准的汽油机）。目前Python,Perl,PHP,Java,vi等大多数语言使用传统型NFA；MySQL和egrep(大多数版本)使用DFA。 DFA不支持捕获括号，反向引用和忽略量词优先功能（后面会说原因），但是DFA通常匹配速度会比较快。 什么是NFA和DFA呢本来想找一个关于NFA和DFA的视频看看，结果google了一下，youtube上全是三哥的，口音有点醉人。不过转念一想他们在计算机基础理论的研究上还是先人一步呀。 比较权威的资料参考 automata Implementing Regular Expressions 感觉理解的比较模糊，写不出啥来，还是看别人的把。 测试引擎类型 是否支持忽略量词优先12345#Python匹配的是'nfa'字符串，因此Python是传统型NFAre.match(r'nfa|nfa not', 'nfa not')#egrep匹配的是'nfa not'echo 'nfa not' | egrep 'nfa|nfa not' 这个例子我的理解是，如果引擎总是尝试匹配多选结构中的最长分支，那么他是DFA或者POSIX NFA；否则他是传统型NFA 是否导致“无限”回溯12345#Python一直在循环，无法返回结果re.search(r'X(.+)+X', '=XX=======================================')#egrep很快返回无法匹配的结果，因此egrep是DFAecho '=XX=======================================' | egrep 'X(.+)+X' 虽然这是一个很丑陋的正则表达式，但用肉眼一看就知道他是无法匹配的。因为’(.+)+’至少得匹配一个字符，但原字符串中两个‘X’之间不存在字符。为什么Python中执行会“卡住了”呢？第6章的“指数级”匹配会有详细说明。 POSIX NFA使用的程序太少，不找例子了 匹配的基础两条普适的原则 优先选择最左端（最靠开头）的匹配结果 可以这么理解：匹配的过程是从需要查找的字符串起始位置开始遍历，当查找一个符合正则表达式的子串之后便停止了匹配过程，即使后面还有“更加相称”的子串，也不会继续匹配了。 12345678#'cat'只会匹配'indicates'中的'cat'，而不是后面单个的'cat're.search(r'cat', 'The dragging belly indicates that your cat is too fat.')#输出为&lt;_sre.SRE_Match object; span=(23, 26), match='cat'&gt;，其中的23~26为匹配的位置#会匹配'belly're.search(r'fat|cat|belly|your', 'The dragging belly indicates that your cat is too fat.')#尽管正则表达式的第一个分支'fat'在原字符串中也能匹配。但是当匹配的过程进行到索引13，也就是字符'b'时，#后面的'belly'和正则表达式是能够匹配的，所以结果只会是'belly' 标准的匹配量词（*,+,?和{m,n}）是匹配优先的 这就是传说中的贪婪(greddy)模式，感觉说贪婪比较low，以后还是说匹配优先吧。用大白话说就是，匹配优先量词总是尝试匹配多于匹配成功下限的字符，也就是匹配得“越多越好”。 12345678910111213re.match(r'^Subject: (.*)(.*)', 'Subject: Mastering Regular Expressions').groups()#输出为：('Mastering Regular Expressions', '')，因为第一个'.*'会霸占整个标题的文本，而不留任何字符给第二个re.match(r'^.*([0-9][0-9])', 'about 24 characters long')#匹配结果为'about 24'，可能人很容易看出来匹配结果，但是计算机的匹配过程就比较‘累’了，可以理解为如下#1、'.*'占尽整个字符串#2、第一个'[0-9]'需要匹配一个数字，此时无法匹配。'.*'被迫释放最后的字符'g'，但是'[0-9]'仍然无法匹配'g'#3、'.*'被迫继续释放'n'，重复此过程直到释放字符'4'#4、第二个'[0-9]'仍然需要匹配一个数字，'.*'继续释放字符'2'，此时匹配完成re.match(r'^(.*)([0-9]+)', 'Copyright 2003.').groups()#输出为：('Copyright 200', '3')#这条规则书上用先来先服务来说明，比较形象。可以这么理解，'.*'占尽所有字符之后，无法完成匹配，但此时只需要释放一个字符'3'即可以完成匹配过程了。 表达式主导与文本主导 NFA引擎：表达式主导（Regex-Directed） 表达式中的控制权在不同的元素之间转换。怎么理解呢，看书上的例子字符串’tonight’和正则’to(nite|knight|night)’匹配的过程。 表达式中的第一个字符’t’和字符串中的第一个字符’t’匹配，接下来表达式的第二个字符’o’也匹配 正则控制权转移到多选分支，首先选定第一个分支’nite’。第一个分支的’n’和原字符串能够匹配，’i’也能匹配，但是’t’不能匹配了。放弃第一个分支。 依次类推，选定第二、三个分支。最终和第三个分支能够匹配，匹配过程结束。 DFA引擎：文本主导（Text-Directed） 匹配过程中，扫描的字符串中的每个字符都对引擎进行了控制（标记可能匹配的位置）。还是看上面的例子 引擎移动到字符‘t’时，表达式中有一个可能匹配的位置 引擎移动到字符’n’时，表达式中有两个可能匹配的位置，分别在多选分支的第一和第三个分支上 引擎移动到字符’g’时，表达式中只剩下一个可能匹配的位置，在第三个多选分支上。 比较NFA与DFADFA一般情况下比NFA快，这个容易理解，看上面的匹配过程容易看出来。 为什么DFA不支持捕获呢，这个还是没有想明白。 回溯（Backtracking）回溯也是一种标准算法了，想像在走迷宫，前面有个岔路口A,B,C。我们可以选择A，然后记住B和C。如果A没走通，那么回来继续走B，等等 一般情况下，回溯可以用递归实现。最经典的要数8皇后算法了哈。 两个要点 对于匹配优先量词，引擎优先选择进行尝试；对于忽略优先量词，引擎会选择跳过尝试 引擎选择依据LIFO后进先出原则（可以理解为后存储的选择，先进行尝试） 再看匹配优先以”[0-9]+”来匹配”a 1234 num”为例，引擎会在能够回溯的位置保存4个状态，分别在’1’,’2’,’3’,’4’字符的后面（+号限制必须有一个数字）。 接下来引擎匹配到空格失败，需要回溯到最近保存的状态，也就是’4’后面的位置，匹配”1234”字符串成功。 所以，从根本上看，所谓的“贪婪模式”，其实就是回溯的后进先出原则。 那么非贪婪模式呢，其实就是上面的第一个原则，忽略优先量词会优先跳过尝试。 导致的问题 1234567891011121314151617181920#结果为：\"McDonald\\'s\" is said \"makudonarudo\"re.search(r'\".*\"', 'The name \"McDonald\\'s\" is said \"makudonarudo\" in Japanese.')#'[^\"]*'替换'.*'之后，结果为：\"McDonald\\'s\"re.search(r'\"[^\"]*\"', 'The name \"McDonald\\'s\" is said \"makudonarudo\" in Japanese.')#多字符引文，需要匹配&lt;B&gt;&lt;/B&gt;之间的内容#用'.*'不能达到要求。以下结果为：&lt;B&gt;Billions&lt;/B&gt; and &lt;B&gt;Zillions&lt;/B&gt;re.match(r'&lt;B&gt;.*&lt;/B&gt;', '&lt;B&gt;Billions&lt;/B&gt; and &lt;B&gt;Zillions&lt;/B&gt; of suns')#由于tag是多字符了，不能使用排除型字符组了#使用忽略优先量词#以下结果为：B&gt;Billions&lt;/B&gt;re.match(r'&lt;B&gt;.*?&lt;/B&gt;', '&lt;B&gt;Billions&lt;/B&gt; and &lt;B&gt;Zillions&lt;/B&gt; of suns')#可能导致问题，以下结果为：&lt;B&gt;Billions and &lt;B&gt;Zillions&lt;/B&gt;re.match(r'&lt;B&gt;.*?&lt;/B&gt;', '&lt;B&gt;Billions and &lt;B&gt;Zillions&lt;/B&gt; &lt;/B&gt; of suns')#使用排除环视，以下结果为：&lt;B&gt;Zillions&lt;/B&gt;re.search(r'&lt;B&gt;((?!&lt;/?B&gt;).)*&lt;/B&gt;', '&lt;B&gt;Billions and &lt;B&gt;Zillions&lt;/B&gt; &lt;/B&gt; of suns') 浮点数规范化问题规则 保留两位小数，比如3.010000000056规范化为3.01 如果小数点后第三位不为零，则保留三位小数。比如1.625789000000000规范化为1.625 最简单的想法 1234#输出为1.625re.sub(r'(\\.\\d\\d[1-9]?)\\d*', r'\\1', '1.6250001')#输出为1.62re.sub(r'(\\.\\d\\d[1-9]?)\\d*', r'\\1', '1.62000001') 这个表达式有一点问题，当原字符串就是符合规范的时候，它会把自己替换为自己，因为后面的’\\d*’什么也匹配不到，这样有一点浪费。 如果把’\\d*’替换为’\\d+’呢 12345678910#OK，输出为1.625re.sub(r'(\\.\\d\\d[1-9]?)\\d+', r'\\1', '1.6250001')#OK，无法匹配，不会替换，输出为1.62re.sub(r'(\\.\\d\\d[1-9]?)\\d+', r'\\1', '1.62')#NG，字符串被切割。输出1.62。过程有点微妙#1、'[1-9]?'匹配字符'5'，并留下一个不去匹配的备用状态#2、'\\d+'无法匹配了，需要回溯。'[1-9]?'交出字符'5'#3、这样'(\\.\\d\\d[1-9]?)'匹配的是'.62'，'\\d+'匹配的是'5're.sub(r'(\\.\\d\\d[1-9]?)\\d+', r'\\1', '1.625') 占有优先量词和固化分组导致这个问题的根本原因就是，如果’[1-9]?’匹配到了非0数字，我们就不希望再回溯了，也就是不需要保存状态了。 很遗憾Python中这两中特性都不支持，但是可以通过环视来模拟 固化分组 语法：(?&gt;…) 意义：匹配进行到括号之后，此结构内的所有备用状态都会被放弃 占用优先量词 语法：?+、*+、++、{m,n}+ 意义：不创建备用状态，不用交还已经匹配的字符 环视中的回溯环视结构（括号）内会保存一些状态，但是环视匹配结束之后，这些状态便不会保留了。这一点和固化分组及占用优先量词很像。 用肯定环视模拟固化分组：’(?&gt;regex)’用’(?=(regex))\\1’来模拟，注意这里的’\\1’要根据实际情况来 12#使用环视，结果为1.625。并且因为没有匹配成功，所以不会发生替换re.sub(r'(\\.\\d\\d(?=([1-9]?))\\2)\\d+', r'\\1', '1.625') 多选结果的匹配原则 对于传统型NFA引擎，他是按顺序排列的 对于DFA和POSIX NFA引擎，他是匹配优先的 12345#输出为tour，因为他在多选分支排第一个re.search(r'tour|to|tournament', 'three tournaments')#egrep高亮的部分为'tournament'echo 'three tournaments' | egrep 'tour|to|tournament' 匹配日期的几种办法（日期为1-31，并且要支持01这种写法） 直接想可能比较麻烦，书上用画图表的方式表现出来，比较直观 这里需要注意的是，多选分支的顺序也是有讲究的，需要把匹配的数字最短的放到最后，为什么这么说呢？ 12345#结果为'Jan 3'，因为和分支'0?[1-9]'匹配，并且他在最前面re.match(r'Jan (0?[1-9]|[12]\\d|3[01])', \"Jan 31 is Dad's birthday\")#调整顺序可以使得结果OK，匹配到'Jan 31're.match(r'Jan ([12]\\d|3[01]|0?[1-9])', \"Jan 31 is Dad's birthday\") 最左最长规则POSIX规定，如果在字符串的某个位置存在多个可能的匹配，应当返回的是最长的匹配 1234#匹配'oneself're.match(r'one(self)?(selfsufficient)?', \"oneselfsufficient\")#egrep总是返回最长匹配，返回高亮'oneselfsufficient'echo \"oneselfsufficient\" | egrep 'one(self)?(selfsufficient)?' 第5章：正则表达式实用技巧正则表达式的平衡法则 只匹配期望的文本，排除不期望的文本 必须易于控制和理解 必须保证效率 若干例子匹配连续行需要匹配类似于下面这样的文本： 12SRC=array.c builtin.c eval.c field.c gawkmisc.c io.c main.c\\ missing.c msg.c node.c re.c version.c 12345678910111213141516171819202122232425262728293031323334#字符串简化一下s = 'SRC=array.c builtin.c main.c \\\\\\nre.c'#错误示例，只能匹配到：'SRC=array.c builtin.c main.c \\\\'，原因很简单，因为第一个'.*'会一直匹配到'\\\\'之后re.match(r'^\\w+=.*(\\\\\\n.*)*', s)#排除'\\\\'字符，即使用'[^\\\\]*'代替'.*'，对本例子是OK的，能够匹配到：SRC=array.c builtin.c main.c \\\\\\nre.cre.match(r'^\\w+=[^\\\\]*(\\\\\\n[^\\\\]*)*', s)'''但是当s为类似于下面这样的字符串SRC=array.c builtin.c main.c \\ re.cHEADER=array.h node.h \\ io.hs会将整个字符串都匹配，因为'[^\\\\]'能够匹配'\\n'字符，这不是我们期望的结果'''s = 'SRC=array.c builtin.c main.c \\\\\\nre.c\\nHEADER=array.h node.h \\\\\\nio.h'#匹配结果为整个s字符串，但是我们只希望匹配SRC部分re.match(r'^\\w+=[^\\\\]*(\\\\\\n[^\\\\]*)*', s)#将'\\n'也排除，即使用'[^\\n\\\\]*'代替'.*'，可以只匹配SRC了，结果为：SRC=array.c builtin.c main.c \\\\\\nre.cre.match(r'^\\w+=[^\\n\\\\]*(\\\\\\n[^\\n\\\\]*)*', s)#上面这种方法限制了'\\\\'必须出现在一行的结尾位置，如果不是会有问题#只能匹配到：SRC=array.c builtin.cre.match(r'^\\w+=[^\\n\\\\]*(\\\\\\n[^\\n\\\\]*)*', 'SRC=array.c builtin.c\\\\ main.c \\\\\\nre.c')'''换个思路，目前的需求其实两个：1、匹配普通（除反斜线和换行符之外）的字符2、匹配反斜线与其他任何字符的结合体，包括反斜线与换行符的结合体，这就要用到点号通配模式了'''s = 'SRC=array.c builtin.c\\\\ main.c \\\\\\nre.c\\nHEADER=array.h node.h \\\\\\nio.h'#通过re.DOTALL来使用点号通配模式，匹配结果为：SRC=array.c builtin.c\\\\ main.c \\\\\\nre.cre.match(r'^\\w+=([^\\n\\\\]|\\\\.)*', s, re.DOTALL) 匹配IP地址ip地址的格式 点号分开的四个数 每个数字最多3位，最大255 1234567891011121314#简单有效的表示法re.match(r'^\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;$', '192.168.1.137')#精确表示法'''1、1位数字：\\d，如0,9等2、2位数字：\\d\\d，如00,91等3、0或者1开头的三位数字：[01]\\d\\d，如001,199等4、2开头，第二位小于5：2[0-4]\\d，如209,240等5、25开头：25[0-5]，如250,255等因此整个表达式可以表示为：\\d|\\d\\d|[01]\\d\\d|2[0-4]\\d|25[0-5]我们可以将前三个分支合并，化简为：[01]?\\d\\d?|2[0-4]\\d|25[0-5]'''re.match(r'^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])$', '192.168.1.137') 处理文件名linux（比如/usr/local/bin/cmake）和windows（比如C:\\Program Files\\Windows Mail\\wab.exe）下的文件名各有特点，处理起来的方法也不相同 去掉文件名开始的路径1234#linux下的文件名格式，结果为：'python're.sub(r'^.*/', '', '/usr/local/bin/python')#windows下的文件名格式，结果为：'wab.exe're.sub(r'^.*\\\\', '', 'C:\\Program Files\\Windows Mail\\wab.exe') 从路径中获取文件名12345678910'''以下的方法含义比较简单：一段不是'/'的字符串，并且要在结尾但是这样会导致比较多的回溯，因为匹配总是从开头开始，表达式最后的'$'只有在匹配“快结束”的时候才会导致失败。不过对于很短的文件名，这点回溯不是很重要'''#结果为：'python're.search(r'[^/]*$', '/usr/local/bin/python')#结果为：'wab.exe're.search(r'[^\\\\]*$', 'C:\\Program Files\\Windows Mail\\wab.exe') 所在的路径和文件名123456789101112'''下面的方法也很直观，第一个'.*'先会占尽所有字符，然后被迫释放直到一个'/'字符，所以第二个'.*'不会包含任何'/''''#结果为：('/usr/local/bin', 'python')re.match(r'^(.*)/(.*)$', '/usr/local/bin/python').groups()#结果为：('C:\\\\Program Files\\\\Windows Mail', 'wab.exe')re.match(r'^(.*)\\\\(.*)$', 'C:\\Program Files\\Windows Mail\\wab.exe').groups()#为了把“第二个'.*'不包含任何'/'”的意思更加突出，也可以这么写。结果是一样的re.match(r'^(.*)/([^/]*)$', '/usr/local/bin/python').groups()#以上的方法不能处理'file.txt'这样不包含路径的字符串，可以在代码中加上相应处理逻辑 匹配对称的括号对称的括号就是指的’()’，’[]’，’{}’，’&lt;&gt;’等，他们单独出现的时候处理很简单，嵌套的时候会变的很复杂 12345678910'''原始字符串为：val = foo(bar(this), 3.7) + 2 * (that - 1);期待匹配：(bar(this), 3.7)'''#括号及括号内部的全部字符，匹配结果为：'(bar(this), 3.7) + 2 * (that - 1)'re.search(r'(?&lt;=foo)\\(.*\\)', 'val = foo(bar(this), 3.7) + 2 * (that - 1);')#从一个开括号到最近的闭括号，匹配结果为：'(bar(this)'re.search(r'(?&lt;=foo)\\([^)]*\\)', 'val = foo(bar(this), 3.7) + 2 * (that - 1);')#从一个开括号到最近的闭括号，并且不允许包含其他开括号。无法匹配，如果把'(?&lt;=foo)'去掉是可以匹配的re.search(r'(?&lt;=foo)\\([^()]*\\)', 'val = foo(bar(this), 3.7) + 2 * (that - 1);') 正则表达式无法匹配任意深度的嵌套结构，比如上面的一层嵌套，可构造如下表达式： 1234#匹配结果为：'(bar(this), 3.7)'re.search(r'(?&lt;=foo)\\([^()]*(\\([^()]*\\)[^()]*)*\\)', 'val = foo(bar(this), 3.7) + 2 * (that - 1);')#它也可以匹配单层嵌套的多个括号，匹配结果为：'(bar(this),bar2(), 3.7)'re.search(r'(?&lt;=foo)\\([^()]*(\\([^()]*\\)[^()]*)*\\)', 'val = foo(bar(this),bar2(), 3.7) + 2 * (that - 1);') 可以利用“string x count”（Python中是”string * count”）来构造任意深度嵌套的表达式，参考下面的公式 1regex_str = '\\(' + '(?:[^()]|\\(' * 2 + '[^()]*' + r'\\))*' * 2 + '\\)' 这个公式有点难理解呀，来分析一下两层嵌套的情况 已经有点变态了，理解就好，强记也没有意义 123regex_str = '\\(' + '(?:[^()]|\\(' * 2 + '[^()]*' + r'\\))*' * 2 + '\\)'#结果为：'(bar(this, bar3(12)), 3.7)'re.search(r'(?&lt;=foo)' + regex_str, 'val = foo(bar(this, bar3(12)), 3.7) + 2 * (that - 1);') 匹配数字包括负数，小数等 12#可以匹配'365','-3.6','.3'这样的数字re.search(r'-?\\d+(\\.\\d*)?|-?\\.\\d+', '-0.23') 匹配分隔符之内的文本一般步骤： 匹配起始分隔符 匹配正文 匹配结束分隔符 当结束分隔符不止一个字符，或者正文中允许出现结束分隔符，难度就来了 容许引文字符串中出现转义引号123456789101112131415161718192021222324252627282930313233343536373839'''待匹配字符串：\"2\\\"x3\\\"abc\"理清思路，正文部分包括两个部分：1、非'\"'字符；2、'\\\"'字符这个问题用Python表达出来还有点麻烦，因为Python会对转义引文做一些特殊处理\"2\\\"x3\\\"abc\" =&gt; '2\"x3\"abc''2\\'x3\\'abc' =&gt; \"2'x3'abc\"'2\\\"x3\\\"abc' =&gt; '2\"x3\"abc'\"2\\'x3\\'abc\" =&gt; \"2'x3'abc\"为了测试，原字符串也要使用raw字符串r'\"2\\\"x3\\\"abc\"' =&gt; '\"2\\\\\"x3\\\\\"abc\"''''#直接使用排除型字符组肯定不行，会匹配到：'2\\\\'re.match(r'\"([^\"]*)\"', r'\"2\\\"x3\\\"abc\"').groups()#结果为：'2\\\\\"x3\\\\\"abc're.match(r'\"((?:[^\"]|(?&lt;=\\\\)\")*)\"', r'\"2\\\"x3\\\"abc\"').groups()'''这里有一点Python中微妙的东西，必须说明一下正则r'\\\\.'想匹配的结果是“反斜杠以及它后面的一个字符”，而'\\\\\"'代表的字符串实际是“一个反斜杠加一个双引号”所以re.match(r'\\\\.', '\\\\\"')的匹配结果是'\\\\\"'，而不是想象中的'\\\\'（这其实不是两个反斜杠，而是一个）所以为了表达书中的意思，字符串本身也要使用raw字符串。r'\\\\' =&gt; '\\\\\\\\' =&gt; 表示真正意义上的两个反斜杠'''#意外的匹配，下面的匹配结果：r'\"/-|-\\\\\" or \"'，但期待的匹配结果是：r'\"/-|-\\\\\"'。#因为原字符串中的'\\\\'是用来转义'\\'的，不是用来转义'\"'的re.match(r'\"((?:[^\"]|(?&lt;=\\\\)\")*)\"', r'\"/-|-\\\\\" or \"[^-^]\"')'''再理一下思路，这里的正文部分其实包括两个：1、非结束分隔符'[^\"]'；2、转义字符'\\\\.'。'''#能够匹配到：r'\"/-|-\\\\\"'。re.match(r'\"((\\\\.|[^\"])*)\"', r'\"/-|-\\\\\" or \"[^-^]\"')#依然会有不期待的匹配，下面会匹配到：'\"You need a 2\\\\\"x3\\\\\"'，期待是不能匹配#原因是回溯的过程中r'x3\\\"'中的反斜杠会被认为是'[^\"]'，而'\"'被认为是结束分隔符re.match(r'\"((\\\\.|[^\"])*)\"', r'\"You need a 2\\\"x3\\\" Photo')#产生根本原因是多个多选分支能够匹配的内容发生了重叠，可以将'[^\"]'修改为'[^\\\\\"]'re.match(r'\"((\\\\.|[^\\\\\"])*)\"', r'\"You need a 2\\\"x3\\\" photo') 去除文本首尾的空白字符最好的办法，使用下面两个正则 12345s0 = ' abcddsss dfff '#去除开头的空白字符s1 = re.sub(r'^\\s+', '', s0)#去除末尾的空白字符re.sub(r'\\s+$', '', s1) HTML相关范例匹配HTML Tag一般情况下，下面的表达式就够了 1re.match(r'&lt;[^&gt;]+&gt;', '&lt;input value=\"1234\"&gt;&lt;/input&gt;') 但是如果引号字符串里出现了’&gt;’字符就有问题了，会匹配’&lt;input value=”&gt;’ 1re.match(r'&lt;[^&gt;]+&gt;', '&lt;input value=\"&gt;\"&gt;&lt;/input&gt;') tag中主要包括三类字符： 双引号包含的字符串：”[^”]*” 单引号包含的字符串：’[^’]*’ 非单引号，非双引号，非’&gt;’字符 1234567891011re.match(r''' &lt; #开始尖括号\"&lt;\" ( # 任意数量的... \"[^\"]*\" # 双引号字符串 | # 或者是... '[^']*' # 单引号字符串 | # 或者是... [^'\"&gt;] # 其他文本 )* &gt; #结束尖括号\"&gt;\" ''', r'&lt;input value=\"&gt;\"&gt;&lt;/input&gt;', re.X) 匹配HTML Link123456789101112131415161718192021222324252627282930#匹配第一种情况，href属性为双引号内容#s = '&lt;a href=\"http://www.oreilly.com\"&gt;O\\'Reilly Media&lt;/a&gt;'#匹配第二种情况，href属性为单引号内容#s = \"&lt;a href='http://www.oreilly.com'&gt;O'Reilly Media&lt;/a&gt;\"#匹配第三种情况，href属性为无引号内容s = \"&lt;a href=http://www.oreilly.com&gt;O'Reilly Media&lt;/a&gt;\"guts, link = re.match(r'&lt;a\\b([^&gt;]+)&gt;(.*?)&lt;/a&gt;', s).groups()urls = re.search(r''' \\b href # \"href\"属性 \\s*=\\s* # \"=\"两端可能会出现空白字符 (?: # 其值为... \"([^\"]*)\" # 双引号字符串 | # 或者是... '([^']*)' # 单引号字符串 | # 或者是... ([^\"'\\s&gt;]+) # “其他文本” ) ''', guts, re.X # 多行可添加注释并，忽略大小写).groups()'''由于不同多选分支的匹配，造成返回元祖的内容格式不固定，比如第一个匹配：('http://www.oreilly.com', None, None)第三个匹配：(None, None, 'http://www.oreilly.com')因此这里需要选择出实际匹配的内容，而Python中文没有Perl里'$+'这种操作，所以需要自己处理。参考https://stackoverflow.com/questions/2498935/how-to-extract-the-first-non-null-match-from-a-group-of-regexp-matches-in-python'''url = next((x for x in urls if x is not None), None)print(url, ',', link)#或者，也可以使用命名捕获 校验HTTP URL考虑主机、端口、路径的情况 12#输出为：('www.baidu.com', '8888', '/path')re.match(r'^http://([^/:]+)(?::(\\d+))?(/.*)?$', 'http://www.baidu.com/path').groups() 扩展的例子保持数据的协调性查找一系列5位数的美国邮政编码中，以44开头的那些，比如： “03824531449411615213441829505344272742010217443235”中的’’44182”和”44272”。 注意”44941”不是，因为这里的”44”只是”53144”后面的两位，与要求不符。 典型的错误 1234s = '03824531449411615213441829505344272742010217443235'#匹配所有44开头的5位数字，会包括'44941'等re.findall(r'44\\d\\d\\d', s) 关键的问题是要跳过完整的邮政编码，而不是进行单个字符的移动，书中给出几种方法 123456#因为已经限定是数字，所以可以用[^4]表示非4的数字，注意不能使用'[^4][^4]\\d\\d\\d'，这样无法跳过'43210're.findall(r'(?:[^4]\\d&#123;4&#125;|\\d[^4]\\d&#123;3&#125;)*(44\\d&#123;3&#125;)', s)#使用否定顺序环视re.findall(r'(?:(?!44)\\d&#123;5&#125;)*(44\\d&#123;3&#125;)', s)#使用忽略优先量词re.findall(r'(?:\\d&#123;5&#125;)*?(44\\d&#123;3&#125;)', s) 上面的方法都会错误的匹配”44323”，原因： 可以使用’\\G’来避免，实测re库不支持’\\G’，高级一些的regex库支持’\\G’ 12import regexregex.findall(r'\\G(?:(?!44)\\d&#123;5&#125;)*(44\\d&#123;3&#125;)', s) 待续~","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"动态规划算法","date":"2018-06-30T00:23:51.000Z","path":"2018/06/30/动态规划算法/","text":"动态规划动态规划（dynamic programming）,通过组合子问题的解来求解原问题，这里的programming指的是表格法。通常用来求解最优化问题（optimization problem） 按如下4个步骤来设计动态规划算法 刻画一个最优解的结构特征 递归地定义最优解 计算最优解的值，通常采用自底向上的方法 利用计算的信息构造一个最优解 钢条切割Serling公司购买长钢条，将其切割为短钢条出售。假定长度为i的钢条价格为pi 长度i 价格pi 1 1 2 5 3 8 4 9 5 10 6 17 7 17 8 20 9 24 10 30 问题定义：给定一段长度为n英寸的钢条和价格表pi，求切割方案，使得销售收益rn最大 最朴素但暴力的想法：因为长度为n的钢条有n-1个位置可以选择切割或者不切割，比如长度为4的钢条可以在位置为1,2,3的地方分别选择切割或者不切割，所以整体的切割方案会有2n-1种，分别求出这些方案的收益，取最大值即可。 来看示例(以长度为4的钢条为例)12345678(a) ---- 不切割，收益9(b) - --- 位置1处切割，这里有长度为1和3的钢条，收益9(c) -- -- 位置2处切割，这里有长度为2的钢条2条，收益10(d) --- - 位置3处切割，收益和(b)一致为9(e) - - -- 位置1和2处切割，有两条长度1和1条长度2的，收益7(f) - -- - 位置1和3处切割，收益和(e)一致为7(g) -- - - 位置2和3处切割，收益和(e)一致为7(h) - - - - 位置1,2,3处切割，有4条长度1的，收益为4 可以看出这里有很多看似不同，实则一致的方案，比如(b)(d), (e)(f)(g)也就是说，上面的方案做了很多无用的操作，产生浪费 考虑下面的思路: r1=1, 切割方案1=1（无切割）r2=5, 切割方案2=2（无切割）r3=8, 切割方案3=3（无切割）r4=10, 切割方案4=2+2r5=13, 切割方案5=2+3 我的理解，考虑r5的情况。 如果不切割，收益为10 如果在位置1处切割了，则剩下长度为1和4的钢条。还需要考虑长度为4的钢条的切割方案吗？显然不需要了，因为已知r4=10(即长度为4 的钢条最大收益为10)。此时总收益为1+10=11 如果在位置2处切割了，同理，收益为5+8=13 如果在位置3处切割了，收益为5+8=13 如果在位置4处切割了，收益为11所以最大收益即为13 一般的: rn = max(pn, r1+rn-1,r2+rn-2, rn-1+r1)困惑：感觉求1..n有点浪费，应该1..n/2就行了，毕竟是对称的么。 此外，钢条切割问题还存在相似但更简单的递归求解方法： 将钢条从左边切割下长度为i的一段 左半部分为已知pi 对右边剩下的长度为n-i的一段继续进行切割（递归求解） 公式： rn=max(pi+rn-i),其中i为1..n 自顶向下递归实现 1234567CUT-ROD(p, n) if n == 0 return 0 q = -inf for i = 1 to n q = max(q, p[i] + CUT-ROD(p, n - i)) return q C++实现12345678910std::vector&lt;int&gt; p&#123;0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30&#125;;int CutRod(const std::vector&lt;int&gt; &amp;p, int n)&#123; if(n == 0) return 0; int q = -1; for(int i = 1; i &lt;= n; ++i) q = std::max(q, p[i] + CutRod(p, n - i)); return q;&#125; 这种方法虽然很简洁，但是效率实在很差，T(n) = 2n原因在于它反复求解了相同的子问题 使用动态规划方法求解最优钢条切割问题 带备忘的自顶向下法(top-down with memoization)在求解过程中会保存子问题的解（数组或散列表），避免反复求解12345678910111213141516MEMOIZED-CUT-ROD(p, n) let r[0..n] be a new array for i = 0 to n r[i] = -inf return MEMOIZED-CUT-ROD-AUX(p, n, r)MEMOIZED-CUT-ROD-AUX(p, n, r) if r[n] &gt;= 0 return r[n] if n == 0 q = 0 else q = -inf for i = 1 to n q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n - i, r)) r[n] = q return q C++实现12345678910111213141516171819202122int MemoizedCutRodAux(const std::vector&lt;int&gt; &amp;p, int n, std::vector&lt;int&gt; &amp;r)&#123; if(n == 0) return 0; if(r[n] != -1) return r[n]; int q = -1; for(int i = 1; i &lt;= n; ++i) &#123; q = std::max(q, p[i] + MemoizedCutRodAux(p, n - i, r)); &#125; r[n] = q; return q;&#125;int MemoizedCutRod(std::vector&lt;int&gt; &amp;p, int n)&#123; std::vector&lt;int&gt; r(n + 1); for(int i = 1; i &lt;= n; ++i) r[i] = -1; return MemoizedCutRodAux(p, n, r);&#125; 自底向上法(bottom-up method)123456789BOTTOM-UP-CUT-ROD(p, n) let r[0..n] be a new array r[0] = 0 for j = 1 to n q = -inf for i = 1 to j q = max(q, p[i] + r[j - i]) r[j] = q return r[n] C++实现12345678910111213int BottomUpCutRod(const std::vector&lt;int&gt; &amp;p, int n)&#123; std::vector&lt;int&gt; r(n + 1); r[0] = 0; for(int j = 1; j &lt;= n; ++j) &#123; int q = -1; for(int i = 1; i &lt;= j; ++i) q = std::max(q, p[i] + r[j - i]); r[j] = q; &#125; return r[n];&#125; 或者，按照之前第一个递归公式123456789101112131415int BottomUpCutRod2(const std::vector&lt;int&gt; &amp;p, int n)&#123; std::vector&lt;int&gt; r(n + 1); r[0] = 0; for(int j = 1; j &lt;= n; ++j) &#123; //以下3行相当于求p[j],r1 + rj-1,.. rj-1 + r1的最大值 int q = p[j]; for(int i = 1; i &lt; j; ++i) q = std::max(q, r[i] + r[j - i]); //此时q即为最大值 r[j] = q; &#125; return r[n];&#125; 虽然代码只变化了一点点，但感觉是完全不同的两种思想呢 重构解前面虽然给出了最优解的收益值，但并未给出解本身（一个长度列表，给出切割后的每段钢条长度） 1234567891011121314151617EXTENDED-BOTTOM-UP-CUT-ROD(p, n) let r[0..n]and s[0..n]be new arrays r[0] = 0 for j = 1 to n q = -inf for i = 1 to j if a &lt; p[i] + r[j - i] q = p[i] + r[j - i] s[j] = i r[j] = q return r and sPRINT-CUT-ROD-SOLUTION(p, n) (r, s) = EXTENDED-BOTTOM-UP-CUT-ROD(p, n) while n &gt; 0 print s[n] n = n - s[n] C++实现123456789101112131415161718192021222324252627282930313233std::pair&lt;int, std::vector&lt;int&gt;&gt; ExtendedBottomUpCutRod(const std::vector&lt;int&gt; &amp;p, int n)&#123; std::vector&lt;int&gt; r(n + 1); std::vector&lt;int&gt; s(n + 1); r[0] = 0; for(int j = 1; j &lt;= n; ++j) &#123; int q = -1; for(int i = 1; i &lt;= j; ++i) &#123; if(q &lt; p[i] + r[j - i]) &#123; q = p[i] + r[j - i]; s[j] = i; &#125; &#125; r[j] = q; &#125; return&#123;r[n], s&#125;;&#125;void PrintCutRodSolution(const std::vector&lt;int&gt; &amp;p, int n)&#123; auto entry = ExtendedBottomUpCutRod(p, n); auto &amp;s = entry.second; std::cout&lt;&lt; \"cut solution is : \"; while(n &gt; 0) &#123; std::cout&lt;&lt; s[n] &lt;&lt; \" \"; n -= s[n]; &#125;&#125; 矩阵链乘法问题描述：给定n个矩阵的链（A1,A2,…,An）,矩阵Ai的规模为pi-1 * pi，求完全括号化方案，使得计算乘积所需标量乘法次数最少。距离A1,A2,A3的规模分别为10×100、100×5和5×50，则 方案((A1A2)A3)所需的次数为：10×100×5+10×5×50 = 7500 方案(A1( A2A3))所需的次数为：100×5×50+10×100×50 = 75000 可以看出，不同的括号方案，产生的真的是天差地别 计算括号化方案的数量设P(n)为n个矩阵链的方案数量，显然P(1)=1。当n&gt;=2时，完全括号化方案的矩阵乘积可描述为两个完全括号化的部分积相乘的形式，而两个部分积的划分点在第k和k+1个矩阵之间，k为1..n-1。怎么理解这段话呢，假设n为4，则有以下几种划分点 (A1) (A2A3A4), k为1, 注意这里具体A2..4怎么划分是不关心的，因为这已经是P(3)该做的事啦，下同 (A1A2) (A3A4), k为2 (A1A2A3) (A4), k为3可以得到下面的递归式1234 1 如果n = 1P(n) = n-1 ∑ P(k)P(n-k) 如果n &gt;= 2 k=1 应用动态规划法 步骤1：最优括号化方案的结构特征假设AiAi+1…Aj的最优括号化方案的分割点在Ak和Ak+1之间，那么继续对前缀子链AiAi+1…Ak进行括号化时，我们应该直接采用独立求解它时所得的最优方案。我是这么理解这段话的。 假设子链AiAi+1…Ak的最优化方案为P0 假设分割点在k的最优括号化方案没有采用前半段的最优括号化方案P0,而是采用了P1 但此时将P0代入却能得到更低的方案，显然矛盾了。 步骤2：一个递归求解方案令m[i, j]表示计算矩阵Ai..j所需标量乘法次数的最小值，那么原问题的最优解–计算A1..n所需的最低代价就是m[1, n]。 对于i=j时的平凡问题，由于只包含一个矩阵，乘法次数为0 对于i &lt; j，假设AiAi+1…Aj的最优括号化方案的分割点在矩阵Ak和Ak+1之间，那么m[i, j]就等于计算Ai..k和Ak+1..j的代价加上两者相乘的代价的最小值。由于Ai的大小为pi-1×pi，易知Ai..k和Ak+1..j相乘的代价为pi-1pkpj次标量运算。 得到递推公式123 0 如果i = jm[i, j] = min&#123;m[i, k] + m[k+1, j] + pi-1*pk*pj&#125; 如果i &lt; j i &lt;= k &lt;j 并使用s[i, j]保存AiAi+1Aj分割点位置k 步骤3：计算最优代价采用自底向上的表格法代替递归算法来计算最优代价假定矩阵Ai的输入规模是pi-1×pi，程序的输入为p=(p0, p1,…,pn)。并用辅助表m[1..n, 1..n]来保存代价m[i, j]，用s[1..n-1, 2..n]来记录最优值m[i, j]对应的分割点k。还有一个很有意思的点：为了计算m[i, j]需要访问其他哪些表项呢？由递推公式可以知道m[i, j]的计算是依赖于m[i, k]和m[k+1, j]的，而这两项的长度都小于j-i+1。因此可以说m[i,j]的计算只依赖于哪些少于j-i+1个矩阵链相乘的最优计算代价 123456789101112131415MATRIX-CHAIN-ORDER(p) n = p.length - 1 let m[1..n, 1..n] and s[1..n-1, 2..n]be new arrays for i = 1 to n m[i, j] = 0 for l = 2 to n for i = 1 to n - l + 1 j = i + l - 1 m[i, j] = INF for k = i to j - 1 q = m[i, k] + m[k + 1, j] + pi-1*pk*pj if q &lt; m[i, j] m[i, j] = q s[i, j] = k return m and s 步骤4：构造最优解s[i, j]中存放的是什么呢，存放的是m[i,j]对应的分割点1234567PRINT-OPTIMAL-PARENS(s, i, j) if i == j print \"A\"i else print \"(\" PRINT-OPTIMAL-PARENS(s, i, s[i, j]) PRINT-OPTIMAL-PARENS(s, s[i, j] + 1, j) print \")\" C++实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647typedef std::vector&lt;std::vector&lt;int&gt;&gt; Table;void PrintOptimalParens(const Table &amp;s, int i, int j)&#123; if(i == j) std::cout&lt;&lt; \"A\" &lt;&lt; i; else &#123; std::cout&lt;&lt; \"(\"; PrintOptimalParens(s, i, s[i][j]); PrintOptimalParens(s, s[i][j] + 1, j); std::cout&lt;&lt; \")\"; &#125;&#125;void MatrixChainOrder(const std::vector&lt;int&gt; &amp;p)&#123; size_t n = p.size() - 1; Table m(n + 1, std::vector&lt;int&gt;(n + 1)); Table s(n + 1, std::vector&lt;int&gt;(n + 1)); for(int i = 1; i &lt;= n; ++i) // set 0 to chain has length 1 m[i][i] = 0; for(int l = 2; l &lt;= n; l++) // 'l' is the length of chain &#123; for(int i = 1; i &lt;= n - l + 1; ++i) &#123; int j = i + l - 1; // i..j sub chain's length is always 'l' m[i][j] = INT32_MAX; for(int k = i; k &lt; j; ++k) &#123; int q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]; if(q &lt; m[i][j]) &#123; m[i][j] = q; s[i][j] = k; &#125; &#125; &#125; &#125; std::cout&lt;&lt; \"m[1, n] : \" &lt;&lt; m[1][n] &lt;&lt; std::endl; PrintOptimalParens(s, 1, 6); std::cout&lt;&lt; std::endl;&#125;void test()&#123; std::vector&lt;int&gt; p&#123;30, 35, 15, 5, 10, 20, 25&#125;; MatrixChainOrder(p);&#125; 备忘对自然但低效的递归算法加上备忘机制可以达到与自底向上的动态规划相似的效率。其核心是：当递归调用过程中第一次遇到子问题时，计算其解，并存入对应表项，随后每次遇到同一个子问题，只是简单的查表，返回其解 12345678910111213141516171819MEMOIZED-MATRIX-CHAIN(p) n = p.length - 1 let m[1..n, 1..n]be a new table for i = 1 to n for j = i to n m[i, j] = INF return LOOKUP-CHAIN(m, p, 1, n)LOOKUP-CHAIN(m, p, i, j) if m[i, j] &lt; INF return m[i, j] if i == j m[i, j] = 0 else for k = i to j - 1 q = LOOKUP-CHAIN(m, p, i, k) + LOOKUP-CHAIN(m, p, k + 1, j) + pi-1*pk*pj if q &lt; m[i, j] m[i, j] = q return m[i, j] 12345678910111213141516171819202122232425262728293031int LookupChain(Table &amp;m, const std::vector&lt;int&gt; &amp;p, int i, int j)&#123; if(m[i][j] &lt; INT32_MAX) return m[i][j]; if(i == j) m[i][j] = 0; else &#123; for(int k = i; k &lt; j; ++k) &#123; int q = LookupChain(m, p, i, k) + LookupChain(m, p, k + 1, j) + p[i - 1] * p[k] * p[j]; if(q &lt; m[i][j]) m[i][j] = q; &#125; &#125; return m[i][j];&#125;int MemoizedMatrixChain(const std::vector&lt;int&gt; &amp;p)&#123; int n = p.size() - 1; Table m(n + 1, std::vector&lt;int&gt;(n + 1)); for(int i = 1; i &lt;= n; ++i) &#123; for(int j = i; j &lt;= n; ++j) m[i][j] = INT32_MAX; &#125; return LookupChain(m, p, 1, n);&#125; 但是，自底向上动态规划算法，回比自顶向下备忘算法快。 最长公共子序列一个给定序列的子序列就是讲给定序列中的0个或多个元素去掉之后的结果。给定两个序列X和Y，如果Z既是X的子序列，也是Y的子序列，我们称它为X和Y的公共子序列。例如X:(A,B,C,B,D,A,B)和Y:(B,D,C,A,B,A)，那么序列(B,C,A)是X和Y的公共子序列，长度为3，而(B,C,B,A)和(B,D,A,B)是最长公共子序列。最长公共子序列问题(longest-common-subsequence problem)，给定两个序列X和Y，且X和Y长度最长的公共子序列 步骤1：刻画最长公共子序列的特征先考虑暴力搜索方法 穷举X(x1,x2,…,xm)的所有子序列，可以想象每一个项都为一个一个bit位，可以取0或1，这样可以得到总共2m个子序列 已知X的一个子序列，确认其是否为Y的子序列。遍历Y即可，时间为O(n)显然，该方法不实用。定义LCS的最优子结构，令X=(x1,x2,…,xm)和Y=(y1,y2,…,yn)为两个序列，Z=(z1,z2,…,zk)为X和Y的任意LCS 如果xm=yn，则zk=xm=yn，且Zk-1是Xm-1和Yn-1的一个LCS 如果xm!=yn，那么zk!=xm意味着Z是Xm-1和Y的一个LCS 如果xm!=yn，那么zk!=yn意味着Z是X和Yn-1的一个LCS 步骤2：一个递归解 定义c[i, j]表示Xi和Yj的LCS的长度，如果i=0活着j=0，即一个序列长度为0，则LCS的长度为0，公式入下：123 0 若i=0或j=0c[i, j] = c[i-1, j-1] + 1 若i,j&gt;0且xi = yj max(c[i, j-1], c[[i-1, j]]) 若i,j&gt;0且xi != yj 步骤3：计算LCS的长度 算法思想： 将c[i, j]的值保存在表c[0..m, 0..n]中，并按行主次序计算表项 维护表b[1..m, 1..n]帮助构造最优解。其中b[i, j]指向表项对应计算c[i, j]时所选择的子问题最优解 c[m, n]保存了LCS的长度 12345678910111213141516171819LCS-LENGTH(X, Y) m = X.length n = Y.length let b[1..m, 1..n] and c[0..m, 0..n]be new tables for i = 1 to m c[i, 0] = 0 for j = 0 to n c[0, j] = 0 for i = 1 to m for j = 1 to n if x[i] == y[j] c[i, j] = c[i - 1, j - 1] + 1 b[i, j] = '↖' elseif c[i - 1, j] &gt;= c[i, j - 1] c[i, j] = c[i - 1, j] b[i, j] = '↑' else c[i, j] = c[i, j - 1] b[i, j] = '←' return c and b 步骤4：构造LCS 想想上面’↖’,’↑’,’←’三个箭头代表的意义。 如果是’↖’就说明x[i]等于y[j]，且他们是LCS中的一个元素 如果是’↑’,说明c[i - 1, j]和c[i, j]是一样大的 如果是’←’,说明c[i, j - 1]和c[i, j]是一样大的递归迭代即可 123456789PRINT-LCS(b, X, i, j) if i == 0 or j == 0 return if b[i, j] == '↖' PRINT-LCS(b, X, i - 1, j - 1) print x[i] elseif b[i, j] == '↑' PRINT-LCS(b, X, i - 1, j) else PRINT-LCS(b, X, i, j - 1) C++实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162template &lt;typename T&gt;using Table = std::vector&lt;std::vector&lt;T&gt;&gt;;enum Arrow&#123; UP, //up arrow LEFT, //left arrow UL, //upper left arrow&#125;;void PrintLcs(const Table&lt;Arrow&gt; &amp;b, const std::string &amp;X, int i, int j)&#123; if(i == 0 || j == 0) return; if(b[i][j] == UL) &#123; PrintLcs(b, X, i - 1, j - 1); std::cout&lt;&lt; X[i - 1] &lt;&lt; \" \"; &#125; else if(b[i][j] == UP) PrintLcs(b, X, i - 1, j); else PrintLcs(b, X, i, j - 1);&#125;void LcsLength(const std::string &amp;X, const std::string &amp;Y)&#123; int m = X.size(), n = Y.size(); Table&lt;Arrow&gt; b(m + 1, std::vector&lt;Arrow&gt;(n + 1)); Table&lt;int&gt; c(m + 1, std::vector&lt;int&gt;(n + 1)); //initialize for(int i = 1; i &lt;= m; ++i) c[i][0] = 0; for(int j = 0; j &lt;= n; ++j) c[0][j] = 0; //main loop for(int i = 1; i &lt;= m; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; //string suffix is [0..m-1] and [0..n-1] if(X[i - 1] == Y[j - 1]) &#123; c[i][j] = c[i - 1][j - 1] + 1; b[i][j] = UL; &#125; else if(c[i - 1][j] &gt;= c[i][j - 1]) &#123; c[i][j] = c[i - 1][j]; b[i][j] = UP; &#125; else &#123; c[i][j] = c[i][j - 1]; b[i][j] = LEFT; &#125; &#125; &#125; //print result std::cout&lt;&lt; \"LCS is : \"; PrintLcs(b, X, m, n); std::cout&lt;&lt; std::endl;&#125; 15.4-2利用完整的表c及原始序列X,Y来重构LCS，要求运行时间O(m + n)，不使用表b按照题目意思，实现如下 12345678910111213141516171819202122void PrintLcs2(const Table&lt;int&gt; &amp;c, const std::string &amp;X, const std::string &amp;Y, int i, int j)&#123; //一个栈 std::vector&lt;int&gt; stk; while(i != 0 &amp;&amp; j != 0) &#123; if(X[i - 1] == Y[j - 1]) //c[i][j]使用了c[i - 1][j - 1] &#123; i--; j--; stk.push_back(i); &#125; else if(c[i][j] == c[i - 1][j]) //c[i][j]使用了c[i - 1][j] i--; else //c[i][j]使用了c[i][j - 1] j--; &#125; for(int i = stk.size() - 1; i &gt;= 0; --i) std::cout&lt;&lt; X[stk[i]] &lt;&lt; \" \"; std::cout&lt;&lt; std::endl;&#125; 15.4-3设计LCS-LENGTH的带备忘录版本，运行时间为O(mn) 首先考虑不带备忘录的直接递归版，比较简单，根据公式直接递归即可1234567891011121314151617181920212223242526272829303132#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;static int count = 0;int LcsLength(const std::string &amp;X, const std::string &amp;Y, int i, int j)&#123; count++; if(i == 0 || j == 0) return 0; if(X[i - 1] == Y [j - 1]) return LcsLength(X, Y, i - 1, j - 1) + 1; int p = LcsLength(X, Y, i - 1, j), q = LcsLength(X, Y, i, j - 1); if(p &gt;= q) return p; return q;&#125;int LcsLength(const std::string &amp;X, const std::string &amp;Y)&#123; int m = X.size(), n = Y.size(); return LcsLength(X, Y, m, n);&#125;int main()&#123; std::cout&lt;&lt; \"length : \" &lt;&lt; LcsLength(\"ABCBDAB\", \"BDCABA\")&lt;&lt; std::endl; std::cout&lt;&lt; \"count : \" &lt;&lt; count &lt;&lt; std::endl; //这么短的字符串，居然调用了152次 return 0;&#125; 思路如下： c的第一行和第一列都初始化为0，其他项初始化为-1 递归时，如果发现c的某一项不是-1，则说明已处理过，无需再计算12345678910111213141516171819202122232425262728293031323334int LookupLcs(const std::string &amp;X, const std::string &amp;Y, Table&lt;int&gt; &amp;c, int i, int j)&#123; if(i != 0 &amp;&amp; j != 0 &amp;&amp; c[i][j] == -1) &#123; if(X[i - 1] == Y[j - 1]) &#123; c[i][j] = LookupLcs(X, Y, c, i - 1, j - 1) + 1; &#125; else &#123; int p = LookupLcs(X, Y, c, i - 1, j), q = LookupLcs(X, Y, c, i, j - 1); if(p &gt;= q) c[i][j] = p; else c[i][j] = q; &#125; &#125; return c[i][j];&#125;int MemoizedLcsLength(const std::string &amp;X, const std::string &amp;Y)&#123; int m = X.size(), n = Y.size(); Table&lt;int&gt; c(m + 1, std::vector&lt;int&gt;(n + 1)); c[0][0] = 0; for(int i = 1; i &lt;= m; ++i) &#123; c[i][0] = c[0][i] = 0; for(int j = 1; j &lt;= n; ++j) c[i][j] = -1; &#125; return LookupLcs(X, Y, c, m, n);&#125; 15.4-4只是用表c中2×min(m, n)个表项及O(1)的额外空间来计算LCS的长度。然后说明如何只用min(m, n)个表项及O(1)的额外空间完成相同的工作 先来2×min(m, n)，这个比较好想。假设Y的长度小于X的长度，因为如果Y的长度大于X的长度，则只要调用LcsLength(Y, X)就行了嘛。这样就保证了n = min(m, n)。 使用c0保存上一行的信息 c1为当前计算行的信息 c1计算完成之后，将所有项赋值到c0。这样c0重新成为”上一行” 循环迭代即可1234567891011121314151617181920212223242526int LcsLength(const std::string &amp;X, const std::string &amp;Y)&#123; int m = X.size(), n = Y.size(); std::vector&lt;int&gt; c0(n + 1), c1(n + 1); for(int i = 0; i &lt;= n; ++i) c0[i] = 0; for(int i = 1; i &lt;= m; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; if(X[i - 1] == Y[j - 1]) &#123; c1[j] = c0[j - 1] + 1; &#125; else if(c1[j - 1] &gt;= c0[j]) &#123; c1[j] = c1[j - 1]; &#125; else c1[j] = c0[j]; &#125; for(int j = 1; j &lt;= n; ++j) c0[j] = c1[j]; &#125; return c1[n];&#125; 那如何只使用O(min(m, n))的空间呢?我的实现如下1234567891011121314151617181920212223242526int LcsLength2(const std::string &amp;X, const std::string &amp;Y)&#123; int m = X.size(), n = Y.size(); std::vector&lt;int&gt; c(n + 1); for(int i = 0; i &lt;= n; ++i) c[i] = 0; for(int i = 1; i &lt;= m; ++i) &#123; //ul_item始终指向假想存在的前一行的左前方项 int ul_item = c[0]; for(int j = 1; j &lt;= n; ++j) &#123; //计算当前c[j]项时，先保存下来。这样可以假想up_item始终指向前一行的上方项 int up_item = c[j]; if(X[i - 1] == Y[j - 1]) c[j] = ul_item + 1; //前一行的左前方项+1 else if(c[j - 1] &gt; c[j]) //左侧项比上方项大 c[j] = c[j - 1]; //c[j]需要指向左侧项 else ; //否则c[j]则无需修改 //计算下一个值前，左前方项需要重新置为当前上方项 ul_item = up_item; &#125; &#125; return c[n];&#125; 15.4-5设计一个O(n2)时间的算法，求一个n个数的序列的最长单调递增子数列 参考：https://blog.csdn.net/qq_24722301/article/details/44994575 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;void PrintSeq(const std::vector&lt;int&gt; &amp;seq, const std::vector&lt;int&gt; &amp;f)&#123; std::cout&lt;&lt; \"origin seq is : \"; for(auto &amp; i : seq) std::cout&lt;&lt; i &lt;&lt; \" \"; std::cout&lt;&lt; std::endl; int n = seq.size(); int max = 0, max_index = 0; for(int i = 1; i &lt;= n; ++i) &#123; if(f[i] &gt; max) &#123; max = f[i]; max_index = i; &#125; &#125; std::cout&lt;&lt; \"max : \" &lt;&lt; max &lt;&lt; \" index : \" &lt;&lt; max_index &lt;&lt; std::endl; int cur = max, cur_index = max_index; std::stack&lt;int&gt; stk; std::cout&lt;&lt; \"sub sequence is : \"; while(cur &gt; 0) &#123; stk.push(cur_index - 1); while(f[cur_index] != cur - 1) cur_index--; cur = f[cur_index]; &#125; while(!stk.empty()) &#123; std::cout&lt;&lt; seq[stk.top()] &lt;&lt; \" \"; stk.pop(); &#125; std::cout&lt;&lt; std::endl;&#125;void IncreasingSubSeq(const std::vector&lt;int&gt; &amp;seq)&#123; int n = seq.size(); std::vector&lt;int&gt; f(n + 1); f[1] = 1; for(int i = 2; i &lt;= n; ++i) &#123; f[i] = 1; for(int j = 1; j &lt; i; ++j) &#123; if(seq[j - 1] &lt; seq[i - 1] &amp;&amp; f[i] &lt; f[j] + 1) f[i] = f[j] + 1; &#125; &#125; PrintSeq(seq, f);&#125;int main()&#123; std::vector&lt;int&gt; seq&#123;1, 4, 3, 2, 6, 5&#125;; //std::vector&lt;int&gt; seq&#123;5, 6, 1, 2, 3, 4&#125;; IncreasingSubSeq(seq); return 0; 最优二叉搜索树书上说的比较详细，实现如下12345678910111213141516171819202122232425262728293031void OptimalTree(const std::vector&lt;double&gt; &amp;p, const std::vector&lt;double&gt; &amp;q)&#123; int n = p.size() - 1; Table&lt;double&gt; e(n + 2, std::vector&lt;double&gt;(n + 2)); Table&lt;double&gt; w(n + 2, std::vector&lt;double&gt;(n + 2)); Table&lt;int&gt; root(n + 1, std::vector&lt;int&gt;(n + 1)); for(int i = 1; i &lt;= n + 1; ++i) &#123; e[i][i - 1] = q[i - 1]; w[i][i - 1] = q[i - 1]; &#125; for(int l = 1; l &lt;= n; ++l) &#123; for(int i = 1; i &lt;= n - l + 1; ++i) &#123; int j = i + l - 1; e[i][j] = INT32_MAX; w[i][j] = w[i][j - 1] + p[j] + q[j]; for(int k = i; k &lt;= j; ++k) &#123; double t = e[i][k - 1] + e[k + 1][j] + w[i][j]; if(t &lt; e[i][j]) &#123; e[i][j] = t; root[i][j] = k; &#125; &#125; &#125; &#125; std::cout&lt;&lt; \"result : \" &lt;&lt; e[1][n] &lt;&lt; std::endl;&#125; 15.5-1打印最优BST，只想到了很挫的写法1234567891011121314151617181920212223242526272829void PrintTree(const Table&lt;int&gt; &amp;root, int i, int j, int parent)&#123; if(i == j + 1) &#123; if(j &lt; parent) std::cout&lt;&lt; \"d\" &lt;&lt; j &lt;&lt; \" is left child of k\" &lt;&lt; parent &lt;&lt; std::endl; else std::cout&lt;&lt; \"d\" &lt;&lt; j &lt;&lt; \" is right child of k\" &lt;&lt; parent &lt;&lt; std::endl; &#125; else &#123; int cur_index = root[i][j]; if(cur_index &lt; parent) std::cout&lt;&lt; \"k\" &lt;&lt; cur_index &lt;&lt; \" is left child of k\" &lt;&lt; parent &lt;&lt; std::endl; else std::cout&lt;&lt; \"k\" &lt;&lt; cur_index &lt;&lt; \" is right child of k\" &lt;&lt; parent &lt;&lt; std::endl; PrintTree(root, i, cur_index - 1, cur_index); PrintTree(root, cur_index + 1, j, cur_index); &#125;&#125;void ConstructOptimalTree(const Table&lt;int&gt; &amp;root, int i, int j)&#123; int cur_index = root[i][j]; std::cout&lt;&lt; \"k\" &lt;&lt; cur_index &lt;&lt; \" is root\" &lt;&lt; std::endl; PrintTree(root, i, cur_index - 1, cur_index); PrintTree(root, cur_index + 1, j, cur_index);&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"《算法导论》读书笔记","date":"2018-05-01T12:23:51.000Z","path":"2018/05/01/《算法导论》笔记/","text":"参考：https://ita.skanev.com 第二章：算法基础插入排序实现代码12345678910void insert_sort(int arr[], int size)&#123; for(int i = 1; i &lt; size; ++i) &#123; int cur = arr[i], j; for(j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; cur; --j) arr[j+1] = arr[j]; arr[j+1] = cur; &#125;&#125; 2.1-2重写过程插入排序算法，使得按非升序排列解：只要将“arr[j] &gt; cur” 改成“arr[j] &lt; cur”即可 2.1-3 查找问题 1234567int findIndex(int arr[], int size, int data)&#123; for(int i = 0; i &lt; size; ++i) if(arr[i] == data) return i; return -1;&#125; 2.1-4 两个n为二进制相加成n+1位的问题 123456789101112131415161718static constexpr int kN = 6;void binaryAdd()&#123; int left[kN]&#123;1, 0, 1, 0, 0, 1&#125;, right[kN]&#123;0, 1, 1, 0, 1, 0&#125;, result[kN + 1]&#123;0&#125;; int carry = 0; for(int i = kN - 1; i &gt;= 0; --i) &#123; result[i + 1] = left[i] + right[i] + carry; if(result[i + 1] &gt;= 2) &#123; result[i + 1] -= 2; carry = 1; &#125; &#125; result[0] = carry;&#125; 2.2-2选择排序 1234567891011121314void selection_sort(int arr[], int size)&#123; for(int i = 0; i &lt; size; ++i) &#123; int minIndex = i; for(int j = i + 1; j &lt; size; ++j) &#123; if(arr[j] &lt; arr[minIndex]) minIndex = j; &#125; if(minIndex != i) swap(arr[i], arr[minIndex]); &#125;&#125; 归并排序实现代码12345678910111213141516171819202122232425262728293031void merge(int arr[], int p, int q, int r)&#123; int n1 = q - p + 1, n2 = r - q; int *lArr = new int[n1 + 1], *rArr = new int[n2 +1]; for(int i = 0; i &lt; n1; ++i) lArr[i] = arr[p + i]; for(int j = 0; j &lt; n2; ++j) rArr[j] = arr[q + j + 1]; lArr[n1] = rArr[n2] = Inf; int i = 0, j = 0; for(int k = p; k &lt;= r; ++k) &#123; if(lArr[i] &lt;= rArr[j]) arr[k] = lArr[i++]; else arr[k] = rArr[j++]; &#125; delete []lArr; delete []rArr;&#125;void merge_sort(int arr[], int begin, int end)&#123; if(begin &lt; end) &#123; int mid = (begin + end) / 2; merge_sort(arr, begin, mid); merge_sort(arr, mid + 1, end); merge(arr, begin, mid, end); &#125;&#125; 2.3-2不使用哨兵 1234567891011121314151617181920212223void merge(int arr[], int p, int q, int r)&#123; int n1 = q - p + 1, n2 = r - q; int *lArr = new int[n1], *rArr = new int[n2]; for(int i = 0; i &lt; n1; ++i) lArr[i] = arr[p + i]; for(int j = 0; j &lt; n2; ++j) rArr[j] = arr[q + j + 1]; int i = 0, j = 0, k = p; while(i &lt; n1 &amp;&amp; j &lt; n2) &#123; if(lArr[i] &lt;= rArr[j]) arr[k++] = lArr[i++]; else arr[k++] = rArr[j++]; &#125; while(i &lt; n1) arr[k++] = lArr[i++]; while(j &lt; n2) arr[k++] = rArr[j++]; delete []lArr; delete []rArr;&#125; 2.3-6可以用二分查找将插入排序的最坏情况改进到θ(nlgn)吗解：应该不行哈，比较找到元素后还需要移动元素 2.3-7描述一个运行时间为θ(nlgn)的算法，给定n个整数的集合S和另一个整数n，使得确定S中是否存在两个和为x的元素解答：看到这道题我的第一想法直接分治，将原数组分为两一半，则结果有下面3中情况1.在左侧区间 2.在右侧区间 3.左右区间各有一个对于情况1和2，显然时间为T(N/2)但是对于情况3，没有想到能够将时间压缩到cN的方法 相到的第二个方法，步骤如下 使用分治法将原数组升序排列，占用时间θ(nlgn) i从0到n-2循环遍历 每次i循环时，在(i+1, n-1)之间查找元素x-S[i]。因为数组已经有序使用二分法显然应该占用θ(lgn)的时间 步骤2和3合起来应该占用θ(nlgn)的时间，综上，整个时间是符合要求的","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"《深度探索C++对象模型》读书笔记","date":"2018-04-20T12:23:51.000Z","path":"2018/04/20/《深度探索C++对象模型》笔记/","text":"以下所有程序的测试环境为：win10 x64及Linux x86_64 第一章：关于对象C++对象模式C++中有两种class data members : static 和nonstatic有三种class member functions : static、nonstatic和virtual 示例程序如下：12345678910111213141516class Point&#123;public: Point(float xval) : x_(xval) &#123;&#125; virtual ~Point() &#123;&#125; float x() const &#123; return x_; &#125; static int PointCount() &#123; return point_count_; &#125;protected: virtual std::ostream &amp;print(std::ostream &amp;out) const &#123; out&lt;&lt; \"x: \"&lt;&lt; x_; return out; &#125; float x_; static int point_count_;&#125;; 书中介绍三种方法来modeling出各种data members和function members 简单对象模型（A Simple Object Model） 表格驱动对象模型（A Table-driven Object Model） C++对象模型（The C++ Object Model） 前两种模型都未真正应用到C++编译器上，第三种模型才是当前正使用的。要点如下 Nonstatic data members被置于每一个class object之内 static data members则被存放在所有的class object之外 Static和nonstatic function members也被放在所有的class object之外 Virtual function以以下两个步骤支持之 每一个class产生一堆指向virtual functions的指针，放在表格中。该表格被称为virtual table(vtbl) 每一个class objec被添加一个指针，指向相关的virtual table.通常这个指针被称为vptr。vptr的设定和重置都由每一个class的ctr,dtr,copy运算符自动完成。每一个class所关联的type_info object通常放在表格的第一个slot处 书中用图像表示如下： 我的注解：图中vptr虽然放在整个class object的最后，但据我测试得知，不管是ms的cl还是g++，都是将vptr放到最前面。怎么验证书上说的呢，下面一步步来测试 对象大小 1234567891011TEST(PointTest, size)&#123; EXPECT_EQ(4, sizeof(float));#if defined(_WIN32) //in windows, vptr size is 4 Bytes. EXPECT_EQ(8, sizeof(Point));#elif defined(__linux__) //in linux, vptr size is 8, and has 4 Bytes alignment EXPECT_EQ(16, sizeof(Point));#endif&#125; data member的相对位置 12345678910111213TEST(PointTest, datamembers)&#123; Point obj(7.0); Point *pobj = &amp;obj; float *raw = reinterpret_cast&lt;float*&gt;(pobj); #if defined(_WIN32) //Beacuse vptr size is 4 Bytes, so the index '1' is x_; EXPECT_FLOAT_EQ(7.0, raw[1]);#elif defined(__linux__) //Beacuse vptr size is 8 bytes, so the index '2' is x_; EXPECT_FLOAT_EQ(7.0, raw[2]);#endif&#125; 通过vptr找到type_info object还未找到好的验证办法 对象模型如何影响程序书中以一个例子说明，不同的对象模型导致程序会被相应修改假设class X定义了copy ctr, virtual dtr和virtual function foo1234567891011121314151617181920212223242526272829303132333435363738//转换前X foobar()&#123; X xx; X *px= new X; xx.foo(); px-&gt;foo(); delete px; return xx;&#125;//可能被转换为void foobar(X &amp;result_)&#123; //构造result_取代local xx result_.X::X(); //扩展X *px = new X; //先分配相应内存 px = _new(sizeof(X)); //再调用构造函数（有点像C++11的allocator做的事哈） if(px != 0) px-&gt;X::X(); //扩展xx.foo(),注意这里不使用virtual机制 foo(&amp;result_); //使用virtual机制扩展px-&gt;foo() //虚函数表的索引2即为foo函数 (*px-&gt;vtbl[2])(px); //扩展delete px if(px != 0) &#123; //虚函数表的索引1为析构函数 (*px-&gt;vtbl[1])(px); _delete(px); &#125; return;&#125; 关键词带来的差异书中说下面的代码是一个函数调用操作，这个没能理解123//编译报错：invalid conversion from ‘int’ to ‘int*’//看出错信息，应该是编译器尝试将pf定义成int *，并且尝试将1024赋值给int *int (*pf)(1024); 下面的操作是声明，这个好理解的，就是最简单的函数指针么123456789int func()&#123; return 10; &#125;void test()&#123; //declaration of ptr int (*ptr)(); ptr = func; std::cout&lt;&lt; ptr()&lt;&lt; std::endl;&#125; struct和class的取舍我理解书中的意思：struct和class并没有本质的区别，当一个人感觉“比较好”的时候，可以考虑使用struct。但是书中也明确说明了，对于template是不能使用struct的，毕竟C中没有template嘛。 但是有时候C程序员的巧记有时候却成为C++程序员的陷阱。比如：把单一元素的数组放置一个struct的尾端，于是每一个struct objects可以拥有可变大小的数组12345678910111213struct mumble&#123; /*stuff*/ char pc[1];&#125;;//假设这里取得了字符串char *str;//需要把str放到mumble的尾部//struct mumble的长度，加上存储字符串需要的长度struct mumble *pmumb1 = (struct mumble *) malloc(sizeof(struct mumble) + strlen(str) + 1);strcpy(pmumb1-&gt;pc, str); 测试如下1234567891011121314struct mumble&#123; int data; char pc[1];&#125;;void test()&#123; const char *str = \"hello world\"; struct mumble *pmumb1 = (struct mumble *) malloc(sizeof(struct mumble) + strlen(str) + 1); strcpy(pmumb1-&gt;pc, str); printf(\"%s\\n\", pmumb1-&gt;pc);&#125; C的这种做法有一个前提条件，就是：pc一定要指向struct的末尾。但是C++只能保证 凡处于同一access section的数据，保证以其声明次序出现在内存布局中 然而多个access sections的各笔数据，排列次序就不一定了 基类，子类和数据成员没有谁先谁后的强制规定。 vptr和vtbl的存在会影响内存布局 如果需要一个复杂的class object的某部分数据，可以考虑使用组合（composition） 对象的差异C++中直接支持三种parogramming paradigms（程序设计典范） 程序模型（ptocedural model）像C一样，比如字符串处理 123char boy[] = \"Danny\";char *p_son = new char[strlen(boy) + 1];strcpy(p_son, boy); 抽象数据类型模型（abstract data type model, ADT）所谓的抽象就是和一组表达式（public接口）一起提供，而其运算定义仍然未知 123std::string girl = \"Anna\";//operator=()String daughter = girl; 面向对象模型（object-oriented model）次模型有一些彼此相关的类型，通过一个抽象的base class被封装起来 12345678//Book，Video等继承自Library_materials，实际调用时的类型不确定void check_in(Library_materials *pmat)&#123; if(pmat-&gt;late()) pmat-&gt;fine(); pmat-&gt;check_in(); //...&#125; 为了支持OO的多态，只有通过pointer或者reference的间接处理，通过下面的例子来说明12345678910111213141516171819202122232425262728class Base&#123;public: virtual int id() const &#123; return 10; &#125;&#125;;class Derived : public Base&#123;public: int id() const &#123; return 20; &#125;&#125;;TEST(OOTest, test)&#123; //derived object Derived dobj; EXPECT_EQ(20, dobj.id()); //base object Base bobj = dobj; //no polymorphic EXPECT_EQ(10, bobj.id()); Base *pobj = &amp;dobj; //has polymorphic EXPECT_EQ(20, pobj-&gt;id()); Base &amp;robj = dobj; //has polymorphic EXPECT_EQ(20, robj.id());&#125; C++通过下列的方法支持多态 经由一组隐含的转化操作，例如”shape * ps = new Circle()” 经由virtual funtion 机制，”ps-&gt;rotate();” 经由dynamic_cast和typeid运算符（这种方法应该不推荐） 需要多少内存才能够表现一个class object（可以参考之前的测试例子）? nonstatic data members的总和大小 由于alignment的需求而padding上去的孔家 为了支持virtual而由内部产生的任何额外负担 指针的类型指向不同对象的指针有何不同呢? 以内存需求的观点来看，没有什么不同，都需要足够的内存来放置一个机器地址 1234567891011121314151617TEST(PointerTest, size)&#123; Base *pbase = new Base; int *pint = new int(5); std::vector&lt;int&gt; *pvec = new std::vector&lt;int&gt;(5);#if defined(_WIN32) //pointer size is 4 bytes EXPECT_EQ(4, sizeof(pbase)); EXPECT_EQ(4, sizeof(pint)); EXPECT_EQ(4, sizeof(pvec));#elif defined(__linux__) //pointer size is 8 bytes EXPECT_EQ(8, sizeof(pbase)); EXPECT_EQ(8, sizeof(pint)); EXPECT_EQ(8, sizeof(pvec));#endif&#125; 但是不同类型的指针寻址出来的object类型不同。指针类型会教导编译器如何解释某个特定地址中的内容及其大小相应类简单定义如下 123456789101112131415class String&#123;private: int len; char *str;&#125;;class ZooAnimal&#123;public: virtual ~ZooAnimal() &#123;&#125;private: int loc; String name;&#125;; 12345678910111213141516TEST(PointerTest, size2)&#123; ZooAnimal *pobj = new ZooAnimal; ZooAnimal *next = pobj + 1;#if defined(_WIN32) //str(4) + len(4) =&gt; name(8) //loc(4) + vptr(4) + name(8) =&gt; 16 EXPECT_EQ(16, sizeof(ZooAnimal)); EXPECT_EQ(16, long(next) - long(pobj));#elif defined(__linux__) //str(8) + len(4) + alignment(4) =&gt; name(16) //loc(4) + vptr(8) + name(16) + alignment(4) =&gt; 32 EXPECT_EQ(32, sizeof(ZooAnimal)); EXPECT_EQ(32, long(next) - long(pobj));#endif&#125; 书中有一句话很有意思：一个ZooAnimal指针将横跨地址空间1000~1015(在ZooAnimal大小为16的情况下)，怎么理解？上面的测试中有一个pobj+1操作，这表面上是+1，但由测试可知，编译器会将next指针移动16（或32）个位置，这个大小显然就是对象本身的大小。那么void *指针呢？我们不知道它将涵盖怎样的地址空间，这就是为什么void * 指针只能够含有一个地址，而不能够通过它操作所指之object的缘故。 加上多态之后123456789101112class Bear : public ZooAnimal&#123;public: Bear() &#123;&#125; ~Bear() &#123;&#125; void rotate() &#123;&#125; virtual void dance() &#123;&#125;protected: enum Dances &#123;haicaowu&#125;; Dances dances_known; int cell_block;&#125;; 定义Bear继承ZooAnimal之后，可能的内存布局如下12345678910111213TEST(PointerTest, derivedsize)&#123; Bear b; Bear *pb = &amp;b; Bear &amp;rb = *pb;#if defined(_WIN32) //base(16) + 4 + 4 =&gt; 24 EXPECT_EQ(24, sizeof(Bear));#elif defined(__linux__) //base(32) + 4 + 4 =&gt; 40 EXPECT_EQ(40, sizeof(Bear));#endif&#125; 比较：一个Bear指针和一个ZooAnimal指针有什么不同123Bear b;ZooAnimal *pz = &amp;b;Bear *pb = &amp;b; 他们每个都指向Bear object的第一个byte，其间的差别是：pb所涵盖的地址包含整个Bear object，而pz所涵盖的地址只包含Bear object的ZooAnimal subobject.1234567891011121314151617TEST(PointerTest, derivedsize2)&#123; Bear b; ZooAnimal *pz = &amp;b; Bear *pb = &amp;b;#if defined(_WIN32) //base size EXPECT_EQ(16, long(pz + 1) - long(pz)); //total size EXPECT_EQ(24, long(pb + 1) - long(pb));#elif defined(__linux__) //base size EXPECT_EQ(32, long(pz + 1) - long(pz)); //total size EXPECT_EQ(40, long(pb + 1) - long(pb));#endif&#125; 根据上面这个例子，突然想到代码里可能会遇到的一个bug123456789101112131415161718192021222324252627282930class Base&#123;public: virtual int id() const &#123; return 10; &#125;&#125;;class Derived : public Base&#123;public: int id() const &#123; return 20; &#125; int data;&#125;;//assume Base and Derived object has different sizeTEST(PointerTest, fatalerror)&#123; static constexpr int size = 5; Derived *parr = new Derived[size]; for(int i = 0; i &lt; size; ++i) printf(\"%d \", (parr + i)-&gt;id()); printf(\"\\n\"); delete []parr; //fatal error //reason: pbaseArr + 1 do not point to a real Derived object Base *pbaseArr = new Derived[size]; for(int i = 0; i &lt; size; ++i) printf(\"%d \", (pbaseArr + i)-&gt;id()); printf(\"\\n\"); delete []pbaseArr;&#125; 切割问题12345Bear b;//引起切割ZooAnimal za = b;//调用ZooAnimal::rotate()za.rotate(); 为什么调用的是ZooAnimal实体，而不是Bear实体za不是一个Bear，而是一个ZooAnimal。有一个似是而非的观念：OO程序并不支持堆object的直接处理 如果初始化函数将一个object内容完整拷贝到另一个object中去，为什么za的vptr不指向Bear的virtual table答：编译器在初始化和指定材质之间做出了仲裁，编译器必须确保如果某个object含有一个或以上的vptrs，那些vptrs的内容不会被base class object初始化或改变。这段话没有看懂 二重继承可能的内存布局 构造函数语意学开篇举了一个很有趣的例子一个类变量要支持“if(obj)”这种判断操作，一般会重载operator int函数12345678910111213141516171819202122class Object&#123;public: Object(int d=0) : data(d) &#123;&#125; operator int() &#123; return data; &#125;private: int data;&#125;;TEST(ObjectTest, intoperator)&#123; Object obj1(5); if(obj1) SUCCEED(); else FAIL()&lt;&lt;\"object is null\"; Object obj2(0); if(obj2) FAIL()&lt;&lt;\"object is not null\"; else SUCCEED();&#125; 但是这样重载之后，会导致“obj1 &lt;&lt; 1”这样的操作合法（&lt;&lt;被当做左移运算符）。这样很可能导致歧义。文中说Jerry以operator void*()取代operator int()来解决。这个在stl的代码里没有找到相关证据 Default Constructor的建构操作本节主要讨论默认构造函数在什么时候会被编译器产生出来。注意：这说明编译器不会为每个类都生成默认构造函数在以下四种情况下，编译器会生成默认构造函数 带有Default Constructor的Member Class object编译器需要在合成的构造函数中将该成员初始化123456789class Foo &#123;public: Foo() &#123;&#125;&#125;;class Bar &#123;public: Foo foo; char *str; &#125;;//则编译器合成的Bar默认构造函数可能像这样inline Bar::Bar()&#123; //C++伪码 //注意，并未将str也初始化，那是程序员的事 foo.Foo::Foo();&#125; 那如果程序员已经定义了默认构造函数了呢1234567Bar::Bar() &#123; str = 0; &#125;//则编译器会进行扩张，可能的扩张后如下Bar::Bar()&#123; foo.Foo::Foo(); str = 0;&#125; 带有Default Constructo的Base Class类似的道理，默认构造函数需要被合成出来，调用base classes的默认构造函数 带有一个Virtual Function的Class因为vptr和vtbl的存在，编译器需要合成出默认构造函数来初始化每个object的vptr地址 带有一个Virtual Base Class的Class虚基类有些特殊，有多个类虚拟继承虚基类时，虚基类只会存在一个实体。每一种virtual basse class实现法的共通点在于必须使virtual base class在其每一个derived class object中的位置，能够于执行期准备妥当。也就是说编译器在编译器无法决定其位置。12345678910111213class X &#123;public : int i; &#125;;class A : public virtual X &#123; public: int j; &#125;;class B : public virtual X &#123; public: double d; &#125;;class C : public A, public B &#123;public: int k; &#125;;//考虑下面的测试//无法再编译时期决定（resolve）出pa-&gt;X::i的位置void foo(const A *pa) &#123; pa-&gt;i = 1024; &#125;void test()&#123; foo(new A); foo(new C);&#125; cfront的做法是再derived class object的每一个virtual base class中安插一个指针完成。所有经由reference或pointer来存取一个virtual base class的操作都可以通过相关指针完成。比如foo函数可能被改写成如下1void foo(const A *pa) &#123; pa-&gt;__vbcX-&gt;i = 1024; &#125; 其中__vbcX表示编译器所产生的指针，指向virtual base class X.它在class Object的建构期间完成。怎么理解这个__vbcX指针呢，我做了几个小测试没有虚拟继承时的情况1234567891011121314class X &#123;public: int i=0; &#125;;class A : public X &#123;public: int a=3; &#125;;class C : public A &#123;public: int c=3; &#125;;//no virual base classTEST(VCBTest, size)&#123; //i(4) EXPECT_EQ(4, sizeof(X)); //i(4) + a(4) EXPECT_EQ(8, sizeof(A)); //i(4) + a(4) + c(4) EXPECT_EQ(12, sizeof(C));&#125; 有虚拟继承时的情况比较复杂，要搞清楚其内存布局存在困难1234567891011121314151617181920212223242526class X &#123;public: int i=0; &#125;;class A : public virtual X &#123;public: int a=3; &#125;;class B : public virtual X &#123;public: int b=5; &#125;;class C : public A, public B &#123;public: int c=6; &#125;;TEST(VCBTest, size)&#123; EXPECT_EQ(4, sizeof(X));#if defined(_WIN32) //vcb size is 4 bytes //vcb(4) + i(4) + a(4) EXPECT_EQ(12, sizeof(A)); //vcb(4) + i(4) + b(4) EXPECT_EQ(12, sizeof(B)); //size 24 is not obvious EXPECT_EQ(24, sizeof(C));#elif defined(__linux__) //vcb size is 8 bytes //vcb(8) + i(4) + a(4) EXPECT_EQ(16, sizeof(A)); //vcb(8) + i(4) + b(4) EXPECT_EQ(16, sizeof(B)); //size 40 is not obvious EXPECT_EQ(40, sizeof(C));#endif&#125; 不过虚拟继承本身不是很重要，整个chromium中用的也不多 C++新手的常见误解 任何class如果没有定义default constructor,就会合成出一个来 编译器合成出来的default constructor会明确设定class内每一个data member的默认值 Copy Constructor的建构操作本节讨论拷贝构造函数在什么时候被编译器生成出来 注意：“如果一个class未定义出copy constructor，编译器就会自动为他产生一个”这句话是不对的。正确的应该如ARM所说：Default constructors和copy constructors在必要的时候被产生出来 若一个类的声明如下123456789class Word&#123;public: Word(const char *); ~Word() &#123;delete []str; &#125;private: int cnt; char *str;&#125;; 这种情况不会合成default copy constructor(但可能引起崩溃) 若类声明如下123456789101112131415161718class Word&#123;public: Word(conts String &amp;); ~Word();private: int cnt; String str;&#125;;//String 声明了explicit copy constructorclass String&#123;public: String(const char *); String(const String&amp;); ~String();&#125;; 则编译器必须合成一个copy constructor，以便调用member的copy constructor123456//合成的copy constructor(伪码)inline Word::Word(const Word &amp;wd)&#123; str.String::String(wd.str); cnt = wd.cnt;&#125; 那综合而言，什么情况下，不要Bitwise copy semantics(位拷贝)呢？ 当class内含一个member object，且该object声明有一个copy constructor(不管是明确声明还是编译器合成的) 当class的基类存在一个copy constructor(不管是明确声明还是合成) 当class声明了一个或多个virtual functions 当class派生自一个继承串链，其中有一个或多个virtual base classes时 1,2好理解，3,4接下来讨论 先讨论3，总结而言就一句话 重新设定Virtual Table的指针存在虚函数的类中有vptr指针，编译器需要合成一个copy constructor以将vptr适当地初始化考虑下面的例子1234567891011121314151617class ZooAnimal&#123;public: ZooAnimal() &#123;&#125; virtual ~ZooAnimal() &#123;&#125; virtual void animate() &#123;&#125; virtual void draw() &#123;&#125;&#125;;class Bear : public ZooAnimal&#123;public: Bear() &#123;&#125; void animate() &#123;&#125; void draw() &#123;&#125; virtual void dance() &#123;&#125;&#125;; ZooAnimal class object 以另一个ZooAnimal class object作为初值，或者Bear class object 以另一个Bear class object作为初值，都可以靠“bitwise copy senmantics”完成比如123456789TEST(CopyCtrTest, vptr1)&#123; Bear yogi; Bear winnie = yogi; int *py = reinterpret_cast&lt;int*&gt;(&amp;yogi), *pw = reinterpret_cast&lt;int*&gt;(&amp;winnie); //yogi's vptr and winnie's vptr should be equal EXPECT_EQ(py[0], pw[0]);&#125; 可能的内存布局 但是当base class object以其derived class object的内容做初始化时，vptr的复制操作就需要注意了。12345678910TEST(CopyCtrTest, vptr2)&#123; Bear yogi; ZooAnimal franny = yogi; int *py = reinterpret_cast&lt;int*&gt;(&amp;yogi), *pf = reinterpret_cast&lt;int*&gt;(&amp;franny); //yogi's vptr and franny's vptr should not be equal //because franny is not a Bear object but a ZooAnimal object EXPECT_NE(py[0], pf[0]);&#125; 可能的内存布局也就是说合成出来的ZooAnimal copy constructor会明确设定object的vptr指向ZooAnimal class的virtual table，而不是直接从右手边的class object中将其vptr拷贝过来 对于情况4 处理Virtual Base Class Subobject示例程序12345678910111213class Raccoon : public virtual ZooAnimal&#123;public: Raccoon() &#123;&#125; Raccoon(int val) &#123;&#125;&#125;;class RedPanda : public Raccoon&#123;public: RedPanda() &#123;&#125; RedPanda(int val) &#123;&#125;&#125;; 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344TEST(CopyCtrTest, vbc1)&#123;#if defined(_WIN32) //vptr is 4 bytes and vbc is 4 bytes EXPECT_EQ(4, sizeof(ZooAnimal)); EXPECT_EQ(4, sizeof(Bear)); EXPECT_EQ(8, sizeof(Raccoon)); EXPECT_EQ(8, sizeof(RedPanda));#elif defined(__linux__) //why is all 8?? EXPECT_EQ(8, sizeof(ZooAnimal)); EXPECT_EQ(8, sizeof(Bear)); EXPECT_EQ(8, sizeof(Raccoon)); EXPECT_EQ(8, sizeof(RedPanda));#endif&#125;TEST(CopyCtrTest, vbc2)&#123; Raccoon rocky; Raccoon little_critter = rocky; int *pr = reinterpret_cast&lt;int*&gt;(&amp;rocky), *pl = reinterpret_cast&lt;int*&gt;(&amp;little_critter);#if defined(_WIN32) //maybe index 0 is vptr and index 1 is vcb. I am not sure EXPECT_EQ(pr[0], pl[0]); EXPECT_EQ(pr[1], pl[1]);#elif defined(__linux__)#endif&#125;TEST(CopyCtrTest, vbc3)&#123; RedPanda rocky; Raccoon little_critter = rocky; int *pr = reinterpret_cast&lt;int*&gt;(&amp;rocky), *pl = reinterpret_cast&lt;int*&gt;(&amp;little_critter);#if defined(_WIN32) //maybe index 0 is vptr and index 1 is vbc. I am not sure EXPECT_NE(pr[0], pl[0]); EXPECT_NE(pr[1], pl[1]);#elif defined(__linux__)#endif&#125; 也就是说在RedPanda对象作为初值设置Raccoon时，编译器必须合成copy constructor来设定virtual base class pointer/offset的初值 程序转换语意学（Program Transformation Semantics） 明确的初始化操作已知的定义操作1234567X x0;void foo_bar()&#123; X x1(x0); X x2 = x0; X x3 = X(x0);&#125; 转化阶段 重写每一个定义，删除其中的初始化操作 class的copy constructor调用操作被安插进去 可能被转化为如下1234567891011//C++伪码void foo_bar()&#123; X x1; X x2; X x3; //编译器安装X copy constructor x1.X::X(x0); x2.X::X(x0); x3.X::X(x0);&#125; 参数的初始化如下的调用操作1234void foo(X x0);X xx;foo(xx); 可能被转换为12345678void foo(X &amp;x0);//编译器产生的临时性对象X __temp0;//编译器对于copy constructor的调用__temp0.X::X(xx);//重写函数调用操作（注意foo的参数类型已是引用）foo(__temp0); 返回值初始化注意：这个现在可能很不一样了，C++11的编译器都已经使用std::move来优化返回值了吧 如下的调用操作123456X bar()&#123; X xx; //... return xx;&#125; cfront中，可能经历如下双阶段转换 加上一个额外的参数，类型是返回值的引用 返回之前安插copy constructor调用操作12345678void bar(X &amp;__result)&#123; X xx; xx.X::X(); //编译器产生的copy constructor操作 __result.X::X(xx); return;&#125; 这样对bar()的调用操作1X xx = bar(); 将被转换为以下的指令12X xx; //注意这里xx是不需要施行default constructor的bar(xx); 使用者层面做优化如下的代码123456X bar(const T &amp;y, const T &amp;z)&#123; X xx; //以y和z来处理xx return xx;&#125; 建议在X类中新增一个constructor，直接计算xx的值12345X bar(const T &amp;y, const T &amp;z)&#123; //... return X(y, z);&#125; 编译器层面做优化之前的返回优化的bar函数，编译器可以把xx以__resukt取代1234567void bar(X &amp;__result)&#123; //default constructor __result.X::X(); //直接处理__result return;&#125; 这种优化操作就称为Named Return Value(NRV)优化。 Copy Constructor：要还是不要已知3D坐标点类如下：1234567class Point3D&#123;public: Point3D(float x, float y, float z);private: float x_, y_, z_;&#125;; 书中观点很明确，不应当提供一个explict copy constructor，默认的bitwise又快又安全。但是如果类本身需要大量的memberwise初始化操作，那么提供copy constructot函数实体就非常合理了（为了NRV优化）真的是这样吗，来测试一下12345678910111213class Point3D&#123;public: Point3D(float x, float y, float z) : x_(x), y_(y), z_(z) &#123;&#125; //有拷贝构造函数则有NRV，否则没有 Point3D(const Point3D &amp;rhs) : x_(rhs.x_), y_(rhs.y_), z_(rhs.z_) &#123;&#125;private: float x_, y_, z_;&#125;; 测试代码1234567891011121314151617Point3D func()&#123; Point3D xx(1, 2, 3); return xx;&#125;static constexpr int NUM = 100000000;void test()&#123; auto start = std::chrono::system_clock::now(); for(int i = 0;i &lt; NUM; ++i) Point3D a = func(); auto end = std::chrono::system_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"elapse time :%ld microseconds\\n\", duration.count());&#125; 分别在Win10和linux下，有无copy ctr的情况下测试 时间(ms) 有copy ctr(有NRV) 无copy ctr(无NRV) Win10 1391667 874403 Linux 656451 1287036 看来cl和g++的处理很不相同啊，不能妄下结论 然后，书中又提到了一个很容易踩的坑对于有虚函数的类，在构造函数中使用memcpy和memset很危险1234567class Shape&#123;public: //这里会将vptr置空，导致fatal error Shape() &#123;memset(this, 0, sizeof(Shape)); &#125; virtual ~Shape() &#123;&#125;&#125;; 因为编译器扩张的构造函数如下1234567Shape::Shape()&#123; //vptr的设定在使用者代码执行之前 __vptr__Shape = __vtbl__Shape; //这里会将vptr清为0 memset(this, 0, sizeof(Shape));&#125; 额，反正我个人而言是不喜欢用memcpy，memset这种C的库函数的 成员们的初始化队伍（Member Initialization Semantics）当在构造函数中要设定class members的初值是，要么就是经由member initialization list，要不就是在constructor函数本身之内。但是下面几种情况要求必须在initialization list中初始化 当初始化一个reference member时 当初始化一个const member时 当调用base class的constructor，而它拥有一组参数时 当调用一个member class的constructor，而它拥有一组参数时 对于以下构造函数1234567891011class Word&#123; String name_; iint cnt_;public: Word() &#123; name_ = 0; cnt_ = 0; &#125;&#125;; 虽然程序本身没问题，但是合成的构造函数效率很低，可能如下123456789101112Word::Word&#123; //String的默认构造函数 name_.String::String(); //临时性对象 String temp = String(0); //memberwise地拷贝name_ name_.String::operator=(temp); //销毁临时性对象 temp.String::~String(); cnt_ = 0;&#125; 很明显，更有效率的方法12345678910Word::Word : name_(0)&#123; cnt_ = 0;&#125;//可能扩张成如下Word::Word&#123; name_.String::String(0); cnt_ = 0;&#125; 虽然cnt本省不需要优化了，但如果参数是模板参数，即不知道参数的准确类型呢所以结论如下：坚持所有的member初始化操作必须在member initialization list中完成。 inistialization list的初始化操作，由编译器安插的任何explicit user code之前 注意点1:list中的项目初始化次序由class中的members声明次序决定错误代码示例 12345678class X&#123; int i; int j;public: //i先被初始化为未知量，j被初始化为val X(int val) : j(val), i(j) &#123;&#125;&#125;; 注意点2:调用一个member function以设定一个member的初值 1X::X(int val) : i(xfoo(val)), j(val) &#123;&#125; 其中xfoo是X的一个member function.这么做是可以的，但是因为不清楚xfoo对X object的依赖性有多高，所以要谨慎 注意点3:一个derived class member function的返回值作为base class constructor的参数 1234567class FooBar : public X&#123; int fval_;public: int fval() &#123; return fval_; &#125; FooBar(int val) : fval_(val), X(fval()) &#123;&#125;&#125;; 这种情况是有问题的，因为基类的构造函数要安插在成员初始化之前。而成员未初始化是fval()函数的返回值未可知可能的FooBar扩张结果123456FooBar::FooBar&#123; //不是个好主意，此时fval()返回值未可知 X::X(this, this-&gt;fval()); fval_ = val;&#125; Data语意学下面各个类的sizeof应当是？1234class X &#123;&#125;;class Y : public virtual X &#123;&#125;;class Z : public virtual X &#123;&#125;;class A : public Y, public Z &#123;&#125;; 实测结果如下12345678910111213TEST(ObjectTest, size)&#123; EXPECT_EQ(1, sizeof(X));#if defined(_WIN32) EXPECT_EQ(4, sizeof(Y)); EXPECT_EQ(4, sizeof(Z)); EXPECT_EQ(8, sizeof(A));#elif defined(__linux__) EXPECT_EQ(8, sizeof(Y)); EXPECT_EQ(8, sizeof(Z)); EXPECT_EQ(16, sizeof(A));#endif&#125; 说明 空的class会被编译器安插进去一个char，使得这个class的两个objects得以在内存中配置独一无二的地址。 Y和Z的结果怎么回事？其大小受3个因素影响 语言本身的额外负担，语言支持virtual base class需要额外的vbc指针来指向virtual base class subobject。指针大小因平台而异 编译器对特殊情况（empty virtual base class）的优化处理TODO(我猜cl和g++都优化了，内存布局参考下面的图片) alignment限制 Empty virtual base class的特殊处理。注意在linux x64下指针的大小为8 bytes A的大小，有以下几点决定 被大家共享的唯一一个class X实体大小(1 byte) Base class Y的大小，减去“因virtual base class X而配置”的大小。书中这句话有点拗口，我觉得说的就是vbc指针的大小 class A自己的大小：0 byte class A的alignment 这里又要考虑编译器对“empty virtual base class”的特殊处理了，class X实体的1 byte被拿掉。所以cl编译器下的大小为4 + 4 = 8，g++编译器下的大小为8 + 8 = 16 Data Member的绑定（The Binding of a Data Member）情形一：类内外遍历12345678910111213//某个头文件的定义xextern float x;class Point3D&#123;public: Point3D(float, float, float)&#123;&#125; //这里传回和设置的一定是类内的x，而不是extern的那个 float X() const &#123; return x; &#125; void X(int new_x) &#123; x = new_x; &#125;private: float x, y, z;&#125;; 情形二：对于member function的argument list123456789101112typedef int Length;class Point3D&#123;public: //这里的Length为int类型 void mumble(Length val) &#123; val_ = val; &#125; Length mumble() &#123; return val_; &#125;private: typedef float Length; Length val_;&#125;; 可以考虑始终把“nested type声明”放置class的开始处 Data Member的布局（Data Member Layout）考虑下面的类声明1234567891011class Point3D&#123;public: Point3D(float x, float y, float z) : x_(x), y_(y), z_(z) &#123;&#125;private: float x_; static std::list&lt;Point3D*&gt; *freeList; float y_; static const int chunksize = 250; float z_;&#125;; 每一个Point3D对象由3个float组成，次序是x,y,z。static data member存放在程序的data segment中，和个别的class objects无关。来测试验证一下123456789TEST(Point3DTest, size)&#123; EXPECT_EQ(12, sizeof(Point3D)); Point3D point(3, 4, 5); float *p3d = (float*)(&amp;point); EXPECT_FLOAT_EQ(3, p3d[0]); EXPECT_FLOAT_EQ(4, p3d[1]); EXPECT_FLOAT_EQ(5, p3d[2]);&#125; 同时书上说，access sections的多寡不会引起额外负担也就是说，下面的声明和之前是一样的1234567891011class Point3D&#123;private: float x_; static std::list&lt;Point3D*&gt; *freeList;private: float y_; static const int chunkSize = 250;private: float z_;&#125;; Data Member的存取以下为了测试，需要把之前Point3D中private改为public。章节开篇问题，已知下面的定义和使用123Point3D origin, *pt = &amp;origin;origin.x = 0.0;pt-&gt;x = 0.0; 通过origin和pt来存取x有什么重大差异吗 Static Data Members 每个static data member只有一个实体，放在程序的data segment之中 这是C++语言中通过指针和对象存取member结论完全相同的唯一一种情况。 12345//侯捷老师这里的注解应该有问题吧，原作应该就是==，毕竟chunkSize是常量嘛//origin.chunkSize == 250;Point3D::chunkSize == 250;//pt-&gt;chunkSize == 250;Point3D::chunkSize == 250; 如果chunkSize是继承而来的也无关紧要，任然可以直接存取 如果static data member是经由函数调用而被存取 12//这里foobar函数会被求值，虽然没有什么用foobar().chunkSize == 250; 取静态成员地址得到的类型，windows和linux有很大区别 123456789TEST(Point3DTest, staticmember)&#123;#if defined(_WIN32) EXPECT_STREQ(\"int const *\", typeid(&amp;Point3D::chunkSize).name());#elif defined(__linux__) //'P' is pointer,'K' is const, 'i' is int EXPECT_STREQ(\"PKi\", typeid(&amp;Point3D::chunkSize).name());#endif&#125; 对静态成员的编码（name-mangling） Nonstatic Data Member data member的偏移量12345678910111213141516171819202122232425TEST(Point3DTest, datamemberoffset)&#123; float Point3D::* offset_x = &amp;Point3D::x_, Point3D::* offset_y = &amp;Point3D::y_, Point3D::* offset_z = &amp;Point3D::z_; char dst[10]; sprintf(dst, \"%d\", offset_x); int offset_x_int = atoi(dst); sprintf(dst, \"%d\", offset_y); int offset_y_int = atoi(dst); sprintf(dst, \"%d\", offset_z); int offset_z_int = atoi(dst); EXPECT_EQ(0, offset_x_int); EXPECT_EQ(4, offset_y_int); EXPECT_EQ(8, offset_z_int);&#125;TEST(Point3DTest, datamemberoffset2)&#123; Point3D origin(4, 5, 6); long addr_origin = long(&amp;origin), addr_origin_y = long(&amp;origin.y_); //there is no '-1' offset?? EXPECT_EQ(addr_origin_y, addr_origin + 4);&#125; 书中说地址&amp;origin.y_将等于”&amp;origin + (&amp;Point3D::y_ - 1)”，并且特别强调了这里的-1操作，但是我实际测试时，发现并没有-1 对于本节开始的那个问题：两者有什么重大差异吗书中给出答案：当Point3D是一个derived class,而且在其继承结构中有一个virtual base class继承而来的member时，有重大差异，真的是这样吗123456789101112131415161718192021222324class Point &#123; public: float x_; &#125;;class Point2D : public virtual Point &#123; public: float y_; &#125;;class Point3D : public Point2D &#123; float z_; &#125;;void test()&#123; Point3D origin; //Point3D *pt = &amp;origin; Point *pt = &amp;origin; static constexpr int NUM = 100000000; auto start = std::chrono::system_clock::now(); for(int i = 0; i &lt; NUM; ++i) origin.x_ = 0.0; auto end = std::chrono::system_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"elapse time :%ld microseconds\\n\", duration.count()); start = std::chrono::system_clock::now(); for(int i = 0; i &lt; NUM; ++i) pt-&gt;x_ = 0.0; end = std::chrono::system_clock::now(); duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"elapse time :%ld microseconds\\n\", duration.count());&#125; 测试结果如下（Win10, linux基本类似）： 时间(ms) pt类型为Point* pt类型为Point3D* 直接对象存取 187800 185301 指针存取 203222 152793 可以看出，指针的实际类型确实会影响成员的存取性能 继承与Data Member只要继承不要多态（Inheritance without PolyMorphism）考虑下面的类关系1234567891011121314151617181920212223242526272829303132333435class Point2D&#123;public: Point2D(float x=0.0, float y=0.0) : x_(x), y_(y) &#123;&#125; float x() const &#123; return x_; &#125; float y() const &#123; return y_; &#125; void x(float newx) &#123; x_ = newx; &#125; void y(float newy) &#123; y_ = newy; &#125; void operator+=(const Point2D &amp;rhs) &#123; x_ += rhs.x(); y_ += rhs.y(); &#125;protected: float x_, y_;&#125;;class Point3D : public Point2D&#123;public: Point3D(float x=0.0, float y=0.0, float z=0.0) : Point2D(x, y), z_(z) &#123;&#125; float z() const &#123; return z_; &#125; void z(float newz) &#123; z_ = newz; &#125; void operator+=(const Point3D &amp;rhs) &#123; Point2D::operator+=(rhs); z_ += rhs.z(); &#125;protected: float z_;&#125;; 好处很明显，Point2D和Point3D类的声明和使用都不会有所改变，所以这两个抽象类的使用者不需要知道objects是否独立的classes类型测试如下123456789101112131415161718TEST(Point2DTest, member)&#123; EXPECT_EQ( 8, sizeof(Point2D)); Point2D point(3, 4); float *p = (float*)(&amp;point); EXPECT_FLOAT_EQ(3, p[0]); EXPECT_FLOAT_EQ(4, p[1]);&#125;TEST(Point3DTest, member)&#123; EXPECT_EQ(12, sizeof(Point3D)); Point3D point(3, 4, 5); float *p = (float*)(&amp;point); EXPECT_FLOAT_EQ(3, p[0]); EXPECT_FLOAT_EQ(4, p[1]); EXPECT_FLOAT_EQ(5, p[2]);&#125; 存在的问题：有可能为了表现class体系之抽象化而膨胀所需空间。C++语言保证“出现在derived class中的base class subobject”有其完整原样性。考虑下面的例子123456789101112131415161718192021222324252627class Concrete&#123;private: int val; char c1; char c2; char c3;&#125;;class Concrete1&#123;private: int val; char bit1;&#125;;class Concrete2 : public Concrete1&#123;private: char bit2;&#125;;class Concrete3 : public Concrete2&#123;private: char bit3;&#125;; 实际测试123456789101112TEST(ConcreteTest, size)&#123; EXPECT_EQ( 8, sizeof(Concrete)); EXPECT_EQ( 8, sizeof(Concrete1));#if defined(_WIN32) EXPECT_EQ(12, sizeof(Concrete2)); EXPECT_EQ(16, sizeof(Concrete3));#elif defined(__linux__) EXPECT_EQ( 8, sizeof(Concrete2)); EXPECT_EQ( 8, sizeof(Concrete3));#endif&#125; 很遗憾，和书上说的有出入，cl下确实有空间膨胀的问题，但是g++下没有这个问题，难道优化了？ 原始的Concrete object大小为8好理解的 val占4bytes c1,c2,c3各占1bytes alignment需要1bytes Concrete1 object 占用8bytes也好理解。这时alignment为3么 Concrete2和Concrete3的大小就不好理解了。cl编译器下的内存布局应当如书中所说书中还有一大段解释，为什么一定是需要膨胀的。TODO：为什么g++编译器不需要膨胀 加上多态（Adding Polymorphism）如果需要处理坐标点，而不打算在乎他是Point2D或Point3D，那么就需要virtual function啦123456789101112131415161718192021222324252627282930313233343536373839class Point2D&#123;public: Point2D(float x=0.0, float y=0.0) : x_(x), y_(y) &#123;&#125; float x() const &#123; return x_; &#125; float y() const &#123; return y_; &#125; //z's set and get function virtual float z() const &#123; return 0.0; &#125; void x(float newx) &#123; x_ = newx; &#125; void y(float newy) &#123; y_ = newy; &#125; virtual void z(float newz) &#123;&#125; virtual void operator+=(const Point2D &amp;rhs) &#123; x_ += rhs.x(); y_ += rhs.y(); &#125;protected: float x_, y_;&#125;;class Point3D : public Point2D&#123;public: Point3D(float x=0.0, float y=0.0, float z=0.0) : Point2D(x, y), z_(z) &#123;&#125; float z() const override &#123; return z_; &#125; void z(float newz) override &#123; z_ = newz; &#125; //para type is const Point2D &amp; void operator+=(const Point2D &amp;rhs) override &#123; Point2D::operator+=(rhs); z_ += rhs.z(); &#125;protected: float z_;&#125;; 这样声明之后，一个很明显的好处就是弹性较大，一个点既有可能是2d也有可能是3d坐标点，这样的弹性，当然正式面向对象程序设计的中心（非常赞同这句话）。1234567891011121314void foo(Point2D &amp;p1, Point2D &amp;p2)&#123; p1 += p2;&#125;TEST(PointTest, op)&#123; Point2D p1(3, 4); Point3D p2(5, 6, 7); foo(p1, p2); EXPECT_FLOAT_EQ( 8, p1.x()); EXPECT_FLOAT_EQ(10, p1.y()); EXPECT_FLOAT_EQ( 0, p1.z());&#125; 那么这样做的代价是什么呢（我一直相信天下没有免费的午餐） 导入Point2D相关的virtual table 在每个calss object中导入一个vptr 加强constructor,使他能够为vptr设定初值 加强destructor，使他能够抹消指向class相关virtual table的vptr vptr的位置书中说cfront是放在class object的尾端的。我实际测试cl和g++编译器，都是放在最开始的1234567891011121314151617181920212223242526272829struct no_virts&#123; int d1 = 1, d2 = 2;&#125;;class has_virts : public no_virts&#123;public: virtual void foo() &#123;&#125;private: int d3 = 3;&#125;;TEST(HasVirtsTest, VptrTest)&#123; has_virts obj; int *p = (int*)&amp;obj;#if defined(_WIN32) //vptr size is 4, so index 0 is vptr EXPECT_EQ(1, p[1]); EXPECT_EQ(2, p[2]); EXPECT_EQ(3, p[3]);#elif defined(__linux__) //vptr size is 8 bytes, so index 0 and 1 is vptr EXPECT_EQ(1, p[2]); EXPECT_EQ(2, p[3]); EXPECT_EQ(3, p[4]);#endif&#125; 内存布局如下图所示 多重继承（Multiple Inheritance）把vptr放在class object的起始处，如果base class没有virtual function而derived class有，那么单一继承的自然多态就会被打破，在这种情况下，把一个derived object转换为其base类型，就需要编译器的介入，用以调整地址。这段话挺有意思的，来测试一下12345678910111213141516171819TEST(HasVirtsTest, VptrTest2)&#123; has_virts obj, *p1 = &amp;obj; has_virts *p2 = p1; no_virts *pbase = p1; EXPECT_EQ(p1, p2); //base ptr 'pbase' point to first data d1 //derived ptr 'p1' point to vptr //so the diff between pbase and p1 is the size of vptr size#if defined(_WIN32) //vptr size is 4 bytes EXPECT_EQ(4, long(pbase) - long(p1));#elif defined(__linux__) //vptr size is 8 bytes EXPECT_EQ(8, long(pbase) - long(p1));#endif&#125; 考虑如下继承所得的Vertex3D类123456789101112131415161718192021222324252627class Point2D&#123;public: virtual void foo1() &#123;&#125;protected: float x_, y_;&#125;;class Point3D : public Point2D&#123;protected: float z_;&#125;;class Vertex&#123;public: virtual void foo2() &#123;&#125;protected: Vertex *next;&#125;;class Vertex3D : public Point3D, public Vertex&#123;protected: float mumble;&#125;; 内存布局如下图所示（注意实际vptr的位置与书中有出入，实际vptr的位置在起始位置） 将多重派生对象指定给第一个base class的指针，需要付出的成本只有地址的指定操作 第二个及后继的base class的地址指定操作，则需要将地址修改过：加上（或减去，downcast）介于base class subobjects的大小 123456789101112131415TEST(MultipleInheritance, size)&#123; Vertex3D v3d, *pv3d = &amp;v3d; Vertex *pv = &amp;v3d; Point2D *p2d = &amp;v3d; Point3D *p3d = &amp;v3d; //pv is pointer from the second base class //so it will not be equal with the pv3d EXPECT_NE((long)pv3d, (long)pv); EXPECT_EQ(sizeof(Point3D), (long)pv - (long)pv3d); //p2d and p3d is the pointer from first base class EXPECT_EQ(pv3d, p2d); EXPECT_EQ(pv3d, p3d);&#125; 对于pv3d为0的情况要特殊处理123456789101112TEST(MultipleInheritance, size2)&#123; Vertex3D *pv3d = nullptr; Vertex *pv = pv3d; //pv should be null EXPECT_EQ(pv, nullptr); pv3d = new Vertex3D; pv = pv3d; EXPECT_EQ(sizeof(Point3D), (long)pv - (long)pv3d); delete pv3d;&#125; 可能编译器内部有类似于如下的转化1pv = pv3d ? (Vertex*)((char*)pv3d) + sizeof(Point3D) : 0; 为了测试实际的内存布局，在代码中设定了坐标初值x=1, y=2, z=3,mumble=4测试结果如下123456789101112131415161718TEST(MultipleInheritance, mumber)&#123; Vertex3D v3d; float *p = (float*)(&amp;v3d);#if defined(_WIN32) EXPECT_EQ(28, sizeof(Vertex3D)); EXPECT_FLOAT_EQ(1, p[1]); EXPECT_FLOAT_EQ(2, p[2]); EXPECT_FLOAT_EQ(3, p[3]); EXPECT_FLOAT_EQ(4, p[6]);#elif defined(__linux__) EXPECT_EQ(48, sizeof(Vertex3D)); EXPECT_FLOAT_EQ(1, p[2]); EXPECT_FLOAT_EQ(2, p[3]); EXPECT_FLOAT_EQ(3, p[4]); EXPECT_FLOAT_EQ(4, p[10]);#endif&#125; 我自己画出其内存布局如下： 虚拟继承（Virtual Inheritance）class如果含有一个或多个virtual base class subobjects，将被分割成两部分：一个不变局部和一个共享局部 不变局部的部分，不管后继如何衍化，总是拥有固定的offset，这部分数据可直接存取 共享局部数据，会因为每次的派生操作而有变化，只能被间接存取，下面会介绍三种主流间接存取策略 此部分有点复杂，因虚拟继承实际使用不多，故暂时跳过TODO(完成该部分) 对象成员的效率（Object Member Efficency）书中主要测试聚合，封装，单继承，虚拟继承等情况下的存取效率结果要点如下： 单一继承不会影响效率 虚拟继承影响成员效率较大 指向Data Members的指针（Pointer to Data Members）考虑下面的类12345678class Point3D&#123;public: virtual ~Point3D() &#123;&#125; //all in public section for test static Point3D origin; float x_, y_, z_;&#125;; &amp;Point3D::z这种操作将取得z在class object中的偏移量12345678910111213141516171819TEST(Point3DTest, mumberoffset)&#123; char offset[10];#if defined(_WIN32) sprintf(offset, \"%d\", &amp;Point3D::x_); EXPECT_STREQ(\"4\", offset); sprintf(offset, \"%d\", &amp;Point3D::y_); EXPECT_STREQ(\"8\", offset); sprintf(offset, \"%d\", &amp;Point3D::z_); EXPECT_STREQ(\"12\", offset);#elif defined(__linux__) sprintf(offset, \"%d\", &amp;Point3D::x_); EXPECT_STREQ(\"8\", offset); sprintf(offset, \"%d\", &amp;Point3D::y_); EXPECT_STREQ(\"12\", offset); sprintf(offset, \"%d\", &amp;Point3D::z_); EXPECT_STREQ(\"16\", offset);#endif&#125; 书中反复强调，offset的值会被额外加上1，也说出了原因，考虑如下例子123456789float Point3D::* p1 = 0//这里将virtual函数去掉，这样确保x_指向0位置float Point3D::* p2 = &amp;Point3D::x_;//这里判断不应当通过//但是我实际测试发现，即使不加offset 1，该判断也是不通过的//即不会使得“没有指向任何data member”的指针和指向第一个data member的指针相等//TODO:可能编译器做了什么特殊处理了吧if(p1 == p2)&#123;&#125; 对象的地址和对象成员的地址之间的关系是什么呢？看下面的测试12345678910TEST(Point3DTest, mumberoffset2)&#123; Point3D obj; //12(16) is the offset of member in class#if defined(_WIN32) EXPECT_EQ((long)&amp;obj.z_, 12 + (long)&amp;obj);#elif defined(__linux__) EXPECT_EQ((long)&amp;obj.z_, 16 + (long)&amp;obj);#endif&#125; 多重继承的情况在多重继承之下，若要将第二个（及后继）base class和一个“与derived class object绑定”之member结合起来，那么将会因为需要加入offset值而变得相当复杂 123456789101112131415161718192021222324252627282930struct Base1 &#123; int val1=1; &#125;;struct Base2 &#123; int val2=2; &#125;;struct Derived : Base1, Base2 &#123;&#125;;TEST(MultiInheritance, ptomember1)&#123; char offset[10]; //TODO: why offset is all 0 sprintf(offset, \"%d\", &amp;Base1::val1); EXPECT_STREQ(\"0\", offset); sprintf(offset, \"%d\", &amp;Base2::val2); EXPECT_STREQ(\"0\", offset); sprintf(offset, \"%d\", &amp;Derived::val1); EXPECT_STREQ(\"0\", offset); sprintf(offset, \"%d\", &amp;Derived::val1); EXPECT_STREQ(\"0\", offset);&#125;int func(int Derived::* dmp, Derived *pd)&#123; return pd-&gt;*dmp;&#125;TEST(MultiInheritance, ptomember2)&#123; Derived d, *pd = &amp;d; //dmp指向val2，所以func必须返回val2的值 int Base2::* dmp = &amp;Base2::val2; EXPECT_EQ(2, func(dmp, pd));&#125; 指向Members的指针的效率问题总结而言就两句话 单一继承不影响效率 虚拟继承对效率影响很大 Function语意学相关函数定义如下12345678910111213141516171819Point3D Point3D::normalize() const&#123; register float mag = magnitude(); Point3D normal; normal.x_ = x_ / mag; normal.y_ = y_ / mag; normal.z_ = z_ / mag; return normal;&#125;float Point3D::magnitude() const&#123; return sqrt(x_ * x_ + y_ * y_ + z_ * z_);&#125;//调用Point3D obj, *ptr = &amp;obj;obj.normalize();ptr-&gt;normalize(); Member的各种调用方式Nonstatic Member Functions（非静态成员函数） C++的设计准则之一就是：Nonstatic Member Function至少必须和一般fnonmember function有相同的效率。member function会经过以下几个步骤被转化为nonmember的形式 改写函数的signature（原型），安插一个额外的参数（this指针）以magnitude举例，函数原型可能被修改为 1234//注意下面两个const的用法//第一个const只在const函数时才有，表示不能修改成员变量//第二个const表示this指针不能修改，这个是必须要有的Point3D Point3D::magnitude(const Point3D *const this) 将每一个对nonstatic data member的存取操作改为经由this指针 123return sqrt(this-&gt;x_ * this-&gt;x_ + this-&gt;y_ * this-&gt;y_ this-&gt;z_ * this-&gt;z_); 将member function重新写成一个外部函数，并进行mangling处理 1extern magnitude_7Point3DFv(register const Point3D *const this) 名称的特殊处理（Name Mangling）主要讲编译器对变量/函数名称进行特化处理编码的过程。目前编译器并没有统一的编码方法。 Virtual Member Functions（虚拟成员函数） 对于“ptr-&gt;normalize()”这样的调用，在normalize函数为虚函数的情况下，会被转化为1(*ptr-&gt;vptr[1])(ptr); 其中： vptr表示编译器产生的指向virtual table的指针 1为virtual table slot的索引值，关联到normalize函数 第二个ptr边数this指针 对于“obj.normalize()”这样的调用，是没有必要转换为上面虚函数表那样调用的。因为obj的类型已经确定为Point3D经由class object调用一个virtual function，这种操作应该总是被编译器像对待nonstatic member function一样的加以决议 Static Member Functions（静态成员函数）若Point3D::normalize是静态成员函数，则相关调用会被转化1234//obj.normalize();normaize__7Point3DSFv();//ptr-&gt;normalize();normaize__7Point3DSFv(); static member function 没有this指针，它还有以下一些次要特性 不能直接存取class中的 nonstatic members 不能被声明为const、volatile或virtual 不需要经由class object才被调用 取static member function的地址，获得的将是其在内存中的位置，地址的类型不是“指向class member function的指针”，而是“nonmember函数指针”1234567891011121314151617181920class Point3D&#123;public: static unsigned int object_count() &#123; return object_count_; &#125;private: static unsigned int object_count_;&#125;;TEST(Point3DTest, staticmembertype)&#123; const char *name = typeid(&amp;Point3D::object_count).name(); #if defined(_WIN32) EXPECT_STREQ(\"unsigned int (__cdecl*)(void)\", name);#elif defined(__linux__) EXPECT_STREQ(\"PFjvE\", name);#endif&#125; Virtual Member Functions（虚拟成员函数）对于“ptr-&gt;z()”这样的函数调用（其中z()为virtual function），什么信息才能让我在执行期调用正确的函数？ ptr所指向对象的真实类型，这可使我们选择正确的z()实体 z()实体的位置，以便我能够调用它 如何找到virtual function的地址呢 在每一个class object安插上一个由编译器产生的指针（vptr），指向虚函数表 每一个virtual function 被指派一个表格索引值 一个class 只会有 一个virtual table，每一个table内含其对应的class object中索引active virtual function函数实体的地址，包括 这个calss所定义的函数实体。他会overriding可能存在的base class virtual funtion 函数实体 继承自base class的函数实体 一个pure_virtual_called()函数实体（纯虚函数） 考虑如下例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Point&#123;public: virtual ~Point() &#123;&#125; virtual Point&amp; mult(float) = 0; float x() const &#123; return x_; &#125; virtual float y() const &#123; return 0.0; &#125; virtual float z() const &#123; return 0.0; &#125;protected: Point(float x=0.0) : x_(x) &#123;&#125; float x_;&#125;;class Point2D : public Point&#123;public: Point2D(float x=0.0, float y=0.0) : Point(x), y_(y) &#123;&#125; ~Point2D() &#123;&#125; Point2D &amp;mult(float m) override &#123; x_ *= m; y_ *= m; return *this; &#125; float y() const override &#123; return y_; &#125;protected: float y_;&#125;;class Point3D : public Point2D&#123;public: Point3D(float x=0.0, float y=0.0, float z=0.0) : Point2D(x, y), z_(z) &#123;&#125; ~Point3D() &#123;&#125; Point3D &amp;mult(float m) override &#123; Point2D::mult(m); z_ *= m; return *this; &#125; float z() const override &#123; return z_; &#125;protected: float z_;&#125;; 书中给出内存布局（注意，实际中vptr在最前面）测试程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//mult() function 's prototypetypedef Point2D &amp;(*MultPtr2D)(Point2D* const p, float);//x(),y(),z() function 's prototypetypedef float (*DataPtr2D)(const Point2D* const p);TEST(Point2DTest, virtualfunc)&#123; Point2D *ptr = new Point2D(3, 4); //vptr index is 0 void **vptr = reinterpret_cast&lt;void***&gt;(ptr)[0];#if defined(_WIN32) //TODO: I have tried index [0..4] for mult function, but it did not work#elif defined(__linux__) //mult func index is 2 MultPtr2D mult = reinterpret_cast&lt;MultPtr2D&gt;(vptr[2]); Point2D &amp;obj = (mult)(ptr, 3); EXPECT_FLOAT_EQ(9, obj.x()); EXPECT_FLOAT_EQ(12, obj.y()); EXPECT_FLOAT_EQ(0 , obj.z()); //y() index is 3 DataPtr2D yfunc = reinterpret_cast&lt;DataPtr2D&gt;(vptr[3]); //z() index is 4 DataPtr2D zfunc = reinterpret_cast&lt;DataPtr2D&gt;(vptr[4]); EXPECT_FLOAT_EQ(12, yfunc(ptr)); EXPECT_FLOAT_EQ(0, zfunc(ptr));#endif delete ptr;&#125;//mult() function 's prototypetypedef Point3D &amp;(*MultPtr3D)(Point3D* const p, float);//x(),y(),z() function 's prototypetypedef float (*DataPtr3D)(const Point3D* const p);TEST(Point3DTest, virtualfunc)&#123; Point3D *ptr = new Point3D(3, 4, 5); //vptr index is 0 void **vptr = reinterpret_cast&lt;void***&gt;(ptr)[0];#if defined(_WIN32) //TODO: I have tried index [0..4] for mult function, but it did not work#elif defined(__linux__) //mult func index is 2 MultPtr3D mult = reinterpret_cast&lt;MultPtr3D&gt;(vptr[2]); Point3D &amp;obj = (mult)(ptr, 3); EXPECT_FLOAT_EQ(9, obj.x()); EXPECT_FLOAT_EQ(12, obj.y()); EXPECT_FLOAT_EQ(15, obj.z()); //y() index is 3 DataPtr3D yfunc = reinterpret_cast&lt;DataPtr3D&gt;(vptr[3]); //z() index is 4 DataPtr3D zfunc = reinterpret_cast&lt;DataPtr3D&gt;(vptr[4]); EXPECT_FLOAT_EQ(12, yfunc(ptr)); EXPECT_FLOAT_EQ(15, zfunc(ptr));#endif delete ptr;&#125; 如何在编译时期设定virtual function的调用的呢 不知道ptr指向的真正类型，但是经过ptr可以存取到该对象的virtual table 虽然不知道那个z()实体会调用，但是我知道z()函数的地址被放置slot 4 这些信息使得编译器可以将调用操作转换为1(*ptr-&gt;vptr[4])(ptr) 多重继承下的Virtual FunctionsTODO:这一部分比较复杂，主要是说编译器如何在运行时调整指针的offset值来支持多重继承下的虚函数调用。还提到了男神Donald E.Knuth~ 虚拟继承下的Virtual Functions 不要在virtul base class中声明nonstatic data member。 函数的效能 nonmember, static member, non static member效率完全一致 虚函数（单继承，多重继承，虚拟继承）对性能有不同程度的影响 指向Member Functions的指针（Pointer-to-Member Functions）12345678910class Point&#123;public: Point(float x=0.0) : x_(x) &#123;&#125; float x() const &#123; return x_; &#125; virtual float y() const &#123; return 0.0; &#125; virtual float z() const &#123; return 0.0; &#125;protected: float x_;&#125;; 测试程序如下12345678TEST(PointTest, MemberFuncPointer)&#123; Point pt(3); //prototype float (Point::* xptr)() const = &amp;Point::x; //call EXPECT_FLOAT_EQ(3, (pt.*xptr)());&#125; 支持指向 Virtual Member Functios之指针 书中说 对于nonstatic member function去地址，将获得该函数在内存中的地址 对virtual member function取地址，所能获得的是索引值 但我实际测试时，对于virtual函数 cl编译器下取地址获得的还是是内存地址 g++编译器下取得的是索引，但感觉也不是严格按照之前虚函数表的索引来的123printf(\"x():%p\\n\", &amp;Point::x);printf(\"y():%p\\n\", &amp;Point::y);printf(\"z():%p\\n\", &amp;Point::z); 输出123456789cl:x():00EF3580y():00EF248Dz():00EF2488g++:x():0x4010b0y():0x1z():0x9 Inline Functions整本书还有3章，后面的感觉实用性不高，待续","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++多态","date":"2018-04-16T12:23:51.000Z","path":"2018/04/16/对C++多态的新理解/","text":"以前对C++的多态只有使用上面的概念，比如虚函数表等知其然而不知其所以然。 最近在读《深度探索C++对象模型》，有了全新的理解。 具体内容可参考原书4.2节。 下面是我的小测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;stdio.h&gt;#include \"gtest/gtest.h\"class Point&#123;public: virtual ~Point() &#123;&#125; virtual void set_data(float) = 0; float x() const &#123; return x_; &#125; virtual float y() const &#123; return 0.0; &#125; virtual float z() const &#123; return 0.0; &#125;protected: Point(float x=0.0) : x_(x) &#123;&#125; float x_;&#125;;class Point2D : public Point&#123;public: Point2D(float x=0.0, float y=0.0) : Point(x), y_(y) &#123;&#125; void set_data(float d) override &#123; y_ = d; &#125; float y() const override &#123; return y_; &#125;protected: float y_;&#125;;class Point3D : public Point2D&#123;public: Point3D(float x=0.0, float y=0.0, float z=0.0) : Point2D(x, y), z_(z) &#123;&#125; void set_data(float d) override &#123; z_ = d; &#125; float z() const override &#123; return z_; &#125;protected: float z_;&#125;;class PointTest : public testing::Test&#123;protected: void SetUp() &#123; p2d = new Point2D(3, 4); p3d = new Point3D(7, 8, 9); &#125; void TearDown() &#123; delete p2d; delete p3d; &#125; Point *p2d; Point *p3d;&#125;;TEST_F(PointTest, sizetest)&#123; //float size is default 4 EXPECT_EQ(4 , sizeof(float)); //in linux64 sys, vptr's size is 8, and there is 4byte assignment EXPECT_EQ(16, sizeof(Point)); EXPECT_EQ(16, sizeof(Point2D)); EXPECT_EQ(24, sizeof(Point3D));&#125;TEST_F(PointTest, membertest)&#123; float *p1 = reinterpret_cast&lt;float*&gt;(p2d); //in linux64 sys, [0..7] is vptr, so p1[2] is first data, and p1[3] is second data EXPECT_EQ(3, p1[2]); EXPECT_EQ(4, p1[3]); Point *p3d = new Point3D(7, 8, 9); //same reason with above float *p2 = reinterpret_cast&lt;float*&gt;(p3d); EXPECT_EQ(7, p2[2]); EXPECT_EQ(8, p2[3]); EXPECT_EQ(9, p2[4]);&#125;typedef float(*FPtr1)(Point2D *);typedef void (*FPtr2)(Point2D *, float);typedef float(*FPtr3)(Point3D *);typedef void (*FPtr4)(Point3D *, float);/*vtbl's structor is below0: type_info1: destructor2: set_data()3: y()4: z()*/TEST_F(PointTest, vptrtest1)&#123; FPtr1 **fp1 = reinterpret_cast&lt;FPtr1**&gt;(p2d); // this is same as call p2d-&gt;y() EXPECT_FLOAT_EQ(4, (*fp1[0][3])(static_cast&lt;Point2D*&gt;(p2d))); // this is same as call p2d-&gt;z() EXPECT_FLOAT_EQ(0, (*fp1[0][4])(static_cast&lt;Point2D*&gt;(p2d))); FPtr2 **fp2 = reinterpret_cast&lt;FPtr2**&gt;(p2d); // this is same as call p2d-&gt;set_data(10) (*fp2[0][2])(static_cast&lt;Point2D*&gt;(p2d), 10); EXPECT_FLOAT_EQ(10, p2d-&gt;y());&#125;TEST_F(PointTest, vptrtest2)&#123; FPtr3 **fp1 = reinterpret_cast&lt;FPtr3**&gt;(p3d); // this is same as call p3d-&gt;y() EXPECT_FLOAT_EQ(8, (*fp1[0][3])(static_cast&lt;Point3D*&gt;(p3d))); // this is same as call p3d-&gt;z() EXPECT_FLOAT_EQ(9, (*fp1[0][4])(static_cast&lt;Point3D*&gt;(p3d))); FPtr4 **fp2 = reinterpret_cast&lt;FPtr4**&gt;(p3d); // this is same as call p3d-&gt;set_data(10) (*fp2[0][2])(static_cast&lt;Point3D*&gt;(p3d), 20); EXPECT_FLOAT_EQ(20, p3d-&gt;z());&#125;int main(int argc, char **argv)&#123; testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS();&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"图论算法","date":"2018-03-31T03:23:51.000Z","path":"2018/03/31/图论算法/","text":"根据书中说明，代码实现如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;assert.h&gt;#include &lt;string&gt;#include &lt;list&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include \"gtest/gtest.h\"template &lt;typename T&gt;class Graph&#123;private: struct Vertex &#123; //顶点名字 T name; //顶点的邻接表。pair分别表示邻接节点指针和，该路径的权 std::list&lt;std::pair&lt;Vertex *, int&gt;&gt; adjLists_; //节点是否已知，在Dijkstra等算法中用到 bool known; //顶点的入度，在拓扑排序中用到 int indegrees = 0; //最短路径等用于显示路径 Vertex *path; //最短路径等用于显示距离 int dist; //出队次数，验证负值回路用 int dequeue_times; explicit Vertex(const T &amp;n) : name(n) &#123;&#125; &#125;;public: //参数array为顶点名字的列表 explicit Graph(const std::initializer_list&lt;T&gt; &amp;nameArray) : vertexNum_(nameArray.size()), edgeNum_(0) &#123; for(auto &amp;vname : nameArray) vertexMap_[vname] = new Vertex(vname); &#125; //拷贝赋值等设为删除的 Graph(const Graph &amp;) = delete; Graph &amp;operator=(const Graph &amp;) = delete; Graph(Graph &amp;&amp;) = delete; Graph &amp;operator=(Graph &amp;&amp;) = delete; //起止顶点的列表。pair分别表示起、止顶点的名字 void addUnweightedEdge(const std::initializer_list&lt;std::pair&lt;T, T&gt;&gt; &amp;edges) &#123; for(auto &amp;entry : edges) addSingleEdge(entry.first, entry.second); &#125; //起止顶点的列表。第一个pair分别表示起点的名字， 第二个pair代表终点的名字和权 void addWeightedEdge(const std::initializer_list&lt;std::pair&lt;T, std::pair&lt;T, int&gt;&gt;&gt; &amp;edges) &#123; for(auto &amp;entry : edges) addSingleEdge(entry.first, entry.second.first, entry.second.second); &#125; //表示是否无向图 virtual bool isUnDirected() const= 0; //顶点数 int vertexNum() const &#123; return vertexNum_; &#125; //边数 int edgeNum() const &#123; return edgeNum_; &#125; //顶点的邻接顶点 std::vector&lt;T&gt; adjacentVertex(const T &amp;vName) &#123; Vertex *v = vertexMap_[vName]; if(v == nullptr) return &#123;&#125;; std::vector&lt;T&gt; res(v-&gt;adjLists_.size()); int k = 0; for(auto &amp;adj : v-&gt;adjLists_) res[k++] = adj.first-&gt;name; return res; &#125; //顶点间的权值, 若两顶点不邻接，则返回0 int weight(const T &amp;fromName, const T &amp;toName) &#123; Vertex *from = vertexMap_[fromName], *to = vertexMap_[toName]; assert(from != nullptr &amp;&amp; to != nullptr); for(const auto &amp;entry : from-&gt;adjLists_) if(entry.first == to) return entry.second; return 0; &#125; //拓扑排序 std::vector&lt;T&gt; topsort() const &#123; if(isUnDirected()) &#123; printf(\"UnDirectedGraph not support topSort\\n\"); return &#123;&#125;; &#125; //这里新建了一个map，而没有使用修改Vertex结构体里的值 //这样可以多次拓扑排序而不影响结果 std::map&lt;Vertex *, int&gt; indegreeMap; std::queue&lt;Vertex *&gt; vertexQ; for(auto &amp;entry : vertexMap_) &#123; Vertex *v = entry.second; if(v-&gt;indegrees == 0) vertexQ.push(v); else indegreeMap[v] = v-&gt;indegrees; &#125; int count = 0; std::vector&lt;T&gt; res(vertexNum_); while(!vertexQ.empty()) &#123; Vertex *v = vertexQ.front(); vertexQ.pop(); res[count++] = v-&gt;name; for(auto &amp;entry : v-&gt;adjLists_) &#123; Vertex *adj = entry.first; if(--adj-&gt;indegrees == 0) vertexQ.push(adj); &#125; &#125; if(count != vertexNum_) return &#123;&#125;; return res; &#125; //无权最短路径 std::map&lt;T, int&gt; unweighted(const T &amp;vName) &#123; Vertex *src = vertexMap_[vName]; if(!src) return &#123;&#125;; for(auto &amp;entry : vertexMap_) entry.second-&gt;dist = INF; std::map&lt;T, int&gt; res; std::queue&lt;Vertex *&gt; vertexQ; vertexQ.push(src); src-&gt;dist = 0; while(!vertexQ.empty()) &#123; Vertex *v = vertexQ.front(); vertexQ.pop(); res[v-&gt;name] = v-&gt;dist; for(auto &amp;entry : v-&gt;adjLists_) &#123; Vertex *adj = entry.first; if(adj-&gt;dist == INF) &#123; adj-&gt;dist = v-&gt;dist + 1; adj-&gt;path = v; vertexQ.push(adj); &#125; &#125; &#125; return res; &#125; //Dijkstra 算法 std::map&lt;T, int&gt; dijkstra(const T &amp;vName) &#123; Vertex *src = vertexMap_[vName]; if(!src) return &#123;&#125;; for(auto &amp;entry : vertexMap_) &#123; entry.second-&gt;known = false; entry.second-&gt;dist = INF; &#125; std::map&lt;T, int&gt; res; //这里简单的运用优先队列（堆） //其实就是书中说的第二种方法，每次w的距离变化时，把dw插入到优先队列 //空间需求会增大，效率不高 auto cmp = [](Vertex *a, Vertex *b) &#123; return a-&gt;dist &gt; b-&gt;dist; &#125;; std::priority_queue&lt;Vertex *, std::vector&lt;Vertex *&gt;, decltype(cmp)&gt; vertexQ(cmp); src-&gt;dist = 0; vertexQ.push(src); while(!vertexQ.empty()) &#123; Vertex *v = vertexQ.top(); vertexQ.pop(); if(v-&gt;known) continue; v-&gt;known = true; res[v-&gt;name] = v-&gt;dist; for(auto &amp;entry : v-&gt;adjLists_) &#123; Vertex *adj = entry.first; if(!adj-&gt;known &amp;&amp; adj-&gt;dist &gt; entry.second + v-&gt;dist) &#123; adj-&gt;dist = entry.second + v-&gt;dist; adj-&gt;path = v; vertexQ.push(adj); &#125; &#125; &#125; return res; &#125; //具有负边值的最短路径 std::map&lt;T, int&gt; weightedNegative(const T &amp;vName) &#123; Vertex *src = vertexMap_[vName]; if(!src) return &#123;&#125;; for(auto &amp;entry : vertexMap_) &#123; entry.second-&gt;dist = INF; entry.second-&gt;dequeue_times = 0; &#125; //后面要用到find，这里不直接使用queue对象 std::list&lt;Vertex *&gt; vertexQ; src-&gt;dist = 0; vertexQ.push_back(src); std::map&lt;T, int&gt; res; while(!vertexQ.empty()) &#123; Vertex *v = vertexQ.front(); res[v-&gt;name] = v-&gt;dist; vertexQ.pop_front(); if(++(v-&gt;dequeue_times) &gt; vertexNum_) &#123; printf(\"fatal : has negative loop\\n\"); return &#123;&#125;; &#125; for(auto &amp;entry : v-&gt;adjLists_) &#123; Vertex *adj = entry.first; if(adj-&gt;dist &gt; entry.second + v-&gt;dist) &#123; adj-&gt;dist = entry.second + v-&gt;dist; adj-&gt;path = v; if(std::find(vertexQ.begin(), vertexQ.end(), adj) == vertexQ.end()) vertexQ.push_back(adj); &#125; &#125; &#125; return res; &#125; //最小生成树的prim算法 std::map&lt;T, int&gt; prim(const T &amp;vName) &#123; Vertex *src = vertexMap_[vName]; if(!src) return &#123;&#125;; for(auto &amp;entry : vertexMap_) &#123; entry.second-&gt;dist = INF; entry.second-&gt;known = false; &#125; //类似Dijkstra算法 auto cmp = [](Vertex *a, Vertex *b) &#123; return a-&gt;dist &gt; b-&gt;dist; &#125;; std::priority_queue&lt;Vertex *, std::vector&lt;Vertex *&gt;, decltype(cmp)&gt; vertexQ(cmp); src-&gt;dist = 0; vertexQ.push(src); std::map&lt;T, int&gt; res; while(!vertexQ.empty()) &#123; Vertex *v = vertexQ.top(); vertexQ.pop(); if(v-&gt;known) continue; v-&gt;known = true; res[v-&gt;name] = v-&gt;dist; for(auto &amp;entry : v-&gt;adjLists_) &#123; Vertex *adj = entry.first; if(!adj-&gt;known &amp;&amp; adj-&gt;dist &gt; entry.second) &#123; adj-&gt;dist = entry.second; adj-&gt;path = v; vertexQ.push(adj); &#125; &#125; &#125; return res; &#125; //内置不相交集，用于Kruskal算法 class DisjSets &#123; public: explicit DisjSets() &#123;&#125; Vertex *find(Vertex *v) &#123; if(v-&gt;path == nullptr) return v; return find(v-&gt;path); &#125; //这里考虑简单求并 void unionSets(Vertex *v1, Vertex *v2) &#123; v2-&gt;path = v1; &#125; &#125;; struct Edge &#123; Vertex *end_point_1; Vertex *end_point_2; int weight; bool operator &gt;(const Edge &amp;rhs) const &#123; return weight &gt; rhs.weight; &#125; &#125;; std::vector&lt;int&gt; kruskal() &#123; std::priority_queue&lt;Edge, std::vector&lt;Edge&gt;, std::greater&lt;Edge&gt;&gt; pq; for(auto &amp;edge : edges_) pq.push(edge); for(auto &amp;entry : vertexMap_) entry.second-&gt;path = nullptr; DisjSets ds; int edgeAccepted = 0; std::vector&lt;int&gt; res; while(edgeAccepted &lt; vertexNum_ - 1) &#123; auto &amp;edge = pq.top(); Vertex *p1 = edge.end_point_1, *p2 = edge.end_point_2; int weight = edge.weight; Vertex *path1 = ds.find(p1), *path2 = ds.find(p2); pq.pop(); if(path1 != path2) &#123; ds.unionSets(path1, path2); edgeAccepted++; //仅为结果显示 std::cout &lt;&lt; p1-&gt;name &lt;&lt; \" -&gt; \" &lt;&lt; p2-&gt;name &lt;&lt; \" : \" &lt;&lt; weight &lt;&lt; std::endl; res.push_back(weight); &#125; &#125; return res; &#125;private: static constexpr int INF = 1e9; void addSingleEdge(const T &amp;from, const T &amp;to, int weight = 1) &#123; Vertex *fromVertex = vertexMap_[from], *toVertex = vertexMap_[to]; assert(fromVertex != nullptr &amp;&amp; toVertex != nullptr); edges_.push_back(&#123;fromVertex, toVertex, weight&#125;); edgeNum_++; fromVertex-&gt;adjLists_.push_back(&#123;toVertex, weight&#125;); toVertex-&gt;indegrees++; //无向图的边是双向的，相邻的顶点互为邻接顶点 if(isUnDirected()) &#123; toVertex-&gt;adjLists_.push_back(&#123;fromVertex, weight&#125;); fromVertex-&gt;indegrees++; &#125; &#125; //键：顶点名字，值：顶点对象指针。作用：为了快速得到某一个顶点 std::map&lt;T, Vertex *&gt; vertexMap_; std::vector&lt;Edge&gt; edges_; int vertexNum_; int edgeNum_;&#125;;//无向图template&lt;typename T&gt;class UnDirectedGraph : public Graph&lt;T&gt;&#123;public: using Graph&lt;T&gt;::Graph; bool isUnDirected() const override &#123; return true; &#125;&#125;;//有向图template &lt;typename T&gt;class DirectedGraph : public Graph&lt;T&gt;&#123;public: using Graph&lt;T&gt;::Graph; bool isUnDirected() const override &#123; return false; &#125;&#125;; 单元测试如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137TEST(TestUnDirectedGraph, TopSort)&#123; UnDirectedGraph&lt;std::string&gt; graph&#123;\"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\"&#125;; graph.addUnweightedEdge(&#123;&#123;\"v1\", \"v2\"&#125;, &#123;\"v1\", \"v3\"&#125;, &#123;\"v1\", \"v4\"&#125;, &#123;\"v2\", \"v4\"&#125;, &#123;\"v2\", \"v5\"&#125;, &#123;\"v3\", \"v6\"&#125;, &#123;\"v4\", \"v3\"&#125;, &#123;\"v4\", \"v6\"&#125;, &#123;\"v4\", \"v7\"&#125;, &#123;\"v5\", \"v4\"&#125;, &#123;\"v5\", \"v7\"&#125;, &#123;\"v7\", \"v6\"&#125;&#125;); ASSERT_EQ(true, graph.isUnDirected()); ASSERT_EQ(7, graph.vertexNum()); ASSERT_EQ(12, graph.edgeNum()); ASSERT_EQ(std::vector&lt;std::string&gt;(&#123;\"v2\", \"v3\", \"v4\"&#125;), graph.adjacentVertex(\"v1\")); ASSERT_EQ(std::vector&lt;std::string&gt;(&#123;\"v4\", \"v5\", \"v6\"&#125;), graph.adjacentVertex(\"v7\")); ASSERT_EQ(1, graph.weight(\"v1\", \"v4\")); ASSERT_EQ(1, graph.weight(\"v6\", \"v4\")); ASSERT_EQ(std::vector&lt;std::string&gt;(&#123;&#125;), graph.topsort());&#125;TEST(TestUnDirectedGraph, Prim)&#123; UnDirectedGraph&lt;std::string&gt; graph&#123;\"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\"&#125;; graph.addWeightedEdge(&#123;&#123;\"v1\", &#123;\"v2\", 2&#125;&#125;, &#123;\"v1\", &#123;\"v4\", 1 &#125;&#125;, &#123;\"v2\", &#123;\"v4\", 3&#125;&#125;, &#123;\"v2\", &#123;\"v5\", 10&#125;&#125;, &#123;\"v3\", &#123;\"v1\", 4&#125;&#125;, &#123;\"v3\", &#123;\"v6\", 5 &#125;&#125;, &#123;\"v4\", &#123;\"v3\", 2&#125;&#125;, &#123;\"v4\", &#123;\"v5\", 7 &#125;&#125;, &#123;\"v4\", &#123;\"v6\", 8&#125;&#125;, &#123;\"v4\", &#123;\"v7\", 4 &#125;&#125;, &#123;\"v5\", &#123;\"v7\", 6&#125;&#125;, &#123;\"v7\", &#123;\"v6\", 1 &#125;&#125;&#125;); auto m = std::map&lt;std::string, int&gt;(&#123;&#123;\"v1\", 0&#125;, &#123;\"v2\", 2&#125;, &#123;\"v3\", 2&#125;, &#123;\"v4\", 1&#125;, &#123;\"v5\", 6&#125;, &#123;\"v6\", 1&#125;, &#123;\"v7\", 4&#125;&#125;); ASSERT_EQ(m, graph.prim(\"v1\"));&#125;TEST(TestUnDirectedGraph, Kruskal)&#123; UnDirectedGraph&lt;std::string&gt; graph&#123;\"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\"&#125;; graph.addWeightedEdge(&#123;&#123;\"v1\", &#123;\"v2\", 2&#125;&#125;, &#123;\"v1\", &#123;\"v4\", 1 &#125;&#125;, &#123;\"v2\", &#123;\"v4\", 3&#125;&#125;, &#123;\"v2\", &#123;\"v5\", 10&#125;&#125;, &#123;\"v3\", &#123;\"v1\", 4&#125;&#125;, &#123;\"v3\", &#123;\"v6\", 5 &#125;&#125;, &#123;\"v4\", &#123;\"v3\", 2&#125;&#125;, &#123;\"v4\", &#123;\"v5\", 7 &#125;&#125;, &#123;\"v4\", &#123;\"v6\", 8&#125;&#125;, &#123;\"v4\", &#123;\"v7\", 4 &#125;&#125;, &#123;\"v5\", &#123;\"v7\", 6&#125;&#125;, &#123;\"v7\", &#123;\"v6\", 1 &#125;&#125;&#125;); auto m = std::vector&lt;int&gt;(&#123;1, 1, 2, 2, 4, 6&#125;); ASSERT_EQ(m, graph.kruskal());&#125;TEST(TestDirectedGraph, TopSort)&#123; DirectedGraph&lt;std::string&gt; graph&#123;\"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\"&#125;; graph.addUnweightedEdge(&#123;&#123;\"v1\", \"v2\"&#125;, &#123;\"v1\", \"v3\"&#125;, &#123;\"v1\", \"v4\"&#125;, &#123;\"v2\", \"v4\"&#125;, &#123;\"v2\", \"v5\"&#125;, &#123;\"v3\", \"v6\"&#125;, &#123;\"v4\", \"v3\"&#125;, &#123;\"v4\", \"v6\"&#125;, &#123;\"v4\", \"v7\"&#125;, &#123;\"v5\", \"v4\"&#125;, &#123;\"v5\", \"v7\"&#125;, &#123;\"v7\", \"v6\"&#125;&#125;); ASSERT_EQ(false, graph.isUnDirected()); ASSERT_EQ(7, graph.vertexNum()); ASSERT_EQ(12, graph.edgeNum()); ASSERT_EQ(std::vector&lt;std::string&gt;(&#123;\"v2\", \"v3\", \"v4\"&#125;), graph.adjacentVertex(\"v1\")); ASSERT_EQ(std::vector&lt;std::string&gt;(&#123;\"v6\"&#125;), graph.adjacentVertex(\"v7\")); ASSERT_EQ(1, graph.weight(\"v1\", \"v4\")); ASSERT_EQ(0, graph.weight(\"v6\", \"v4\")); ASSERT_EQ(std::vector&lt;std::string&gt;(&#123;\"v1\", \"v2\", \"v5\", \"v4\", \"v3\", \"v7\", \"v6\"&#125;), graph.topsort());&#125;TEST(TestDirectedGraph, UnWeighted)&#123; DirectedGraph&lt;std::string&gt; graph&#123;\"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\"&#125;; graph.addUnweightedEdge(&#123;&#123;\"v1\", \"v2\"&#125;, &#123;\"v1\", \"v4\"&#125;, &#123;\"v2\", \"v4\"&#125;, &#123;\"v2\", \"v5\"&#125;, &#123;\"v3\", \"v1\"&#125;, &#123;\"v3\", \"v6\"&#125;, &#123;\"v4\", \"v3\"&#125;, &#123;\"v4\", \"v5\"&#125;, &#123;\"v4\", \"v6\"&#125;, &#123;\"v4\", \"v7\"&#125;, &#123;\"v5\", \"v7\"&#125;, &#123;\"v7\", \"v6\"&#125;&#125;); auto m = std::map&lt;std::string, int&gt;(&#123;&#123;\"v1\", 1&#125;, &#123;\"v2\", 2&#125;, &#123;\"v3\", 0&#125;, &#123;\"v4\", 2&#125;, &#123;\"v5\", 3&#125;, &#123;\"v6\", 1&#125;, &#123;\"v7\", 3&#125;&#125;); ASSERT_EQ(m, graph.unweighted(\"v3\"));&#125;TEST(TestDirectedGraph, Dijkstra)&#123; DirectedGraph&lt;std::string&gt; graph&#123;\"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\"&#125;; graph.addWeightedEdge(&#123;&#123;\"v1\", &#123;\"v2\", 2&#125;&#125;, &#123;\"v1\", &#123;\"v4\", 1 &#125;&#125;, &#123;\"v2\", &#123;\"v4\", 3&#125;&#125;, &#123;\"v2\", &#123;\"v5\", 10&#125;&#125;, &#123;\"v3\", &#123;\"v1\", 4&#125;&#125;, &#123;\"v3\", &#123;\"v6\", 5 &#125;&#125;, &#123;\"v4\", &#123;\"v3\", 2&#125;&#125;, &#123;\"v4\", &#123;\"v5\", 2 &#125;&#125;, &#123;\"v4\", &#123;\"v6\", 8&#125;&#125;, &#123;\"v4\", &#123;\"v7\", 4 &#125;&#125;, &#123;\"v5\", &#123;\"v7\", 6&#125;&#125;, &#123;\"v7\", &#123;\"v6\", 1 &#125;&#125;&#125;); auto m = std::map&lt;std::string, int&gt;(&#123;&#123;\"v1\", 0&#125;, &#123;\"v2\", 2&#125;, &#123;\"v3\", 3&#125;, &#123;\"v4\", 1&#125;, &#123;\"v5\", 3&#125;, &#123;\"v6\", 6&#125;, &#123;\"v7\", 5&#125;&#125;); ASSERT_EQ(m, graph.dijkstra(\"v1\"));&#125;TEST(TestDirectedGraph, WeightedNegative)&#123; DirectedGraph&lt;std::string&gt; graph&#123;\"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\"&#125;; graph.addWeightedEdge(&#123;&#123;\"v1\", &#123;\"v2\", 2&#125;&#125;, &#123;\"v1\", &#123;\"v4\", 1 &#125;&#125;, &#123;\"v2\", &#123;\"v4\",-2&#125;&#125;, &#123;\"v2\", &#123;\"v5\", 10&#125;&#125;, &#123;\"v3\", &#123;\"v1\", 4&#125;&#125;, &#123;\"v3\", &#123;\"v6\", 5 &#125;&#125;, &#123;\"v4\", &#123;\"v3\", 2&#125;&#125;, &#123;\"v4\", &#123;\"v5\", 2 &#125;&#125;, &#123;\"v4\", &#123;\"v6\", 8&#125;&#125;, &#123;\"v4\", &#123;\"v7\", 4 &#125;&#125;, &#123;\"v5\", &#123;\"v7\",-2&#125;&#125;, &#123;\"v7\", &#123;\"v6\", 1 &#125;&#125;&#125;); auto m = std::map&lt;std::string, int&gt;(&#123;&#123;\"v1\", 0&#125;, &#123;\"v2\", 2&#125;, &#123;\"v3\", 2&#125;, &#123;\"v4\", 0&#125;, &#123;\"v5\", 2&#125;, &#123;\"v6\", 1&#125;, &#123;\"v7\", 0&#125;&#125;); ASSERT_EQ(m, graph.weightedNegative(\"v1\")); //negative Loop DirectedGraph&lt;std::string&gt; graph2&#123;\"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\"&#125;; graph2.addWeightedEdge(&#123;&#123;\"v1\", &#123;\"v2\", 2&#125;&#125;, &#123;\"v1\", &#123;\"v4\", 1 &#125;&#125;, &#123;\"v2\", &#123;\"v4\", 3&#125;&#125;, &#123;\"v2\", &#123;\"v5\", 10&#125;&#125;, &#123;\"v3\", &#123;\"v1\",-4&#125;&#125;, &#123;\"v3\", &#123;\"v6\", 5 &#125;&#125;, &#123;\"v4\", &#123;\"v3\", 2&#125;&#125;, &#123;\"v4\", &#123;\"v5\", 2 &#125;&#125;, &#123;\"v4\", &#123;\"v6\", 8&#125;&#125;, &#123;\"v4\", &#123;\"v7\", 4 &#125;&#125;, &#123;\"v5\", &#123;\"v7\", 6&#125;&#125;, &#123;\"v7\", &#123;\"v6\", 1 &#125;&#125;&#125;); m = std::map&lt;std::string, int&gt;(&#123;&#125;); ASSERT_EQ(m, graph2.weightedNegative(\"v1\"));&#125;int main(int argc, char **argv)&#123; ::testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS();&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++智能指针","date":"2018-03-31T02:23:51.000Z","path":"2018/03/31/简单实现自己的C++智能指针/","text":"unique_ptr简单实现，没有考虑第二个资源释放的模板参数等，慢慢来123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include \"gtest/gtest.h\"template &lt;typename T&gt;class Unique_ptr&#123;public: explicit Unique_ptr(T *raw) : raw_ptr_(raw) &#123;&#125; Unique_ptr(const Unique_ptr &amp;) = delete; Unique_ptr &amp;operator=(const Unique_ptr &amp;) = delete; Unique_ptr(Unique_ptr &amp;&amp;rhs) : raw_ptr_(rhs.raw_ptr_) &#123; rhs.raw_ptr_ = nullptr; &#125; Unique_ptr &amp;operator=(Unique_ptr &amp;&amp;rhs) &#123; if(this != &amp;rhs) &#123; reset(rhs.raw_ptr_); rhs.raw_ptr_ = nullptr; &#125; return *this; &#125; ~Unique_ptr() &#123; if(raw_ptr_) delete raw_ptr_; &#125; void reset(T *raw = nullptr) &#123; if(raw_ptr_) delete raw_ptr_; raw_ptr_ = raw; &#125; T *release() &#123; T *temp = raw_ptr_; raw_ptr_ = nullptr; return temp; &#125; T &amp;operator *() &#123; assert(raw_ptr_ != nullptr); return *raw_ptr_; &#125; T *operator-&gt;() &#123; assert(raw_ptr_ != nullptr); return raw_ptr_; &#125;private: T *raw_ptr_;&#125;;template &lt;typename T, typename ...Args&gt;Unique_ptr&lt;T&gt; Make_Unique(const Args &amp;...rest)&#123; return Unique_ptr&lt;T&gt;(new T(rest...));&#125;class Object&#123;public: explicit Object(int id) : id_(id) &#123; instances++; &#125; int operation() const &#123; return id_; &#125; Object(const Object &amp;) = delete; Object &amp;operator=(const Object &amp;) = delete; Object(Object &amp;&amp;rhs) = delete; Object &amp;operator=(Object &amp;&amp;rhs) = delete; ~Object() &#123; instances--; &#125; static int instances;private: int id_;&#125;;int Object::instances = 0;TEST(UniquePtrTest, NullPointer)&#123; auto pnull = Unique_ptr&lt;Object&gt;(nullptr); ASSERT_EQ(0, Object::instances);&#125;TEST(UniquePtrTest, AutoRelease)&#123; &#123; auto pobj1 = Unique_ptr&lt;Object&gt;(new Object(3)); ASSERT_EQ(1, Object::instances); &#125; ASSERT_EQ(0, Object::instances);&#125;TEST(UniquePtrTest, MoveCopy)&#123; auto pobj1 = Unique_ptr&lt;Object&gt;(new Object(3)); auto pobj2(std::move(pobj1)); ASSERT_EQ(1, Object::instances);&#125;TEST(UniquePtrTest, MoveOperator)&#123; auto pobj1 = Unique_ptr&lt;Object&gt;(new Object(3)); auto pobj2 = std::move(pobj1); ASSERT_EQ(1, Object::instances);&#125;TEST(UniquePtrTest, Reset)&#123; auto pobj1 = Unique_ptr&lt;Object&gt;(new Object(3)); pobj1.reset(); ASSERT_EQ(0, Object::instances); pobj1.reset(new Object(1)); ASSERT_EQ(1, Object::instances);&#125;TEST(UniquePtrTest, Release)&#123; auto pobj1 = Unique_ptr&lt;Object&gt;(new Object(3)); Object *p = pobj1.release(); ASSERT_EQ(1, Object::instances); ASSERT_EQ(3, p-&gt;operation()); delete p;&#125;TEST(UniquePtrTest, Operator)&#123; auto pobj1 = Unique_ptr&lt;Object&gt;(new Object(3)); ASSERT_EQ(3, (*pobj1).operation()); ASSERT_EQ(3, pobj1-&gt;operation());&#125;int main(int argc, char **argv)&#123; ::testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS();&#125; shared_ptr依然是简单实现，意思一下。没有考虑传递第二个函数指针的功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include \"gtest/gtest.h\"template &lt;typename T&gt;class Shared_ptr&#123;public: explicit Shared_ptr(T *raw) : raw_ptr_(raw) &#123; if(raw_ptr_) users_ = new int(1); else users_ = new int(0); &#125; //注意这里一定是浅拷贝 Shared_ptr(const Shared_ptr &amp;rhs) &#123; shallow_copy(rhs); &#125; Shared_ptr &amp;operator=(const Shared_ptr &amp;rhs) &#123; if(this != &amp;rhs) &#123; checkIsLast(); shallow_copy(rhs); &#125; return *this; &#125; ~Shared_ptr() &#123; checkIsLast(); &#125; int use_count() const &#123; return users_ == nullptr ? 0 : *users_; &#125; T &amp;operator*() &#123; assert(raw_ptr_ != nullptr); return *raw_ptr_; &#125; T *operator-&gt;() &#123; assert(raw_ptr_ != nullptr); return raw_ptr_; &#125;private: void shallow_copy(const Shared_ptr &amp;rhs) &#123; raw_ptr_ = rhs.raw_ptr_; users_ = rhs.users_; ++(*users_); &#125; void checkIsLast() &#123; if(--(*users_) == 0) &#123; delete raw_ptr_; raw_ptr_ = nullptr; delete users_; users_ = nullptr; &#125; &#125; T *raw_ptr_; int *users_;&#125;;TEST(SharedPtrTest, NullPointer)&#123; auto pnull = Shared_ptr&lt;Object&gt;(nullptr); ASSERT_EQ(0, Object::instances);&#125;TEST(SharedPtrTest, AutoRelease)&#123; &#123; auto pobj1 = Shared_ptr&lt;Object&gt;(new Object(3)); ASSERT_EQ(1, Object::instances); ASSERT_EQ(1, pobj1.use_count()); &#125; ASSERT_EQ(0, Object::instances);&#125;TEST(SharedPtrTest, CopyCtr)&#123; &#123; auto pobj1 = Shared_ptr&lt;Object&gt;(new Object(3)); auto pobj2(pobj1); ASSERT_EQ(1, Object::instances); ASSERT_EQ(2, pobj2.use_count()); &#125; ASSERT_EQ(0, Object::instances);&#125;TEST(SharedPtrTest, Assignment)&#123; &#123; auto pobj1 = Shared_ptr&lt;Object&gt;(new Object(3)); auto pobj2 = Shared_ptr&lt;Object&gt;(new Object(4)); ASSERT_EQ(2, Object::instances); ASSERT_EQ(1, pobj1.use_count()); ASSERT_EQ(1, pobj2.use_count()); pobj1 = pobj2; ASSERT_EQ(1, Object::instances); ASSERT_EQ(2, pobj1.use_count()); ASSERT_EQ(2, pobj2.use_count()); ASSERT_EQ(4, pobj1-&gt;operation()); &#125; ASSERT_EQ(0, Object::instances);&#125;int main(int argc, char **argv)&#123; ::testing::InitGoogleTest(&amp;argc, argv); return RUN_ALL_TESTS();&#125; weak_ptr待续","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"经典算法系列（四）","date":"2018-03-10T11:23:51.000Z","path":"2018/03/10/经典算法系列（四）/","text":"中序转后序实现如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#define MAX 80int priority(char op)&#123; switch(op) &#123; case '+': case '-': return 1; case '*': case '/': return 2; default: return 0; &#125;&#125;//中缀表达式转后缀表达式void infixToPostfix(const char *infix)&#123; //输出后缀式 char postfix[MAX] = &#123;0&#125;; //模拟栈数据结构 char stack[MAX] = &#123;0&#125;; //栈顶索引 int top = -1; //输出索引 int index = 0; for(int i = 0; infix[i] != '\\0'; ++i) &#123; char ch = infix[i]; switch(ch) &#123; case '(': //'('拥有最高优先级，直接入栈 stack[++top] = ch; break; case ')': //出栈，直到遇到'(' while(stack[top] != '(') postfix[index++] = stack[top--]; //'('不输出 top--; break; case '+': case '-': case '*': case '/': //出栈，直到栈空或者遇到比当前操作符优先级小的操作符 while(top &gt;= 0 &amp;&amp; priority(stack[top]) &gt;= priority(ch)) postfix[index++] = stack[top--]; //当前操作符入栈 stack[++top] = ch; break; default: //其他字符直接输出 postfix[index++] = ch; break; &#125;; &#125; while(top &gt;= 0) postfix[index++] = stack[top--]; printf(\"input infix :%s\\n\", infix); printf(\"output postfix :%s\\n\", postfix);&#125;int main()&#123; infixToPostfix(\"a+b*c+(d*e+f)*g\"); return 0; &#125; 和之前从中缀转换为后缀表达式思路是完全一致的。只是这里没有使用栈对象，而是栈这种数据结构。参考中序式轉後序式 洗扑克牌将52张扑克牌乱序排列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int randint(int low, int high)&#123; return rand() % (high - low + 1) + low;&#125;static const int NUM = 52;//洗牌，输出乱序排列放的void shuffle()&#123; //数组中存放0..51的值 int array[NUM]; //数组中的值除以4表示具体的牌数字，模4表示具体的花色 //模4的结果0,1,2,3分别表示红心H，方片F，黑桃T，梅花M //比如数字7表示梅花2 for(int i = 0; i &lt; NUM; ++i) array[i] = i; for(int i = 0; i &lt; NUM - 1; ++i) &#123; int j = randint(i, NUM - 1); int temp = array[j]; array[j] = array[i]; array[i] = temp; &#125; for(int i = 0; i &lt; NUM; ++i) &#123; switch(array[i] % 4) &#123; case 0: printf(\"H\"); break; case 1: printf(\"F\"); break; case 2: printf(\"T\"); break; case 3: printf(\"M\"); break; &#125; int div = array[i] / 4; if(div == 0) printf(\"A\"); else if(div &lt;= 9) printf(\"%d\", div + 1); else if(div == 10) printf(\"J\"); else if(div == 11) printf(\"Q\"); else if(div == 12) printf(\"K\"); printf(\" \"); if((i + 1) % 13 == 0) printf(\"\\n\"); &#125;&#125;int main()&#123; srand(time(NULL)); shuffle(); return 0;&#125; 需要注意的是洗牌，也就是取得N个随机不重复整数的算法是参考编程珠玑再一次证明，这个算法真的很有用啊！ 赌博游戏 描述 玩家掷两个骰子，点数为1到6，如果第一次点数和为7或11，则玩家胜如果点数和为2、3或12，则玩家输如果和为其它点数，则记录第一次的点数和，然后继续掷骰，直至点数和等于第一次掷出的点数和，则玩家胜，如果在这之前掷出了点数和为7，则玩家输。 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int getRandPoints()&#123; int t = rand() % 6 + 1; printf(\"get points:%d\\n\", t); return t;&#125;void diceGame()&#123; int num1 = getRandPoints(), num2 = getRandPoints(), sum = num1 + num2; switch(sum) &#123; case 7: case 11: printf(\"you win\\n\"); return; case 2: case 3: case 12: printf(\"you lose\\n\"); return; default: while(true) &#123; num1 = getRandPoints(); num2 = getRandPoints(); if(num1 + num2 == 7) &#123; printf(\"you lose\\n\"); return; &#125; else if(num1 + num2 == sum) &#123; printf(\"you win\\n\"); return; &#125; &#125; &#125;&#125;int main()&#123; srand(time(NULL)); diceGame(); return 0;&#125; 题目本身没什么难度，但是通过模拟一亿次游戏，发现胜率大概在0.4929，赌博害人啊。 约瑟夫问题 描述着名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从，Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。 给定N(总人数)，M(间隔)，要求最后一个留着的人 解法1：使用数组 1234567891011121314151617181920212223242526272829303132static const int N = 41;static const int M = 3;void josephus1()&#123; bool arr[N + 1]; for(int i = 1; i &lt;= N; ++i) arr[i] = true; int killSum = 0, curCount = 0, index = 0; while(true) &#123; if(index == N) index = 1; else index++; if(arr[index] == true) &#123; curCount++; if(curCount == 3) &#123; if(killSum == N - 1) &#123; printf(\"last is:%d\\n\", index); return; &#125; arr[index] = false; killSum++; curCount = 0; &#125; &#125; &#125;&#125; 牛b解法参考约瑟夫环问题详解,用递归的思想解决Josephus问题 123456789101112131415//返回人编号（从0开始）int josephus_recursive(int n, int m)&#123; if(n == 1) return 0; return (josephus_recursive(n - 1, m) + m) % n;&#125;int josephus_loop(int n, int m)&#123; int result = 0; for(int i = 2; i &lt;= n; ++i) result = (result + m) % i; return result;&#125; 大牛还是厉害，啥也不说了，搬砖吧。 排列组合 描述将一组数字、字母或符号进行排列，以得到不同的组合顺序，例如1 2 3这三个数的排列组合有：1 2 3、1 3 2、2 1 3、2 3 1、3 1 2、3 2 1。 实现 123456789101112131415void combination(char src[], int depth)&#123; if(src[depth] == '\\0') &#123; printf(\"%s\\n\", src); return; &#125; combination(src, depth + 1); for(int i = depth + 1; src[i] != '\\0'; ++i) &#123; swap(src[i], src[depth]); combination(src, depth + 1); swap(src[i], src[depth]); &#125;&#125; 格雷码 描述Gray Code是一个数列集合，每个数使用二进位来表示，假设使用n位元来表示每个数好了，任两个数之间只有一个位元值不同，例如以下为3位元的Gray Code：000 001 011 010 110 111 101 1004位元的Gray Code如下：0000 0001 0011 0010 0110 0111 0101 01001100 1101 1111 1110 1010 1011 1001 1000 解法看到这个问题，第一直觉就是找规律，我找到的规律如下（以4位为例） 12345678第一次变化(0000-&gt;0001)的比特位为第0位第二次变化(0001-&gt;0011)的比特位为第右数第一个1的左边位第三次变化(0011-&gt;0010)的比特位为第0位第四次变化(0010-&gt;0110)的比特位为第右数第一个1的左边位...变化的比特位为：- 奇数项取反第0位- 偶数项取反右数第一个1的左边位 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//print bytes of numbervoid printBytes(int num, int len)&#123; assert(len &gt; 0); bool *stack = new bool[len]&#123;0&#125;; int top = -1; while(num != 0) &#123; if(++top &gt;= len) return; stack[top] = num % 2; num /= 2; &#125; top = len - 1; while(top &gt;= 0) printf(\"%d\", stack[top--]); printf(\"\\n\"); delete []stack;&#125;//获取从右往左数，第一个1的位置int posOfFirst1(int num)&#123; if(num == 0) return -1; int pos = 0; while((num &amp; (1 &lt;&lt; pos)) == 0) pos++; return pos;&#125;void printGrayCode(int len)&#123; if(len &lt;= 0) return; int count = 0, num = 0; while(true) &#123; if(count % 2 != 0) num ^= 1; //奇数项总是取反第0位 else &#123; int pos = posOfFirst1(num); if(pos == len - 1) break; if(pos != -1) num ^= 1 &lt;&lt; (pos + 1); //非0偶数项，取反右边第一个1的左边位元 &#125; printBytes(num, len); count++; &#125;&#125; 产生可能的集合 描述给定一组数字或符号，产生所有可能的集合（包括空集合）， 例如给定1 2 3，则可能的集合为：{}、{1}、{1,2}、{1,2,3}、{1,3}、{2}、{2,3}、{3}。 123456789101112131415161718192021222324252627282930void generateAllSet(const char *src)&#123; int len = strlen(src); assert(len &lt;= 32); //以一个整形来表示所有可能的集合 int num = 0; while(true) &#123; printf(\"&#123;\"); int count = 0; for(int i = 0; i &lt; len; ++i) &#123; if((1 &lt;&lt; i) &gt; num) break; if(((1 &lt;&lt; i) &amp; num) != 0) &#123; if(count != 0) printf(\",\"); printf(\"%c\", src[i]); count++; &#125; &#125; printf(\"&#125;\\n\"); if(++num &gt;= (1 &lt;&lt; len)) break; &#125;&#125;const char *src = \"123\";generateAllSet(src); 生成m元素集合的n个元素子集 描述假设有5个元素的集点，取出3个元素的可能子集如下：{1 2 3}、{1 2 4 }、{1 2 5}、{1 3 4}、{1 3 5}、{1 4 5}、{2 3 4}、{2 3 5}、{2 4 5}、{3 4 5}","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"常见背包问题合集","date":"2018-03-09T11:23:51.000Z","path":"2018/03/09/常见背包问题合集/","text":"各种常见的背包问题，其实算法思想类似，都是利用动态规划（Dynamic Programming，DP）的思想。先来看最经典的01背包问题。 01背包问题参考动态规划01背包问题 描述给定n种物品和一背包。物品i的重量是wi，其价值为vi，背包的容量为C。问应如何选择装入背包的物品，使得装入背包中物品的总价值最大?对于一种物品，要么装入背包，要么不装。所以对于一种物品的装入状态可以取0和1。 示例设物品个数N=5,物品重量weight[n]={0，2，2，6，5，4},物品价值value[n]={0，6，3，5，4，6},背包容量C=10求可以装的最大价值 解题思路 建立数组m[N+1][C+1]，其中m[i][j]表示“在容量为j的背包中，放置前i个物品，所能得到的最大价值”，这句话是精髓，把这句话理解了，整个算法就好理解了 先放置第1个物品，即i=1。则m[1][1]=0，因为在一个容量为1（j=1）的背包中，是放不下物品1（weight[1]=2）的；m[1][2..10]=6，因为在一个容量&gt;=2的背包中，是能放下物品2的（注意01背包问题物品只能放一次），所有最大价值都是6 再放置物品2。m[2][1]=0，这个容易理解，因为物品1和物品2都不能放置在容量为1的背包。m[2][2]=?,这个有点不太好理解了。存在两种可能①如果放置了物品1，则此时背包剩余容量为0，不能再放置物品2，价值为6（value[1]=6）②如果不放置物品1，则放置物品2，此时背包剩余容量为0，价值为3（value[2]=3）下面所有的推导都是参考这个逻辑（具体公式下面有） 由上面的推导可以得出公式123456789101112//求m[i][j]的公式if 物品i的重量大于j : //物品i不能放到容量为j的背包中 m[i][j] = m[i - 1][j] else : //物品i可以放到容量为j的背包中，则有两种情况 //1. 物品i不放置，此时价值为m[i - 1][j] //2. 物品i放置，背包容量为j - weight[i]，此时的总价值为 //\"在容量为j - weight[i]的背包中放置前i - 1个物品的价值\" + \"物品i的价值\" //即m[i - 1][j - weight[i]] + value[i] //所以整个的m[i][j]为取这两个中的大者 m[i][j] = max&#123;m[i - 1][j], m[i - 1][j - weight[i]] + value[i]&#125; 整个m数组的值推导如下 物品索引i 物品重量 物品价值 j=1 j=2 j=3 j=4 j=5 j=6 j=7 j=8 j=9 j=10 1 2 6 0 6 6 6 6 6 6 6 6 6 2 2 3 0 6 6 9 9 9 9 9 9 9 3 6 5 0 6 6 9 9 9 9 11 11 14 4 5 4 0 6 6 9 9 9 10 11 13 14 5 4 6 0 6 6 9 9 12 12 15 15 15 可以得出可放置物品的最大价值即为15，那怎么推算出到底放置了哪几个物品呢？ 初始i为N，j为背包容量C，如果m[i][j]==m[i-1][j]则没有放置了物品i，否则放置了物品i。 如果没有放置物品i，则令i为i-1往下递推；如果放置了物品i，则令i=i-1,j=j-weight[i]往下递推（参考上面m[i][j]的公式）直到i为1退出循环 对应第一个物品，若m[1][j] == 0则没有放置物品1，否则放置了物品1 整体代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static const int N = 5;static const int C = 10;void package_01()&#123; int m[N + 1][C + 1] = &#123;0&#125;; int weight[N + 1] = &#123;0, 2, 2, 6, 5, 4&#125;; int value[N + 1] = &#123;0, 6, 3, 5, 4, 6&#125;; //放置1..N个物品(注意，因为存在第0行，所以放置第1个物品的过程可以合并到下面) for(int i = 1; i &lt;= N; ++i) &#123; //在背包容量j为1..C时，放置第i个物品 for(int j = 1; j &lt;= C; ++j) &#123; //不放置物品i时的价值 int not_put_i = m[i - 1][j]; if(j &lt; weight[i]) //背包容量j小于物品i的重量 m[i][j] = not_put_i; else &#123; //放置物品i时的价值 int put_i = m[i - 1][j - weight[i]] + value[i]; //两者取大者 m[i][j] = put_i &gt;= not_put_i ? put_i : not_put_i; &#125; &#125; &#125; printf(\"middle arr is:\\n\"); for(int i = 1; i &lt;= N; ++i) &#123; for(int j = 1; j &lt;= C; ++j) printf(\"%2d \", m[i][j]); printf(\"\\n\"); &#125; printf(\"max sum value: %d\\n\", m[N][C]); int x[N+1] = &#123;0&#125;; //注意这里物品1也不需要单独写，因为第0行全为0 for(int i = N, j = C; i &gt;= 1; --i) &#123; if(m[i][j] == m[i - 1][j]) x[i] = 0; //没有放置物品i else &#123; x[i] = 1; //放置了物品i j -= weight[i]; &#125; &#125; printf(\"put order is: \"); for(int i = 1; i &lt;= N; ++i) printf(\"%d \", x[i]); printf(\"\\n\");&#125; 输出如下12345678middle arr is: 0 6 6 6 6 6 6 6 6 6 0 6 6 9 9 9 9 9 9 9 0 6 6 9 9 9 9 11 11 14 0 6 6 9 9 9 10 11 13 14 0 6 6 9 9 12 12 15 15 15max sum value: 15put order is: 1 1 0 0 1 优化参考浅谈DP问题一上面的m数组是比较大的，如果只需要求出最大的价值，而不需要反推具体放置了哪些，则可优化为如下12345678910void package_01_only_max()&#123; int weight[N + 1] = &#123;0, 2, 2, 6, 5, 4&#125;; int value[N + 1] = &#123;0, 6, 3, 5, 4, 6&#125;; int m[C + 1] = &#123;0&#125;; for(int i = 1; i &lt;= N; ++i) for(int j = C; j &gt;= weight[i]; --j) m[j] = std::max(m[j], m[j - weight[i]] +value[i]); printf(\"max:%d\\n\", m[C]);&#125; 这个优化有一点点难理解，特别是为什么j是从C到weight[i]，来看中间数组m的打印12345i = 1 : 0 6 6 6 6 6 6 6 6 6i = 2 : 0 6 6 9 9 9 9 9 9 9i = 3 : 0 6 6 9 9 9 9 11 11 14i = 4 : 0 6 6 9 9 9 10 11 13 14i = 5 : 0 6 6 9 9 12 12 15 15 15 可以看到和非优化版是完全一致的，那是怎么得出来的呢，来看以下过程 i=1时，首先计算m[C]，初始m数组全为0，则m[C-weight[1]]+v[1]较大，为6；同理可得其他m值 i=2时，还是先计算m[C]值，这时原本的m[C]值可以理解为m[i-1][C]，m[C-weight[i]]可以理解为m[i-1][C-weight[i]]，即为上一轮计算遗留下来的值 设想如果j是从weight[i]到C，会发生什么？这就引出了下面的完全背包问题 完全背包问题与上面01背包问题的区别在于：每种物品均有无数多个 优化版本的参考完全背包问题实例,完全背包问题,完全背包问题讲解（dp）12345for(int i = 1; i &lt;= N; ++i)&#123; for(int j = weight[i]; j &lt;= C; ++j) m[j] = std::max(m[j], m[j - weight[i]] +value[i]);&#125; 可以看到，相比于01背包问题，仅仅内存循环的j变成了weight[i]到C。真的很神奇。","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"经典算法系列（三）","date":"2018-03-04T01:23:51.000Z","path":"2018/03/04/经典算法系列（三）/","text":"背包问题参考常见背包问题合集 蒙地卡罗法求PI1234567891011121314double calcPI()&#123; int sum = 0; double x, y; srand(time(NULL)); for(int i = 0; i &lt; N; ++i) &#123; x = (double)rand() / RAND_MAX; y = (double)rand() / RAND_MAX; if(x * x + y * y &lt; 1) sum++; &#125; return (double)sum / N * 4;&#125; 主要是利用概率的思想 Eratosthenes筛选求质数基本的思想流程如下（假设要求21以内的质数）：12345678初始时2 3 4 5 6 7 8 9 11 12 13 14 15 16 17 18 19 20 21筛选因子为2，即将所有2的倍数筛去(除了2以外)2 3 5 7 9 11 13 15 17 19 21筛选因子为3，将所有3的倍数筛去2 3 5 7 11 13 17 19...按此过程，直到筛选因子i*i &gt; N结束 代码如下12345678910111213141516171819202122232425262728293031static const int N = 1000;void printPrime()&#123; //if primeArr[i]==true, then i is prime bool primeArr[N + 1]; for(int i = 2; i &lt;= N; ++i) primeArr[i] = true; for(int i = 2; i * i &lt;= N; ++i) &#123; while(primeArr[i] != true) i++; for(int j = i * 2; j &lt;= N; ++j) if(j % i == 0) primeArr[j] = false; &#125; //output int count = 0; for(int i = 2; i &lt;= N; ++i) &#123; if(primeArr[i] == true) &#123; printf(\"%4d \", i); count++; if(count % 10 == 0) printf(\"\\n\"); &#125; &#125; printf(\"\\n\");&#125; 大数运算参考：大数运算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;static const int N = 4;static const int MAX_PER_WORD = 9999;void add(int a[N], int b[N], int c[N])&#123; int carry = 0; for(int i = N - 1; i &gt;= 0; --i) &#123; c[i] = a[i] + b[i] + carry; if(c[i] &gt;= MAX_PER_WORD + 1) &#123; c[i] -= MAX_PER_WORD + 1; carry = 1; &#125; else carry = 0; &#125;&#125;void sub(int a[N], int b[N], int c[N])&#123; int borrow = 0; for(int i = N - 1; i &gt;= 0; --i) &#123; c[i] = a[i] - b[i] - borrow; if(c[i] &lt; 0) &#123; c[i] += MAX_PER_WORD + 1; borrow = 1; &#125; else borrow = 0; &#125;&#125;//这里有点遗憾，b乘数还不能做到是大数void mul(int a[N], int b, int c[N])&#123; int temp = 0, carry = 0; for(int i = N - 1; i &gt;= 0; --i) &#123; temp = a[i] * b + carry; c[i] = temp % (MAX_PER_WORD + 1); carry = temp / (MAX_PER_WORD + 1); &#125;&#125;void div(int a[N], int b, int c[N])&#123; int temp = 0, remain = 0; for(int i = 0; i &lt; N; ++i) &#123; temp = a[i] + remain; c[i] = temp / b; remain = (temp % b) * (MAX_PER_WORD + 1); &#125;&#125;void print(int c[N])&#123; for(int i = 0; i &lt; N; ++i) printf(\"%04d\", c[i]); printf(\"\\n\");&#125;int main()&#123; int a[N] = &#123;1125, 106, 1124, 7732&#125;; int b[N] = &#123;457, 1932, 9702, 25&#125;; int c[N] = &#123;0&#125;; add(a, b, c); print(c); sub(a, b, c); print(c); mul(a, 3, c); print(c); div(a, 3, c); print(c); return 0;&#125; 需要注意的是并未考虑数据溢出，正负号等情况，只是一个简单的例子。 因式分解把一个整数分解成多个整数积的形式，比如28分解成2 2 7这里额外要求分解成质数相乘的形式 解法如下：1234567891011121314void factoring(int n)&#123; for(int i = 2; i * i &lt;= n;) &#123; if(n % i == 0) &#123; n /= i; printf(\"%d * \", i); &#125; else ++i; &#125; printf(\"%d\\n\", n);&#125; 完美数如果一个数的真因数和等于n，则称之为完美数（Perfect Number），例如6 = 1 + 2 + 328 = 1 + 2 + 4 + 7 + 14496 = 1 + 2 + 4 + 8 + 16 + 31 + 62 + 124 + 248 要判断一个数是不是完美数，最笨的办法当然是[1,n)循环求出真因数的和123456789101112bool perfectNum(int n)&#123; int sum = 0; for(int i = 1; i &lt; n; ++i) &#123; if(n % i == 0) sum += i; &#125; if(sum == n) return true; return false;&#125; 但这种办法对于求很大范围内（比如N为10万）内的所有完美数，相当没有效率 求出一定数目的质数表 利用质数表求指定数的因式分解 利用因式分解求所有真因数和，并检查是否为完美数 这里对于第三点是有数学技巧的，我没想到，比如对于数496：其可因式分解为2 2 2 2 31，设真因数和为sum则sum + n = (20 + 21 + 22 + 23 + 24) * (310 + 311) 而当n为完美数时，sum==n，即原式为2 * sum 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;static const int N = 100000;static const int FACTOR_NUM = 100;int calcPrimeTable(int ptable[])&#123; bool prime[N + 1]; for(int i = 2; i &lt;= N; ++i) prime[i] = true; for(int i = 2; i * i &lt;= N; ++i) &#123; if(prime[i] == true) &#123; for(int j = 2 * i; j &lt;= N; ++j) if(j % i == 0) prime[j] = false; &#125; &#125; for(int i = 2, j = 0; i &lt;= N; ++i) if(prime[i]) ptable[j++] = i;&#125;int factor(int n, int *ptable, int *ftable)&#123; int count = 0; for(int i = 0; ptable[i] * ptable[i] &lt;= n;) &#123; if(n % ptable[i] == 0) &#123; ftable[count++] = ptable[i]; n /= ptable[i]; &#125; else ++i; &#125; ftable[count++] = n; return count;&#125;bool isPerfectNum(int n, int *ptable, int *ftable)&#123; int factorCount = factor(n, ptable, ftable); int sum = 1, curFactor, curSum = 1; for(int i = 0; i &lt; factorCount;) &#123; curSum = 1; curFactor = ftable[i]; while(i &lt; factorCount &amp;&amp; curFactor == ftable[i]) &#123; curSum = curSum * ftable[i] + 1; i++; &#125; sum *= curSum; &#125; if(sum / 2 == n) return true; return false;&#125;int main()&#123; int primeTable[N + 1]; //质数表 calcPrimeTable(primeTable); int factorTable[FACTOR_NUM]&#123;0&#125;; for(int i = 2; i &lt;= N; ++i) if(isPerfectNum(i, primeTable, factorTable)) printf(\"%d \", i); return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"C++中优先队列的用法","date":"2018-03-02T13:23:51.000Z","path":"2018/03/02/C++优先队列的用法/","text":"什么是优先队列要理解一个东西，自然要理清楚其原理，知其然也要知其所以然。之前对于优先队列有一个简单的实现，可以参考。 当然，STL中的优先队列要更复杂，功能也要更强大，但基本原理都是一致的。 STL中的priority_queue头文件及命名空间头文件:1#include &lt;queue&gt; 命名空间:1std 定义下面的很多内容参考 cplusplus cppreference完整定义如下12template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue; 哇塞好长，有三个模板参数，看着都头大。不着急，慢慢细分来看 第一个模板参数1class T 这个好理解的，就是类型参数。比如传入int，则表示值为int的优先队列。注意这个参数是必须的。 第二个模板参数1class Container = vector&lt;T&gt; 元素所在的容器类型，Container::value_type必须和T一致。这个当然啦，容器里的元素类型当然要和队列本身元素的类型一致啦。毕竟容器里存放的就是队列里的元素。 这个参数是可选的，那容器本身可以使用哪些元素呢？原文如下 12345678The underlying container may be any of the standard container class templates or some other specifically designed container class. The container shall be accessible through random access iterators and support the following operations:empty()size()front()push_back()pop_back()The standard container classes vector and deque fulfill these requirements. By default, if no container class is specified for a particular priority_queue class instantiation, the standard container vector is used. 挑重点的说就是，可以自己实现容器类型，需要实现balabala一大堆函数。也可以用STL里的vector和deque，默认是使用std::vector 看了上面优先队列的基本实现就知道，为什么数组是其基本容器了。因为数组和“堆”这种数据结构简直是天造地设的一对哈哈。 第三个模板参数1class Compare = less&lt;typename Container::value_type&gt; 一个可比较的类型参数，下面细细说来。 先说”typename Container::value_type”这种奇怪语法的原因参考effective c++第42条也就是一个C++的准则：如果解析器在模板中碰到了一个内嵌依赖名字，它不会认为这是一个type，除非你告诉它。好了，问题来了。既然Container::value_type必须是T，那为什么这里不直接使用“less&lt; T &gt;”呢？我也不知道了，可能是为了什么一致性考虑吧，当问题留着。 默认参数是带模板参数的less对象，这个less又是什么鬼。 less对象参考：less 头文件functional 命名空间std 官方定义“Function object class for less-than inequality comparison”翻译过来就是用来比较“小于性”的函数对象。 怎么理解呢，来看less对象的基本代码实现123456template &lt;class T&gt; struct less &#123; bool operator() (const T&amp; x, const T&amp; y) const &#123;return x&lt;y;&#125; typedef T first_argument_type; typedef T second_argument_type; typedef bool result_type;&#125;; 可以看到less对象重载了”()”调用操作符，并且比较两个对象”&lt;”比较的结果。 显然，这就要求T对象本身要支持”&lt;”操作符啦 基本使用直接使用123std::less&lt;int&gt; lessComp;lessComp(5, 4); //falselessComp(4, 5); //true 作为参数传入sort等函数中，官方例子如下1234567891011121314// less example#include &lt;iostream&gt; // std::cout#include &lt;functional&gt; // std::less#include &lt;algorithm&gt; // std::sort, std::includesint main () &#123; int foo[]=&#123;10,20,5,15,25&#125;; int bar[]=&#123;15,10,20&#125;; std::sort (foo, foo+5, std::less&lt;int&gt;()); // 5 10 15 20 25 std::sort (bar, bar+3, std::less&lt;int&gt;()); // 10 15 20 if (std::includes (foo, foo+5, bar, bar+3, std::less&lt;int&gt;())) std::cout &lt;&lt; \"foo includes bar.\\n\"; return 0;&#125; 好了不多说了，还是继续回到上面的第三个Compare模板参数，来看官方解释1234A binary predicate that takes two elements (of type T) as arguments and returns a bool.The expression comp(a,b), where comp is an object of this type and a and b are elements in the container, shall return true if a is considered to go before b in the strict weak ordering the function defines.The priority_queue uses this function to maintain the elements sorted in a way that preserves heap properties (i.e., that the element popped is the last according to this strict weak ordering).This can be a function pointer or a function object, and defaults to less&lt;T&gt;, which returns the same as applying the less-than operator (a&lt;b). 比较长，一句一句来看 一个二进制对象，有两个参数（T类型），并且返回bool值。这个比较好理解 如果在“严格弱序化”的顺序下，a要在b的前面，那么执行”comp(a,b)”表达式时要返回true，其中comp为该比较对象类型，a和b为容器中的元素类型参考严格弱序化还有一个比较难理解的概念：什么叫a在b的前面(a go before b).参考cppreference中的说明”But because the priority queue outputs largest elements first, the elements that “come before” are actually output last. That is, the front of the queue contains the “last” element according to the weak ordering imposed by Compare.”总结而言就是，如果a在b前面了，那么b先输出，a后输出 优先队列利用该函数来维持元素的有序，从而保持“堆”的性质 该参数可以是一个函数指针或函数对象，默认为less&lt; T&gt; 废话说的太多了，还是来几个实例吧 使用默认值，递减顺序排序输出 1234567891011void descendOrder()&#123; std::priority_queue&lt;int&gt; q; for(int i : &#123;3, 7, 1, 5, 2&#125;) q.push(i); while(!q.empty()) &#123; printf(\"%d \", q.top()); //7 5 3 2 1 q.pop(); &#125;&#125; 使用greater对象，递增顺序排序输出 1234567891011void ascendOrder1()&#123; std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; q; for(int i : &#123;3, 7, 1, 5, 2&#125;) q.push(i); while(!q.empty()) &#123; printf(\"%d \", q.top()); //1 2 3 5 7 q.pop(); &#125;&#125; 利用函数指针，递增顺序排序输出 123456789101112131415161718bool gCmp(int a, int b)&#123; return a &gt; b;&#125;typedef bool (*gCmpPtr)(int, int);void ascendOrder2()&#123; std::priority_queue&lt;int, std::vector&lt;int&gt;, gCmpPtr&gt; q(gCmp); for(int i : &#123;3, 7, 1, 5, 2&#125;) q.push(i); while(!q.empty()) &#123; printf(\"%d \", q.top()); //1 2 3 5 7 q.pop(); &#125;&#125; 利用lambda表达式，递增顺序排序输出和上面类似的，只是使用了C++11的lambda 123456789101112void ascendOrder3()&#123; auto cmp = [](int a, int b) &#123; return a &gt; b; &#125;; std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); for(int i : &#123;3, 7, 1, 5, 2&#125;) q.push(i); while(!q.empty()) &#123; printf(\"%d \", q.top()); //1 2 3 5 7 q.pop(); &#125;&#125; 自定义对象的排序 1234567891011121314151617181920212223242526272829303132333435363738struct CmpObj&#123; int key; explicit CmpObj(int k) : key(k) &#123;&#125;&#125;;bool operator &lt; (const CmpObj &amp;a, const CmpObj &amp;b)&#123; return a.key &lt; b.key;&#125;bool operator &gt; (const CmpObj &amp;a, const CmpObj &amp;b)&#123; return a.key &gt; b.key;&#125;void testObjCmp()&#123; std::priority_queue&lt;CmpObj&gt; descendQ; std::priority_queue&lt;CmpObj, std::vector&lt;CmpObj&gt;, std::greater&lt;CmpObj&gt;&gt; ascendQ; for(const auto &amp;obj : &#123;CmpObj(3), CmpObj(1), CmpObj(2)&#125;) &#123; descendQ.push(obj); ascendQ.push(obj); &#125; while(!descendQ.empty()) &#123; printf(\"%d \", descendQ.top().key); //3 2 1 descendQ.pop(); &#125; printf(\"\\n\"); while(!ascendQ.empty()) &#123; printf(\"%d \", ascendQ.top().key); //1 2 3 ascendQ.pop(); &#125;&#125; 需要对自定义对象重载”&lt;”和”&gt;”操作符，希望逆序输出则重载”&lt;”，希望顺序输出则重载”&gt;” 自定义比较Compare对象这个和上面的不一样，这里相当于是自定义第三个模板Compare参数典型的例子是链表指针的比较12345678910111213141516171819202122232425262728struct Node&#123; int data; Node *next; Node(int d = 0, Node *n = nullptr) : data(d), next(n) &#123;&#125;&#125;;struct NodePtrCmp&#123; //类似于less对象，重载()执行操作符 bool operator()(Node *pa, Node *pb) &#123; return pa-&gt;data &gt; pb-&gt;data; &#125;&#125;;void testListCompare()&#123; //注意这里容器的元素时指针 std::priority_queue&lt;Node *, std::vector&lt;Node *&gt;, NodePtrCmp&gt; q; for(int i : &#123;3, 1, 2&#125;) q.push(new Node(i)); while(!q.empty()) &#123; printf(\"%d \", q.top()-&gt;data); // 1 2 3 q.pop(); &#125;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"合并k个有序链表","date":"2018-03-01T12:23:51.000Z","path":"2018/03/01/合并k个有序链表/","text":"描述合并k个有序的链表，并且假设每个链表的平均长度是n 原题地址：Merge k Sorted Lists 在以前的文章中提到过，但是不完整，这里完整地写出各种算法 各种做法准备工作 单链表的定义、创建、输出等，老生常谈了1234567891011121314151617181920212223242526272829struct Node&#123; int data; Node *next; Node(int d = 0, Node *n = nullptr) : data(d), next(n) &#123;&#125;&#125;;Node *create(const std::vector&lt;int&gt; &amp;vec)&#123; Node head, *p = &amp;head, *q; for(int i : vec) &#123; q = new Node(i); p-&gt;next = q; p = p-&gt;next; &#125; return head.next;&#125;void print(Node *head)&#123; while(head) &#123; printf(\"%d-&gt;\", head-&gt;data); head = head-&gt;next; &#125; printf(\"nullptr\\n\");&#125; 单链表的创建用了vector，也可以不用的，这里为了方便，不过这不是重点;链表的头结点也不作为特殊节点了，直接作为数据节点。 合并两个有序单链表 123456789101112131415161718192021222324Node *merge2List(Node *head1, Node *head2)&#123; Node head, *p = &amp;head; while(head1 &amp;&amp; head2) &#123; if(head1-&gt;data &lt;= head2-&gt;data) &#123; p-&gt;next = head1; head1 = head1-&gt;next; &#125; else &#123; p-&gt;next = head2; head2 = head2-&gt;next; &#125; p = p-&gt;next; &#125; if(head1) p-&gt;next = head1; else if(head2) p-&gt;next = head2; return head.next;&#125; 也好理解，和归并排序有点像。 下面两个合并k个链表的算法都需要用到该方法。 算法一：两两合并123456789Node *mergeKList1(Node *listArr[], int size)&#123; if(size == 0) return nullptr; Node *p = listArr[0]; for(int i = 1; i &lt; size; ++i) p = merge2List(p, listArr[i]); return p;&#125; 这个好理解的，当链表不为空时：L[0]和L[1]合并-&gt;再和L[2]合并-&gt;… 算法二：各种巧妙合并以合并7个链表为例 第一种方法 第一轮，size为7 L[0]和L[1]合并到L[0] L[2]和L[3]合并到L[1] L[4]和L[5]合并到L[2] L[6]不合并，直接赋值到L[3]注意到经过上面的过程之后，需要再合并的链表的长度减半了，即变为了(7+1)/2=4 第二轮，size为4 L[0]和L[1]合并到L[0] L[2]和L[3]合并到L[1] 第三轮，size为2 L[0]和L[1]合并到L[0]结束退出 代码如下1234567891011121314151617Node *mergeKList2(Node *listArr[], int size)&#123; if(size == 0) return nullptr; while(size &gt; 1) &#123; for(int i = 0; i &lt; size; i += 2) &#123; if(i + 1 &lt; size) listArr[i / 2] = merge2List(listArr[i], listArr[i + 1]); else listArr[i / 2] = listArr[i]; &#125; size = (size + 1) / 2; &#125; return listArr[0];&#125; 第二种方法以递增的间隔合并 第一轮，间隔为1 L[0]和L[1]合并到L[0] L[2]和L[3]合并到L[2] L[4]和L[5]合并到L[4] L[6]不动 第二轮，间隔加倍为2 L[0]和L[2]合并到L[0] L[4]和L[6]合并到L[4] 第三轮，间隔加倍为4 L[0]和L[4]合并到L[0] 间隔再加倍超过7时退出 代码如下12345678910111213Node *mergeKList3(Node *listArr[], int size)&#123; if(size == 0) return nullptr; int gap = 1; while(gap &lt; size) &#123; for(int i = 0; i &lt; size - gap; i += 2 * gap) listArr[i] = merge2List(listArr[i], listArr[i + gap]); gap *= 2; &#125; return listArr[0];&#125; 第三种方法以递减的间隔合并（这个有点像希尔排序的思想了） 第一轮，间隔为(7+1)/2=4 L[0]和L[4]合并到L[0] L[1]和L[5]合并到L[1] L[2]和L[6]合并到L[2] L[3]不做修改如此之后，size减半为4，只需要管L[0..3]了 第二轮，间隔为(4+1)/2=2 L[0]和L[2]合并到L[0] L[1]和L[3]合并到L[1]size减半为2，只需要管L[0..1]了 第三轮，间隔为(2+1)/2=1 L[0]和L[1]合并到L[0]结束，返回L[0] 代码如下12345678910111213Node *mergeKList4(Node *listArr[], int size)&#123; if(size == 0) return nullptr; while(size &gt; 1) &#123; int gap = (size + 1) / 2; for(int i = 0; i &lt; size - gap; ++i) listArr[i] = merge2List(listArr[i], listArr[i + gap]); size = gap; &#125; return listArr[0];&#125; 算法三：利用优先队列C++ priority_queue优先队列的用法参考大致的思路如下： 每次都以所有链表的head元素作为比较元素，建立最小堆。即队列的top的head元素是最小的 将top元素初队列，取出head元素（此时为所有链表最小的元素），head指向head-&gt;next 此时如果head为空了，就舍弃；否则再将head入队列 重复上面的步骤，直到队列为size为1。则直接将剩下的元素添加到结果链表尾部即可假设需要合并3-&gt;4-&gt;8, 1-&gt;6-&gt;9，2-&gt;5，则过程如下(上方为队列top)123451-&gt;6-&gt;9 top 2-&gt;5 3-&gt;4-&gt;8 4-&gt;8 52-&gt;5 pop/push 3-&gt;4-&gt;8 5 5 6-&gt;93-&gt;4-&gt;8 ========&gt; 6-&gt;9 ==&gt; 6-&gt;9 ==&gt; 6-&gt;9 ==&gt; 8结果:null 结果:1 结果:1-&gt;2 结果:1-&gt;2-&gt;3 结果:1-&gt;2-&gt;3-&gt;4 1234 6-&gt;9 8 9==&gt; 8 ==&gt; 9 ==&gt; =&gt;结果:1-&gt;2-&gt;3-&gt;4-&gt;5 结果:1-&gt;..-&gt;6 结果:1-&gt;..-&gt;6-&gt;8 结果:1-&gt;..-&gt;6-&gt;8-&gt;9 代码如下123456789101112131415161718192021222324252627282930struct NodePtrCmp&#123; bool operator()(Node *pa, Node *pb) &#123; return pa-&gt;data &gt; pb-&gt;data; &#125;&#125;;Node *mergeKList5(Node *listArr[], int size)&#123; if(size == 0) return nullptr; std::priority_queue&lt;Node *, std::vector&lt;Node *&gt;, NodePtrCmp&gt; q; for(int i = 0; i &lt; size; ++i) q.push(listArr[i]); Node head, *p = &amp;head; while(q.size() &gt; 1) &#123; Node *t = q.top(); q.pop(); p-&gt;next = t; t = t-&gt;next; if(t) q.push(t); p = p-&gt;next; &#125; p-&gt;next = q.top(); return head.next;&#125; 算法四：使用堆数据结构能不能不使用STL里的东西，直接使用堆呢？想了一下，应该也是可以的12345678910111213141516171819202122232425262728293031323334353637383940414243444546//下滤过程，类似于堆排序void percolateDown(Node *listArr[], int index, int size)&#123; Node *temp = listArr[index]; int child; for(; index &lt;= size / 2 - 1; index = child) &#123; child = 2 * index + 1; if(child + 1 &lt; size &amp;&amp; listArr[child + 1]-&gt;data &lt; listArr[child]-&gt;data) child++; if(listArr[child]-&gt;data &lt; temp-&gt;data) listArr[index] = listArr[child]; else break; &#125; listArr[index] = temp;&#125;Node *mergeKList6(Node *listArr[], int size)&#123; //build heap for(int i = size / 2 - 1; i &gt;= 0; --i) percolateDown(listArr, i, size); //从堆中取元素的过程 Node head, *p = &amp;head; //i表示当前堆的大小 for(int i = size; i &gt; 0;) &#123; p-&gt;next = listArr[0]; listArr[0] = listArr[0]-&gt;next; if(listArr[0] == nullptr) &#123; //当前top元素的链表空了，则将末元素赋值到首元素 listArr[0] = listArr[i - 1]; //堆大小减1 i--; &#125; //调整堆 percolateDown(listArr, 0, i); p = p-&gt;next; &#125; return head.next;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"经典算法系列（二）","date":"2018-02-25T01:23:51.000Z","path":"2018/02/25/经典算法系列（二）/","text":"骑士走棋盘问题骑士游历（Knight tour）,即骑士（走“日”字，类似于马）在8x8的棋盘上，从任意位置出发，如何走完所有的位置骑士的走法如下：一种可能的解法如下： 递归+回溯解法依然是类似于之前8皇后的解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#define N 8int arr[N][N] = &#123;0&#125;;int dirX[] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;;int dirY[] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;bool check(int x, int y)&#123; if(x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= N || arr[x][y] != 0) return false; return true;&#125;void printSolution()&#123; static int count = 0; printf(\"solution %d:\\n\", ++count); for(int i = 0; i &lt; N; ++i) &#123; for(int j = 0; j &lt; N; ++j) printf(\"%3d\", arr[i][j]); printf(\"\\n\"); &#125;&#125;void backtrack(int curX, int curY, int depth)&#123; arr[curX][curY] = depth; if(depth == N * N) &#123; printSolution(); return; &#125; for(int i = 0; i &lt; 8; ++i) &#123; int nextX = curX + dirX[i], nextY = curY + dirY[i]; if(check(nextX, nextY)) &#123; backtrack(nextX, nextY, depth + 1); arr[nextX][nextY] = 0; &#125; &#125;&#125;void knightTour(int srcX, int srcY)&#123; backtrack(srcX, srcY, 1);&#125;int main()&#123; knightTour(0, 0); return 0;&#125; 一个可能的输出如下12345678 1 60 39 34 31 18 9 6438 35 32 61 10 63 30 1759 2 37 40 33 28 19 836 49 42 27 62 11 16 2943 58 3 50 41 24 7 2048 51 46 55 26 21 12 1557 44 53 4 23 14 25 652 47 56 45 54 5 22 13 参考The Knight’s tour problem 这种解法对于回溯问题比较通用，但对于该问题相当没有效率。初始点为(0,0)时可以很快找出很多解，但是初始点设为(0,4)时，速度就很慢了 Warnsdorff最优算法优化规则如下 We can start from any initial position of the knight on the board. We always move to an adjacent, unvisited square with minimal degree (minimum number of unvisited adjacent). 翻译一下就是 可以从棋盘的任意位置出发 总是移动到相邻未访问的，“度”最小的格子。这里“度”指的是某一个相邻未访问的格子个数 虽然不能参透其精髓，但直观感受是：如果一个格子的相邻格子很少（比如只有一个了），那么这个格子比较“难”访问到了（只剩下一条路），所以要优先访问掉。相反，比较容易访问到的节点，可以放到后面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdio.h&gt;#define N 8int arr[N][N] = &#123;0&#125;;int dirX[] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;;int dirY[] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;void printSolution()&#123; static int count = 0; printf(\"solution %d:\\n\", ++count); for(int i = 0; i &lt; N; ++i) &#123; for(int j = 0; j &lt; N; ++j) printf(\"%3d\", arr[i][j]); printf(\"\\n\"); &#125;&#125;bool check(int x, int y)&#123; if(x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= N || arr[x][y] != 0) return false; return true;&#125;int degree(int x, int y)&#123; int d = 0; for(int i = 0; i &lt; 8; ++i) &#123; int newX = x + dirX[i], newY = y + dirY[i]; if(check(newX, newY)) ++d; &#125; return d;&#125;void minDegreeAdjacent(int &amp;x, int &amp;y)&#123; int curX = x, curY = y; int minDegree = N + 1; for(int i = 0; i &lt; 8; ++i) &#123; int newX = x + dirX[i], newY = y + dirY[i]; if(!check(newX, newY)) continue; int d = degree(newX, newY); if(d &lt; minDegree) &#123; minDegree = d; curX = newX; curY = newY; &#125; &#125; x = curX; y = curY;&#125;void backtrack(int curX, int curY, int depth)&#123; arr[curX][curY] = depth; if(depth == N * N) &#123; printSolution(); return; &#125; int newX = curX, newY = curY; minDegreeAdjacent(newX, newY); printf(\"newX:%d, newY:%d\\n\", newX, newY); if(newX != curX &amp;&amp; newY != curY) &#123; backtrack(newX, newY, depth + 1); arr[newX][newY] = 0; &#125;&#125;void knightTour(int srcX, int srcY)&#123; backtrack(srcX, srcY, 1);&#125;int main()&#123; knightTour(0, 4);&#125; 2018-3-28更新，warnsdorff算法完全可以不用递归123456789101112131415161718192021222324252627282930313233343536void knight_tour2()&#123; int depth = 1, row = 0, col = 0; while(true) &#123; chessborad[row][col] = depth; if(depth == 64) &#123; print(); break; &#125; int minDegree = 8, minRow = -1, minCol = -1; for(int i = 0; i &lt; 8; ++i) &#123; int newRow = row + direction[i][0], newCol = col + direction[i][1]; if(!check(newRow, newCol)) continue; int curDegree = degree(newRow, newCol); if(curDegree &lt; minDegree) &#123; minDegree = curDegree; minRow = newRow; minCol = newCol; &#125; &#125; if(!check(minRow, minCol)) &#123; printf(\"not found\\n\"); break; &#125; depth++; row = minRow; col = minCol; &#125;&#125; 相应输出如下1234567847 14 61 32 1 16 19 3464 31 46 15 60 33 2 1713 48 57 62 45 18 35 2030 63 42 53 56 59 40 349 12 55 58 41 44 21 3626 29 52 43 54 39 4 711 50 27 24 9 6 37 2228 25 10 51 38 23 8 5 有一点没想明白，之前的回溯法相当于遍历所有情况，如果结果存在肯定能找到。现在的方法总是找最优的情况。会不会导致找不到结果了？？ 参考Warnsdorff’s algorithm for Knight’s tour problemAlgorithm: Set P to be a random initial position on the board Mark the board at P with the move number “1” Do following for each move number from 2 to the number of squares on the board: – let S be the set of positions accessible from P. – Set P to be the position in S with minimum accessibility – Mark the board at P with the current move numberReturn the marked board — each square will be marked with the move number on which it is visited. 翻译过来其实就很简单两句话 设置任意点为起始点P 查找P的相邻点集S中的“度”最小的点，并设为P 继续2 对于该算法，用turtle实现了动画，效果如下 红色的数字表示下一步可以走的格子的度 黄色的线表示行走路径 蓝色的格子表示已走的格子 效果如下 其中骑士的图片为 完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#!/usr/bin/env python3import turtlefrom turtle import *from time import sleepN = 8arr = []dirX = [2, 1, -1, -2, -2, -1, 1, 2]dirY = [1, 2, 2, 1, -1, -2, -2, -1]SPACE = 50points_so_far = []def draw_line(t, x, y): t.penup() t.setx(x) t.sety(y) t.pendown() t.forward(N * SPACE)def draw_grid(): gridTurtle = Turtle() gridTurtle.ht() x = - N / 2 * SPACE y = N / 2 * SPACE #h lines for _ in range(N + 1): draw_line(gridTurtle, x, y) y -= SPACE x = - N / 2 * SPACE y = N / 2 * SPACE #v lines gridTurtle.right(90) for _ in range(N + 1): draw_line(gridTurtle, x, y) x += SPACEdef fill(t, r, c): t.penup() t.setx((c - N / 2) * SPACE) t.sety((N / 2 - r) * SPACE) t.pendown() t.begin_fill() for i in range(4): t.forward(SPACE) t.right(90) t.end_fill()def draw_chessboard(): chessTurtle = Turtle() chessTurtle.ht() chessTurtle.fillcolor('black') for i in range(N): c = 1 if i % 2 != 0: c = 0 for j in range(c, N, 2): fill(chessTurtle, i, j)def set_default_turtle(r, c): points_so_far.append((r, c)) screen = Screen() register_shape(\"turtle.gif\") turtle.shape(\"turtle.gif\") turtle.pensize(3) turtle.pencolor(\"yellow\") turtle.penup() turtle.setx(x_by_col(c)) turtle.sety(y_by_row(r)) turtle.pendown()def x_by_col(c): return (c + 1 / 2 - N / 2) * SPACEdef y_by_row(r): return ((N - 1) / 2 - r) * SPACEdef init(r, c): for i in range(N): arr.append([0 for _ in range(N)]) tracer(False) draw_grid() draw_chessboard() set_default_turtle(r, c) tracer(True)def moveto(r, c): size = len(points_so_far) if size &gt; 1: #这里将已经存在的点重画，因为之前的fill操作可能将线覆盖了 tracer(False) turtle.clear() fromr, fromc = points_so_far[0] turtle.penup() turtle.goto(x_by_col(fromc), y_by_row(fromr)) turtle.pendown() for i in range(1, size): tor, toc = points_so_far[i] turtle.goto(x_by_col(toc), y_by_row(tor)) tracer(True) x, y = x_by_col(c), y_by_row(r) turtle.goto(x, y) points_so_far.append((r, c)) sleep(1)def draw_degree(r, c, d): degreeTurtle.penup() x, y = x_by_col(c), y_by_row(r) degreeTurtle.goto(x, y - SPACE / 4) degreeTurtle.pendown degreeTurtle.write(str(d), align='center', font=('Microsoft YaHei', 15)) sleep(0.5)def check(r, c): return 0 &lt;= r &lt; N and 0 &lt;= c &lt; N and arr[r][c] == 0def degree(r, c): d = 0 for i in range(len(dirX)): newr, newc = r + dirX[i], c + dirY[i] if check(newr, newc): d += 1 return ddef minDegreeAdjacent(r, c): mindegree = N + 1 minr, minc = r, c for i in range(len(dirX)): newr, newc = r + dirX[i], c + dirY[i] if not check(newr, newc): continue d = degree(newr, newc) draw_degree(newr, newc, d) if d &lt; mindegree: mindegree = d minr, minc = newr, newc return minr, mincfillTurtle = Turtle()fillTurtle.fillcolor('#9BBEFF')fillTurtle.ht()degreeTurtle = Turtle()degreeTurtle.pencolor(\"red\")degreeTurtle.ht()def warnsdorff(r, c, depth): arr[r][c] = depth tracer(False) fill(fillTurtle, r, c) tracer(True) if depth == N * N: for l in arr: print(l) return degreeTurtle.clear() minr, minc = minDegreeAdjacent(r, c) if (minr, minc) != (r, c): moveto(minr, minc) warnsdorff(minr, minc, depth + 1)def main(): startr, startc = 0, 4 init(startr, startc) warnsdorff(startr, startc, 1) mainloop()if __name__ == '__main__': main() 生命游戏题目和解法参考Game of Life原文解释超赞了，不班门弄斧了，用C++实现一下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;#include &lt;time.h&gt;#define M 10#define N 10int board[M][N] = &#123;0&#125;;void initBoard()&#123; srand(time(NULL)); for(int i = 0; i &lt; M; ++i) &#123; for(int j = 0; j &lt; N; ++j) board[i][j] = rand() % 2; &#125;&#125;void print()&#123; for(int i = 0; i &lt; M; ++i) &#123; for(int j = 0; j &lt; N; ++j) printf(\"%2d\", board[i][j]); printf(\"\\n\"); &#125;&#125;int liveNeighbors(int i, int j)&#123; int lives = 0; for(int x = std::max(i-1, 0); x &lt;= std::min(i+1, M-1); x++) for(int y = std::max(j-1, 0); y &lt;= std::min(j+1, N-1); y++) lives += board[x][y] &amp; 1; lives -= board[i][j] &amp; 1; return lives;&#125;void gameLife()&#123; for(int i = 0; i &lt; M; ++i) &#123; for(int j = 0; j &lt; N; ++j) &#123; int lives = liveNeighbors(i, j); if(board[i][j] == 1 &amp;&amp; (lives == 2 || lives == 3)) board[i][j] = 3; //01 -&gt; 11 else if(board[i][j] == 0 &amp;&amp; lives == 3) board[i][j] = 2; //00 -&gt; 10 &#125; &#125; for(int i = 0; i &lt; M; ++i) for(int j = 0; j &lt; N; ++j) board[i][j] &gt;&gt;= 1;&#125;int main()&#123; initBoard(); printf(\"init state:\\n\"); print(); gameLife(); printf(\"next state:\\n\"); print(); return 0;&#125; 原题算结束了，突然想用turtle来表示一下游戏中的实时状态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/env pythonfrom turtle import *from random import randrangefrom time import sleepM = 10N = 10radius = 10gap = 8board = []cells = []def init(): y = (radius + gap)*(M / 2) tracer(False) for i in range(M): board.append([randrange(0,2) for _ in range(N)]) rows = [] x = - (radius + gap)*(N / 2) for j in range(M): t = Turtle() t.ht() t.pensize(2) t.penup() t.setx(x) t.sety(y - radius) t.pendown() rows.append(t) x += (2 * radius + gap) cells.append(rows) y -= (2 * radius + gap) tracer(True)def show(): tracer(False) for i in range(M): for j in range(N): b = board[i][j] t = cells[i][j] t.clear() if b == 0: t.pencolor('red') else: t.pencolor('green') t.circle(radius) tracer(True)def gamelife(): for i in range(M): for j in range(N): lives = liveneighbors(i, j) if board[i][j] == 1 and (lives == 2 or lives == 3): board[i][j] = 3 elif board[i][j] == 0 and lives == 3: board[i][j] = 2 for i in range(M): for j in range(N): board[i][j] &gt;&gt;= 1 show()def liveneighbors(i, j): lives = 0 for x in range(max(i - 1, 0), min(i + 2, M)): for y in range(max(j - 1, 0), min(j + 2, N)): lives += board[x][y] &amp; 1 lives -= board[i][j] &amp; 1 return livesdef main(): init() show() for i in range(10): gamelife() sleep(2) mainloop()if __name__ == '__main__': main() 结果大概就是这么个样子 字符串匹配Boyer-Moore算法参考字符串匹配的Boyer-Moore算法fstrpos-example 其实就是在字符串中查找子串是否存在，Boyer-Moore算法的精妙在于，他能将匹配的过程加快，而不是每次索引加一。多余的说明就不说了，看原文把，很详细了。下面是我的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;string.h&gt;//查找字符在字符串中的位置，找不到返回-1int findPos(const char *src, char ch)&#123; int len = strlen(src); for(int i = 0; i &lt; len; ++i) if(ch == src[i]) return i; return -1;&#125;//查找[begin..end]对应的后缀，在原字符串头部的索引，找不到返回-1//举几各例子//1、src=\"ABCDAB\", begin=4,end=5(后缀为AB)。则返回1，即B的位置//2、src=\"ABCDEF\", begin=4,end=5(后缀为EF)。返回-1//3、src=\"BABCDAB\",begin=4,end=6(后缀为DAB)。返回0，即第一个B的位置// 我是这么理解的，DAB在头部找不到-&gt;AB在头部找不到-&gt;B在头部找到int findSuffixPos(const char *src, int begin, int end)&#123; int suffixLen = end - begin + 1; //后缀字符串长度不断缩小，直至0（0即为找不到的情况） while(suffixLen &gt;= 0) &#123; int i; for(i = suffixLen - 1; i &gt;= 0; --i) if(src[i] != src[end + i - (suffixLen - 1)]) break; if(i == -1) break; suffixLen--; &#125; return suffixLen - 1;&#125;bool match(const char *src, const char *sub)&#123; int srcLen = strlen(src), subLen = strlen(sub); if(srcLen &lt; subLen) return false; int curIdx = subLen - 1; while(curIdx &lt; srcLen) &#123; int i; for(i = 0; i &lt; subLen; ++i) if(sub[subLen - 1 - i] != src[curIdx - i]) break; else if(i == subLen - 1) return true; //exact match int goodShift = 0, badShift = 0; int badIndex = subLen - 1 - i; char badChar = src[curIdx - i]; int badPos = findPos(sub, badChar); badShift = badIndex - badPos; if(i != 0) &#123; int suffixPos = findSuffixPos(sub, subLen - 1 - i, subLen - 1); goodShift = subLen - 1 - suffixPos; &#125; int shift = badShift &gt;= goodShift ? badShift : goodShift; curIdx += shift; &#125; return false;&#125;int main()&#123; printf(\"%d\\n\", match(\"HERE IS A SIMPLE EXAMPLE\", \"EXAMPLE\")); return 0;&#125; 双色、三色汉诺塔问题双色汉诺塔先看解法如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void move(int n, char from, char to)&#123; const char *color = n % 2 != 0 ? \"yellow\" : \"blue\"; printf(\"%d %6s : %c-&gt;%c\\n\", n, color, from, to);&#125;void hanoi(int depth, char from, char by, char to)&#123; if(depth &lt;= 0) return; else if(depth == 1) move(1, from, to); else &#123; hanoi(depth - 1, from, to, by); move(depth, from, to); hanoi(depth - 1, by, from, to); &#125;&#125;void hanoi2color(int depth)&#123; assert(depth % 2 == 0); char from = 'A', by = 'B', to = 'C'; if(depth &lt;= 0) return; else if(depth == 2) &#123; move(1, from, by); move(2, from, to); return; &#125; else &#123; hanoi(depth - 1, from, to, by); move(depth, from, to); hanoi(depth - 2, by, to, from); &#125; hanoi2color(depth - 2);&#125;int main()&#123; hanoi2color(4); return 0;&#125; 函数hanoi为递归函数，负责将depth个盘子从from经过by到to柱子。该函数实现与单色汉诺塔完全一致。 其中hanoi2color为驱动程序，以4个盘子（黄1蓝2黄3蓝4）为例 当n为2时，直接将盘1（黄）移动到’B’柱子，盘2（蓝）移动到’C’柱子即可。 当n为4时 借助hanoi函数将上方三个盘子(黄1蓝2黄3)移动到柱’B’ 将第4个盘子(蓝4)移动到柱’C’ 将柱’B’上方的两个盘子(黄1蓝2)移动到柱’A’，此时柱’A’(黄1蓝2)，柱’B’(黄3)，柱’C’(蓝4) 接下来只要移动柱’A’上的(黄1蓝2)即可，即为n=2的情况，递归执行 三色汉诺塔123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;assert.h&gt;void move(int n, char from, char to)&#123; const char *color = \"\"; switch(n % 3) &#123; case 0: color = \"blue\"; break; case 1: color = \"red\"; break; case 2: color = \"yellow\"; default: break; &#125; printf(\"%d %6s : %c-&gt;%c\\n\", n, color, from, to);&#125;void hanoi(int depth, char from, char by, char to)&#123; if(depth &lt;= 0) return; else if(depth == 1) move(1, from, to); else &#123; hanoi(depth - 1, from, to, by); move(depth, from, to); hanoi(depth - 1, by, from, to); &#125;&#125;void hanoi3color(int depth)&#123; assert(depth % 3 == 0); char from = 'A', by = 'B', to = 'C'; if(depth &lt;= 0) return; else if(depth == 3) &#123; move(1, from, to); move(2, from, by); move(1, to, by); move(3, from, to); move(1, by, from); return; &#125; else &#123; hanoi(depth - 1, from, to, by); move(depth, from, to); hanoi(depth - 2, by, to, from); &#125; hanoi3color(depth - 3);&#125;int main()&#123; hanoi3color(6); return 0;&#125; 算法逻辑和双色是一致的。这种算法整体上还是比较清晰的，但是感觉这种方法并没有很好地利用(红1黄2蓝3)的大小一致的特性。也就是说其实该算法也可以用来解以下问题：半径分别为(1..6)的6个大小不同的盘子在柱A上，需要的移动结果：柱A(1,4),柱B(2,5),柱C(3,6)。 但是因为原题中（红1黄2蓝3）的大小是一致的，位置可以交错的，所以感觉有点“大材小用”","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"关于C++11for循环的问题","date":"2018-02-22T03:23:51.000Z","path":"2018/02/22/关于C++11for循环的问题/","text":"C++11 for循环新增功能参考：基于范围的 for 循环 然而在使用过程中发现问题代码如下1234567#include &lt;stdio.h&gt;int main()&#123; for(int i : &#123;1, 3, 5&#125;) printf(\"%d\\n\", i); return 0;&#125; 编译报错1234'&lt;begin&gt;': identifier not founderror C3312: no callable 'begin' function found for type 'initializer list'error C3861: '&lt;end&gt;': identifier not founderror C3312: no callable 'end' function found for type 'initializer list' 在头部加上#include vector问题解决 问题原因根据出错信息，知道”for a : b”这种语法是依赖于’initializer list’的，查看vector源码得知，vector中包含initializer_list类的大致路径如下：vector -&gt; xmemory -&gt; xmemory0 -&gt; limits -&gt; xstddef -&gt; initializer_list不排除其他引用路径，不过这不是重点 所以，其实不一定要包含vector类，而包含stack,queue等类都是可以的，甚至直接包含initializer_list类就行","tags":[{"name":"C++11","slug":"C-11","permalink":"http://yoursite.com/tags/C-11/"}]},{"title":"经典算法系列（一）","date":"2018-02-22T00:23:51.000Z","path":"2018/02/22/经典算法系列（一）/","text":"汉诺塔问题 描述有三根柱子依次排列，第一根柱子上有n个从小到大盘子，需要将这n个盘子移动到第三个根柱子上，要求 每次只能移动一个盘子 大盘子不能放到小盘子之上 解法一：递归解法 假设需要将[1]一个盘子，从柱A借助柱B移动到柱C。则直接将[1]从A移动到C即可 假设需要将[1,2]两个盘子，从柱A借助柱B移动到柱C。则先将[1]从A-&gt;B，再将[2]从A-&gt;C，再将[1]从B-&gt;C 假设需要将[1,2,3]三个盘子，从柱A借助柱B移动到柱C。先想办法把[1,2]从A-&gt;B(借助C)，再将[3]从A-&gt;C，再将[1,2]从B-&gt;C(借助A) 上面推理的过程，即为递归的逆过程。实现代码如下123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;void move(int n, char from, char to)&#123; printf(\"[%d]: %c-&gt;%c\\n\", n, from, to); counter++;&#125;void hanoi_recursive(int depth, char from, char by, char to)&#123; if(depth == 1) &#123; move(1, from, to); &#125; else &#123; hanoi_recursive(depth - 1, from, to, by); move(depth, from, to); hanoi_recursive(depth - 1, by, from, to); &#125;&#125;int main()&#123; hanoi(3, 'A', 'B', 'C'); return 0;&#125; 输出如下1234567[1]: A-&gt;C[2]: A-&gt;B[1]: C-&gt;B &#123;1,2,3&#125;行的作用为将[1,2]从A-&gt;B(借助C)[3]: A-&gt;C 将[3]从A-&gt;C[1]: B-&gt;A[2]: B-&gt;C[1]: A-&gt;C &#123;5,6,7&#125;行的作用为将[1,2]从B-&gt;C(借助A) 解法二：非递归解法递归解法很清晰，也好实现，规律找到，代码容易写出。如果不是不能使用递归，就不要自寻烦恼了。对于很多问题，如果不能使用递归，就需要利用栈等特殊的数据结构（二叉树遍历也是） 先看实现代码12345678910111213141516171819202122232425262728293031323334//struct的5个值分别代表://depth:当前层数，为1则不需要再迭代//n:当前移动盘子编号//from:起始柱子，by：经过柱子，to：目的柱子struct hanoiData&#123; int depth; int n; char from; char by; char to;&#125;;void hanoi_stack(int depth, char from, char by, char to)&#123; stack&lt;hanoiData&gt; stk; stk.push(&#123;depth, depth, from, by, to&#125;); while(!stk.empty()) &#123; hanoiData d = stk.top(); stk.pop(); if(d.depth == 1) move(d.n, d.from, d.to); else &#123; stk.push(&#123;d.depth - 1, d.depth - 1, d.by, d.from, d.to&#125;); stk.push(&#123;1, d.depth, d.from, d.by, d.to&#125;); stk.push(&#123;d.depth - 1, d.depth - 1, d.from, d.to, d.by&#125;); &#125; &#125;&#125; 我的思路还是将整个过程且切分为3个部分 将前n - 1个盘子A-&gt;B 将盘子n从A-&gt;C 将n - 1个盘子从B-&gt;C因为栈后进先出的关系，索引将操作3,2,1依次入栈这样执行顺序就是1,2,3了 将操作1出栈执行时，发现深度为n-1，重复执行上面的步骤 和网上这位兄台想到一块去了，事先真没参考 递归非递归性能比较很遗憾，我的这种非递归解法和递归解法性能差了不止一个数量级12hanoi recursive, result:1048575 elapse time :7011 microsecondshanoi stack, result:1048575 elapse time :917490 microseconds 斐波那契数列 描述fn = fn-1 + fn-2 if n &gt; 1fn = n if n = 0, 1求fn 解法参考递归的性能 杨辉三角 描述按如下规律打印 12345678 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 11 7 21 35 35 21 7 1 解法主要是打印有点麻烦，规律还是好找的 123456789101112131415161718192021222324252627#define N 13int arr[N][N] = &#123;0&#125;;void yanghui()&#123; for(int i = 0; i &lt; N; ++i) &#123; arr[i][0] = arr[i][i] = 1; for(int j = 1; j &lt; i; ++j) &#123; arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j]; &#125; &#125; for(int i = 0; i &lt; N; ++i) &#123; for(int k = 0; k &lt; (N - i)*3; k++) printf(\" \"); for(int j = 0; j &lt; N; ++j) &#123; if(arr[i][j] == 0) break; printf(\"%6d\", arr[i][j]); &#125; printf(\"\\n\"); &#125;&#125; 三色旗问题 描述假设有一条绳子，上面有红、白、蓝三种颜色的旗子，起初绳子上的旗子颜色并没有顺序（旗子个数也未知），您希望将之分类，并排列为蓝、白、红的顺序，要如何移动次数才会最少，注意您只能在绳子上进行这个动作，而且一次只能调换两个旗子。 解法参考三色旗问题Dutch national flag problemDutch National Flag很迷惑人的错误解法 12345678910111213141516171819202122232425262728void swap(char color[], int indexA, int indexB)&#123; if(indexA == indexB) &#123; printf(\"index is equal\\n\"); return; &#125; char temp = color[indexA]; color[indexA] = color[indexB]; color[indexB] = temp;&#125;void threeColor_error(char color[], int size)&#123; int bflag = 0, wflag = 0, rflag = size - 1; while(wflag &lt;= rflag) &#123; if(color[wflag] == 'b') swap(color, bflag++, wflag++); else if(color[wflag] == 'r') swap(color, wflag++, rflag--); else wflag++; &#125;&#125;char color[] = &#123;'r','w','b','w','w','b', 'r','b','r','w'&#125;;int size = sizeof(color);threeColor_error(color, size); 错误过程重现如下12345678910r &lt;-bF &lt;-wF w &lt;-bF w &lt;-bF b bw w &lt;-wF w w &lt;-bF w &lt;-bFb b b &lt;-wF w ww w w w &lt;-wF ww w w w wb b b b b &lt;-wFr r r r rb b b b br r &lt;-rF r &lt;-rF r &lt;-rF r &lt;-rFw &lt;-rF r r r r 12345678910b b bb b bw &lt;-bF w &lt;-bF bw w w &lt;-bFw w ww w wr &lt;-wF r rb b &lt;-wf &lt;-rF w &lt;-rFr &lt;-rF r r &lt;-wFr r r 错误原因：将swap(color, wflag++, rflag–)修改成swap(color, wflag, rflag–)即可为什么呢？先看正确的过程如下12345678910r &lt;-bF &lt;-wF w &lt;-bF &lt;-wF w &lt;-bF b bw w w w &lt;-bF w &lt;-bFb b b &lt;-wF w ww w w w &lt;-wF ww w w w wb b b b b &lt;-wFr r r r rb b b b br r &lt;-rF r &lt;-rF r &lt;-rF r &lt;-rFw &lt;-rF r r r r 12345678910b b b bb b b bw &lt;-bF w &lt;-bF w &lt;-bF bw w w w &lt;-bFw w w ww w w wr &lt;-wF r &lt;-wf b &lt;-wF &lt;-rF w &lt;-rFb b &lt;-rF r r &lt;-wFr &lt;-rF r r rr r r r 所以我总结，如果将wFlag指向的红旗子和rFlag指向的旗子（未知颜色）交换时，wFlag自增了，而此时rFlag本来指向的就是红旗子时，wFlag就会错过一枚红旗子 优雅的分析 老鼠走迷宫（一）参考 描述我们在二维阵列中使用2表示迷宫墙壁，使用1来表示老鼠的行走路径，求出由入口至出口的路径。 递归解法完全参考之前8皇后问题的回溯解法完整代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#define N 9int maze[N][N] = &#123; &#123;2,2,2,2,2,2,2,2,2&#125;, &#123;2,0,0,0,0,0,0,0,2&#125;, &#123;2,0,2,2,0,2,2,0,2&#125;, &#123;2,0,2,0,0,2,0,0,2&#125;, &#123;2,0,2,0,2,0,2,0,2&#125;, &#123;2,0,0,0,0,0,2,0,2&#125;, &#123;2,2,0,2,2,0,2,2,2&#125;, &#123;2,0,0,0,0,0,0,0,2&#125;, &#123;2,2,2,2,2,2,2,2,2&#125; &#125;;void print()&#123; for (int i = 0 ; i &lt; N ; i++) &#123; for (int j = 0 ; j &lt; N ; j++) &#123; if(maze[i][j] == 2) printf(\"▉\"); else if(maze[i][j] == 1) printf(\"◇\"); else printf(\" \"); &#125; printf(\"\\n\"); &#125;&#125;bool check(int row, int col)&#123; if(maze[row][col] == 0) return true; return false;&#125;static int counter = 0;void backtrack(int row, int col)&#123; maze[row][col] = 1; if(row == N - 2 &amp;&amp; col == N - 2) &#123; printf(\"solution:%d\\n\", ++counter); print(); &#125; else &#123; int direction[4][2] = &#123;&#123;row, col - 1&#125;, &#123;row - 1, col&#125;, &#123;row, col + 1&#125;, &#123;row + 1, col&#125;&#125;; for(int i = 0; i &lt; 4; ++i) &#123; int newRow = direction[i][0], newCol = direction[i][1]; if(check(newRow, newCol)) &#123; backtrack(newRow, newCol); maze[newRow][newCol] = 0; &#125; &#125; &#125;&#125;int main()&#123; printf(\"original:\\n\"); print(); backtrack(1, 1); return 0;&#125; 输出如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950original:▉▉▉▉▉▉▉▉▉▉ ▉▉ ▉▉ ▉▉ ▉▉ ▉ ▉ ▉▉ ▉ ▉ ▉ ▉▉ ▉ ▉▉▉ ▉▉ ▉▉▉▉ ▉▉▉▉▉▉▉▉▉▉solution:1▉▉▉▉▉▉▉▉▉▉◇◇◇◇ ▉▉ ▉▉◇▉▉ ▉▉ ▉◇◇▉ ▉▉ ▉◇▉ ▉ ▉▉ ◇◇ ▉ ▉▉▉◇▉▉ ▉▉▉▉ ◇◇◇◇◇◇▉▉▉▉▉▉▉▉▉▉solution:2▉▉▉▉▉▉▉▉▉▉◇◇◇◇ ▉▉ ▉▉◇▉▉ ▉▉ ▉◇◇▉ ▉▉ ▉◇▉ ▉ ▉▉ ◇◇◇▉ ▉▉▉ ▉▉◇▉▉▉▉ ◇◇◇▉▉▉▉▉▉▉▉▉▉solution:3▉▉▉▉▉▉▉▉▉▉◇ ▉▉◇▉▉ ▉▉ ▉▉◇▉ ▉ ▉▉◇▉ ▉ ▉ ▉▉◇◇◇◇◇▉ ▉▉▉ ▉▉◇▉▉▉▉ ◇◇◇▉▉▉▉▉▉▉▉▉▉solution:4▉▉▉▉▉▉▉▉▉▉◇ ▉▉◇▉▉ ▉▉ ▉▉◇▉ ▉ ▉▉◇▉ ▉ ▉ ▉▉◇◇ ▉ ▉▉▉◇▉▉ ▉▉▉▉ ◇◇◇◇◇◇▉▉▉▉▉▉▉▉▉▉ 需要注意第62行清空当前状态是必须的 非递归解法参考8皇后的非递归解法，应该也是可以做的，暂时没想好","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"图解排序算法之冒泡排序","date":"2018-02-17T06:23:51.000Z","path":"2018/02/17/图解排序算法之冒泡排序/","text":"一直想做一个通过动态图片来演示排序算法的事情，做到新手也能看懂。 目前想法是利用Python的turtle库来做，希望能做完吧。 简单演示 过程有点啰嗦，专供小白。 图中的代码见下面的完整代码 完整实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152# -*- coding:utf-8 -*-from turtle import *from time import sleep#冒泡排序#参数l:待排序列表def bubblesort(l): size = len(l) for i in range(size - 1): swapped = False ipointer.updateText((size / 2 - i - 1) * DISTANCE, 'size-i-1=%d' % (size - i - 1)) for j in range(size - i - 1): jpoiner.updateText((j - size / 2) * DISTANCE, 'j=%d' % j) setcolor((j, j + 1), 'red') if l[j] &gt; l[j + 1]: swapped = True swap(l, j, j + 1) setcolor((j, j + 1), 'black') if not swapped: breakclass Circle(Turtle): def __init__(self, ypos, r): Turtle.__init__(self) self.r = r self.ypos = ypos self.ht() self.pensize(3) self._drawCircle() def _drawCircle(self): self.penup() self.sety(self.ypos) self.pendown() self.circle(self.r) self.penup() self.sety(self.ypos + self.r - 15) self.pendown() self.write(str(radius_to_data(self.r)), align=\"center\", font=('Microsoft YaHei', 15)) def updateColor(self, color): tracer(False) self.clear() self.pencolor(color) self._drawCircle() tracer(True) def move(self, yshift): tracer(False) self.clear() self.ypos += yshift self._drawCircle() tracer(True)class Pointer(Turtle): def __init__(self, alignRight): Turtle.__init__(self) self.ht() self.pensize(3) self.penup() self.alignRight = alignRight if alignRight == True: self.setx(80) self.left(180) else: self.setx(-80) self.pendown() def _drawArrow(self): self.forward(20) self.left(150) self.forward(5) self.penup() self.back(5) self.left(60) self.pendown() self.forward(5) self.left(150) # reset direction self.penup() self.back(20) self.pendown() def updateText(self, ypos, txt, fontsize=15): tracer(False) self.clear() self.penup() self.sety(ypos) self.pendown() self._drawArrow() align = \"left\" if self.alignRight == False: align = \"right\" self.penup() self.sety(ypos - fontsize) self.pendown() self.write(txt, align = align, font=('Microsoft YaHei', fontsize)) tracer(True)#显示相关的箭头，与排序无关ipointer = Pointer(True)jpoiner = Pointer(False)circles = [] DISTANCE = 90STEP = 6def move_by_step(i, j, distance): moverA = circles[i] moverB = circles[j] count = 0 while distance &gt; 0: count += 1 distance -= STEP moverA.move(STEP) moverB.move(-STEP) sleep(0.1) circles[i] = moverB circles[j] = moverA def swap(l, i, j): move_by_step(i, j, DISTANCE * (j - i)) t = l[i] l[i] = l[j] l[j] = tdef setcolor(tup, color): for i in tup: circles[i].updateColor(color)def data_to_radius(d): return 15 + d * 4def radius_to_data(r): return int((r - 15) / 4)if __name__ == \"__main__\": setup(450, 750) arr = [7, 3, 4, 1, 5, 2, 6] size = len(arr) tracer(False) for i in range(size): ycenter = i - size / 2 r = data_to_radius(arr[i]) print(r) c = Circle(ycenter * DISTANCE - r, r) circles.append(c) tracer(True) print('before sort', arr) bubblesort(arr) print('after sort', arr) mainloop() 显然，目前写的turtle代码还不能复用到其他排序算法，后面考虑如何集成","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"随机化算法","date":"2018-02-07T12:23:51.000Z","path":"2018/02/07/随机化算法/","text":"线性同余数生成器数x1,x2…的生成满足 xi+1 = Aximod M 需要给出x0作为种子，比如x0 = 1, M = 11, A = 7时生成的数为17, 5, 2, 3, 10, 4, 6, 9, 8, 1, 7, 5... 经验总结，建议M取231 - 1 = 2147483647, A取48271 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;static const int M = 2147483647;static const int A = 48271;static const int Q = M / A;static const int R = M % A;class Random&#123;public: explicit Random(int initialValue = 1); int randomInt(); double random0_1(); int randomInt(int low, int high);private: int state_;&#125;;Random::Random(int initialValue)&#123; if(initialValue &lt; 0) initialValue += M; state_ = initialValue; if(state_ == 0) state_ = 1;&#125;int Random::randomInt()&#123; int tempState = A * (state_ % Q) - R*(state_ / Q); if(tempState &gt;= 0) state_ = tempState; else state_ = tempState + M; return state_;&#125;double Random::random0_1()&#123; return (double)randomInt() / M;&#125;int Random::randomInt(int low, int high)&#123; if(low &gt; high) return -1; return randomInt() % (high - low + 1) + low;&#125;int main()&#123; Random r; printf(\"%d\\n\", r.randomInt()); printf(\"%f\\n\", r.random0_1()); printf(\"%d\\n\", r.randomInt(3, 10)); return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++中交换两个元素值","date":"2018-02-04T04:23:51.000Z","path":"2018/02/04/C++中交换两个元素/","text":"首先，交换变量值的函数传值肯定不行，要么传引用，要么传指针，以传引用为例 一般方法使用临时变量123456void swap(int &amp;a, int &amp;b)&#123; int t = a; a = b; b = t;&#125; 不使用临时变量位运算123456void swap(int &amp;a, int &amp;b)&#123; a = a ^ b; b = a ^ b; a = a ^ b;&#125; 可以这么理解123newa = olda ^ oldbnewb = newa ^ oldb = olda ^ oldb ^ oldb = oldanewa = newa ^ newb = olda ^ oldb ^ olda = oldb 如此完成交换。 但是该位运算存在一个问题，对于数组的交换要注意。 有一次写快速排序的时候使用了位运算的swap，结果数组里出现了好多0。分析之后原因如下 比如数组为a = {3, 1, 2}，然后调用了swap(a[1], a[1])，那这样会导致什么呢 1a[1] = a[1] ^ a[1] = 0 即a[1]会被置为0。 当然，调用者本就应该来判断待交换的索引是否相同，如果相同就不交换了。但函数本身最好也要加上不等性判断12if(a == b) return; 算术运算123456void swap(int &amp;a, int &amp;b)&#123; a = a + b; b = a - b; a = a - b;&#125; 可以这么理解 123newa = olda + oldbnewb = newa - oldb = olda + oldb - oldb = oldanewa = newa - newb = olda + oldb - olda = oldb 同样存在上面的问题","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"回溯算法","date":"2018-02-02T12:08:46.000Z","path":"2018/02/02/回溯算法/","text":"以前听到这个名字挺害怕的，其实也就那么回事 是什么回溯（backtracking）,在多数情况下，相当于穷举搜索的巧妙实现。 一般是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径 下面来看几个使用回溯算法的经典问题 问题一：8皇后问题描述在8×8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后都不能处于同一行，同一列或同一斜线 各种解法 递归解法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#define QUEENS 8//通过前depth-1个元素，检查当前元素的放置是否合法bool check(int arr[], int depth)&#123; for(int i = 1; i &lt; depth; ++i) &#123; if(arr[i] == arr[depth] || //两个元素相等 (arr[i] - arr[depth]) == (i - depth) || //两个元素在正对角线 (arr[i] - arr[depth]) == (depth - i)) //两个元素在反对角线 return false; &#125; return true;&#125;static int k = 1;//arr表示放置皇后的结果数组，depth表示放置第几个（行）的皇后void backtracking(int arr[], int depth)&#123; if(depth &lt;= QUEENS) &#123; for(int i = 1; i &lt;= QUEENS; ++i) &#123; //第depth个元素分别放置[1..QUEENS]的元素来试探 arr[depth] = i; //若检查合法则放置下一个元素 if(check(arr, depth)) backtracking(arr, depth + 1); &#125; &#125; else //表示前8个元素全部放置成功，得到结果 &#123; printf(\"solution %2d: \", k++); for(int i = 1; i &lt;= QUEENS; ++i) printf(\"%d \", arr[i]); printf(\"\\n\"); &#125;&#125;int main()&#123; //以数组表示8皇后问题的解，数组中每个元素的索引代表行，值代表列 //比如a[2] = 3表示第二行第三列放置一个皇后 int array[QUEENS + 1] = &#123;0&#125;; backtracking(array, 1); return 0;&#125; 此方法虽然条理较清晰，但是并没有让人感觉到回溯的思想 非递归解法12345678910111213141516171819202122232425262728void queen_norecursive(int arr[])&#123; int depth = 1; while(depth &gt;= 1) &#123; //设置第depth个几点的值 arr[depth] += 1; //检查arr[depth]的合法性，如果不合法则自增 while(arr[depth] &lt;= QUEENS &amp;&amp; !check(arr, depth)) arr[depth] += 1; //找到有效解 if(arr[depth] &lt;= QUEENS &amp;&amp; depth == QUEENS) &#123; printf(\"solution %2d: \", k++); for(int i = 1; i &lt;= QUEENS; ++i) printf(\"%d \", arr[i]); printf(\"\\n\"); &#125; //继续下一层 else if(arr[depth] &lt;= QUEENS &amp;&amp; depth &lt; QUEENS) depth += 1; else //回溯 &#123; arr[depth] = 0; --depth; &#125; &#125;&#125; 光看代码还是，不太好理解，通过在关键位置增加log，N为4时相应输出如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137current depth:1 current arr: 1 0 0 0 //设置节点1的值为1，合法increase depth to: 2 //设置下一层current depth:2current arr: 1 1 0 0 //设置节点2的值为1，不合法，因为x[2]==x[1]current arr: 1 2 0 0 //设置节点2的值为2，不合法，因为x[2]-x[1] == 2-1current arr: 1 3 0 0 //设置节点2的值为3，合法increase depth to: 3 //设置下一层current depth:3current arr: 1 3 1 0 //设置节点3的值为1，不合法，因为x[3] == x[1]current arr: 1 3 2 0 //设置节点3的值为2，不合法，因为x[3]-x[2] == 1-2current arr: 1 3 3 0 //设置节点3的值为3，不合法，因为x[3] == x[2]current arr: 1 3 4 0 //设置节点3的值为4，不合法，因为x[3]-x[2] == 3-2current arr: 1 3 5 0 //设置节点3的值为5，不合法，因为x[3] &gt; 4了backtracking.. //回溯，设置节点3的值为0current depth:2 //回到设置上一层current arr: 1 4 0 0 //设置节点2的值为4（因为前次为3），合法increase depth to: 3 //设置下一层current depth:3current arr: 1 4 1 0 //设置节点3的值为1，不合法，因为x[3] == x[1]current arr: 1 4 2 0 //设置节点3的值为2，合法increase depth to: 4 //设置下一层current depth:4current arr: 1 4 2 1 //设置节点4的值为1，不合法，因为x[4] == x[1]current arr: 1 4 2 2 //设置节点4的值为2，不合法，因为x[3] == x[4]current arr: 1 4 2 3 //设置节点4的值为3，不合法，因为x[4]-x[3] == 4-3current arr: 1 4 2 4 //设置节点4的值为4，不合法，因为x[4] == x[2]current arr: 1 4 2 5 //设置节点4的值为5，不合法，因为x[4] &gt; 4了backtracking.. //回溯，设置节点4的值为0current depth:3 //回到设置上一层current arr: 1 4 3 0 //设置节点3的值为3，不合法，因为x[3]-x[2] == 2-3current arr: 1 4 4 0 //设置节点3的值为4，不合法，因为x[3] == x[2]current arr: 1 4 5 0 //设置节点3的值为5，不合法，因为x[3] &gt; 4了backtracking.. //回溯，设置节点3的值为0current depth:2 //回到设置上一层current arr: 1 5 0 0 //设置节点2的值为5，不合法，因为x[2] &gt; 4了backtracking.. //回溯，设置节点2的值为0current depth:1 //回到设置上一层current arr: 2 0 0 0 //设置节点1的值为2，合法increase depth to: 2 //设置下一层current depth:2current arr: 2 1 0 0 //设置节点2的值为1，不合法，因为x[2]-x[1] == 1-2current arr: 2 2 0 0 //设置节点2的值为2，不合法，因为x[2] == x[1]current arr: 2 3 0 0 //设置节点2的值为3，不合法，因为x[2]-x[1] == 2-1current arr: 2 4 0 0 //设置节点2的值为3，合法increase depth to: 3 //设置下一层current depth:3current arr: 2 4 1 0 //设置节点3的值为1，合法increase depth to: 4 //设置下一层current depth:4current arr: 2 4 1 1 //设置节点4的值为1，不合法，因为x[4] == x[3]current arr: 2 4 1 2 //设置节点4的值为2，不合法，因为x[4] == x[1]current arr: 2 4 1 3 //设置节点4的值为3，合法solution 1: 2 4 1 3 //此时depth == 4，满足条件，打印相应输出current depth:4current arr: 2 4 1 4 //下同，不再赘述current arr: 2 4 1 5backtracking..current depth:3current arr: 2 4 2 0current arr: 2 4 3 0current arr: 2 4 4 0current arr: 2 4 5 0backtracking..current depth:2current arr: 2 5 0 0backtracking..current depth:1current arr: 3 0 0 0increase depth to: 2current depth:2current arr: 3 1 0 0increase depth to: 3current depth:3current arr: 3 1 1 0current arr: 3 1 2 0current arr: 3 1 3 0current arr: 3 1 4 0increase depth to: 4current depth:4current arr: 3 1 4 1current arr: 3 1 4 2solution 2: 3 1 4 2current depth:4current arr: 3 1 4 3current arr: 3 1 4 4current arr: 3 1 4 5backtracking..current depth:3current arr: 3 1 5 0backtracking..current depth:2current arr: 3 2 0 0current arr: 3 3 0 0current arr: 3 4 0 0current arr: 3 5 0 0backtracking..current depth:1current arr: 4 0 0 0increase depth to: 2current depth:2current arr: 4 1 0 0increase depth to: 3current depth:3current arr: 4 1 1 0current arr: 4 1 2 0current arr: 4 1 3 0increase depth to: 4current depth:4current arr: 4 1 3 1current arr: 4 1 3 2current arr: 4 1 3 3current arr: 4 1 3 4current arr: 4 1 3 5backtracking..current depth:3current arr: 4 1 4 0current arr: 4 1 5 0backtracking..current depth:2current arr: 4 2 0 0increase depth to: 3current depth:3current arr: 4 2 1 0current arr: 4 2 2 0current arr: 4 2 3 0current arr: 4 2 4 0current arr: 4 2 5 0backtracking..current depth:2current arr: 4 3 0 0current arr: 4 4 0 0current arr: 4 5 0 0backtracking..current depth:1current arr: 5 0 0 0backtracking.. 问题二：公路收费点重建问题描述设给定N个点p1,p2,…,pN,他们位于x轴上。设xi是pi的x坐标，并且假设x1=0,并且这些点从左到右给出。则这N个点确定每一对点间的N(N-1)/2个形如|xi-xj|(i!=j)的距离d1,..,dN。公路收费点问题是从这些距离重建一个点集。 举个例子 比如x1=0,x2=3,x3=4,x4=6,则生成的d集合为{3, 4, 6, 1, 3, 2}，排序一下得到{1, 2, 3, 3, 4, 6} 现在要做的是从d的集合，反推出x的点集 书中有一个详细的反推的例子，已知D={1,2,2,2,3,3,3,4,5,5,5,6,7,8,10}，推理过程如下：由D的长度15可知，N为6 显然x1=0，x6=10，因为10是D中最大元素，从D中删除10 剩下的最大距离为8，则x2=2，或者x5=8。由对称性可知这两种选择等价，取后者，从D中删除2和8 剩下的最大距离为7，有两种可能 x4=7，则从D中删除1,3,7，剩余最大值为6,又有两种可能A. x3=6，这不可能，因为1已被删除，不在D中，而x4-x3=1B. x2=4，这不可能，因为会导致存在两个4,x2-x1=4,x5-x2=4 x2=3，由于上面的结果都不可能，所以只能取这种 此时D={1,2,2,3,3,4,5,5,6}，最大值为6，则又有两种可能 x3 = 4，这不可能，因为x3-x1=4,x5-x3=4，导致存在两个4 x4=6 剩下唯一解x3=5，代入验证得此时D为空集，答案有效 解答书中给出完整伪代码 公路收费点重建算法：驱动例程12345678910111213bool turnpike(vector&lt;int&gt; &amp;x, DistSet d, int n)&#123; x[1] = 0; d.deleteMax(x[n]); d.deleteMax(x[n - 1]); if(x[n] - x[n - 1] ∈ d) &#123; d.remove(x[n] - x[n - 1]); return place(x, d, n, 2, n - 2); &#125; else return false;&#125; 大致过程为 放置x[1], x[n], x[n - 1]，并在d中删除x[n]和x[n - 1] 判断x[n] - x[n - 1]是否在d中，如果在则从d中移除，并放置其他点 如果不在，则直接返回 公路收费点重建算法：回溯的步骤12345678910111213141516171819202122232425262728293031323334353637/** * Backtracking algorithm to place x[left]...x[right]. * x[1]..x[left-1] and x[right+1]...x[n] already tentatively placed. * If place return true, then x[left]...x[right] will have values. */bool place(vector&lt;int&gt; &amp;x, DistSet d, int n, int left, int right)&#123; int dmax; bool found = false; dmax = d.findMax(); //check if setting x[right] == dmax is feasible.. if(|x[j] - dmax| ∈ d for all 1&lt;=j&lt;left and right&lt;j&lt;=n) &#123; x[right] = dmax; //Try x[right] = dmax for(1&lt;=j&lt;left, right&lt;j&lt;=n) d.remove(| x[j] - dmax |); found = place(x, d, n, left, right - 1); if(!found) //Backtrack for(1&lt;=j&lt;left, right&lt;j&lt;=n) //Undo the deletion d.insert(| x[j] - dmax |); &#125; // If first attempt is failed, try to see if setting // x[left] = x[n] - dmax is feasible. if(!found &amp;&amp; (| x[n] -dmax - x[j] | ∈ d for all 1&lt;=j&lt;left and right&lt;j&lt;=n)) &#123; x[left] = x[n] - dmax; //Same logic as before for(1&lt;=j&lt;left, right&lt;j&lt;=n) d.remove(| x[n] - dmax - x[j] |); found = place(x, d, n, left+1, right); if(!found) //Backtrack for(1&lt;=j&lt;left, right&lt;j&lt;=n) //Undo the deletion d.insert(| x[n] - dmax - x[j] |); &#125; return found;&#125; 英文注释已经比较完整地说明了整个流程，有一点说明一下“x[right] = dmax”，表示设置右边的点为dmax，此时x[right]距x[1]距离为dmax“x[left] = x[n]-dmax”，设置左边点之后，x[left]距x[n]为dmax 根据书中伪代码实现一下，考虑使用std::multiset代替DistSet，因为multiset有两个特点 可以允许重复值，这是set不具备的 元素始终有序，便于找出最大值 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;stdio.h&gt;#include &lt;set&gt;#include &lt;vector&gt;typedef std::vector&lt;int&gt; Vec ;typedef std::multiset&lt;int&gt; MSet ;//删除d中最大值，并将其赋值给x中索引n对应的值void deleteMax(Vec &amp;x, MSet &amp;d, int n)&#123; auto maxItr = d.end(); --maxItr; x[n] = *maxItr; d.erase(maxItr);&#125;//删除d中键为val的元素，不直接使用erase的原因是：erase会将所有相同元素删除void removeVal(MSet &amp;d, int val, bool firstOnly = true)&#123; for(auto itr = d.begin(); itr != d.end();) &#123; if(val == *itr) &#123; itr = d.erase(itr); if(firstOnly) return; &#125; else ++itr; &#125;&#125;//检查若插入insertData，与其他所有已存在的点的距离，是否在d中bool check(const Vec &amp;x, MSet d, int n, int left, int right, int insertData)&#123; for(int i = 1; i &lt;= n; ++i) &#123; //跳过[left...right] if(i &gt;= left &amp;&amp; i &lt;= right) continue; int diff = abs(x[i] - insertData); if(d.find(diff) == d.end()) return false; else removeVal(d, diff); //这里把已经验证存在的项删除 //比如d中只有一个2，而差有两个2时，就是不合法的 &#125; return true;&#125;bool place(Vec &amp;x, MSet &amp;d, int n, int left, int right)&#123; if(d.empty()) return true; auto itr = d.end(); int dmax = *(--itr); bool found = false; //插入x[right] = dmax if(check(x, d, n, left, right, dmax)) &#123; x[right] = dmax; for(int i = 1; i &lt;= n; ++i) &#123; if(i &gt;= left &amp;&amp; i &lt;= right) continue; removeVal(d, abs(x[i] - dmax)); &#125; found = place(x, d, n, left, right - 1); if(!found) &#123; for(int i = 1; i &lt;= n; ++i) &#123; if(i &gt;= left &amp;&amp; i &lt;= right) continue; d.insert(abs(x[i] - dmax)); &#125; &#125; &#125; if(!found &amp;&amp; check(x, d, n, left, right, x[n] - dmax)) &#123; x[left] = x[n] - dmax; for(int i = 1; i &lt;= n; ++i) &#123; if(i &gt;= left &amp;&amp; i &lt;= right) continue; removeVal(d, abs(x[n] - dmax - x[i])); &#125; found = place(x, d, n, left + 1, right); if(!found) &#123; for(int i = 1; i &lt;= n; ++i) &#123; if(i &gt;= left &amp;&amp; i &lt;= right) continue; d.insert(abs(x[n] - dmax - x[i])); &#125; &#125; &#125; return found;&#125;bool turnpike(Vec &amp;x, MSet &amp;d, int n)&#123; x[1] = 0; deleteMax(x, d, n); deleteMax(x, d, n - 1); int diff = x[n] - x[n - 1]; if(d.find(diff) != d.end()) &#123; removeVal(d, diff); return place(x, d, n, 2, n - 2); &#125; return false;&#125;int main()&#123; Vec x(7); MSet d&#123;1, 2, 2, 2, 3, 3, 3, 4, 5, 5, 5, 6, 7, 8, 10&#125;; int n = 6; if(turnpike(x, d, n)) &#123; for(int i = 1; i &lt;= n; ++i) printf(\"%d \", x[i]); //0 3 4 6 8 10 &#125; else printf(\"can not find solution\\n\"); return 0;&#125; 感觉好啰嗦，应该可以化简","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"72法则","date":"2018-01-30T06:23:51.000Z","path":"2018/01/30/72法则/","text":"什么是72法则编程珠玑中无意看到了关于72法则的描述，兴趣突然来了 假设以年利率r%投资一笔钱y年，“72法则”指出，如果r×y=72，那么投资差不多会翻倍 验证下面我试了几种常见收益下的情况 r(收益率%) y(年数) 总收益率(%) 3 24 (1 + 0.03)24 ≈ 203.28 4 18 (1 + 0.04)18 ≈ 202.58 6 12 (1 + 0.06)12 ≈ 201.22 8 9 (1 + 0.08)9 ≈ 199.9 9 8 (1 + 0.09)8 ≈ 199.26 12 6 (1 + 0.12)6 ≈ 197.38 18 4 (1 + 0.18)4 ≈ 193.88 24 3 (1 + 0.24)3 ≈ 190.66 可以看出来，确实非常接近，特别是收益率在6%到12%之间的时候。 好神奇，做个图吧用matplotlib做一个关系图。其中x为年化收益率，在1到30变化 y为总收益率(1 + x/100)(72/x) 如下图所示 相应代码如下 123456789101112131415from matplotlib import pyplot as pltimport numpy as npRATIO = 72x = np.linspace(1, 30, 100)y = np.power(1 + x/100, RATIO / x) * 100plt.plot(x, y, color='red', linewidth=3)plt.xlabel('年化收益率(%)', fontproperties='SimHei', fontsize=10)plt.ylabel('总收益率(%)', fontproperties='SimHei', fontsize=10)plt.title('72/x年总收益率变化情况', fontproperties='SimHei', fontsize=10)plt.ylim(150, 250)plt.legend()plt.show() 复利的力量！！！","tags":[{"name":"金融","slug":"金融","permalink":"http://yoursite.com/tags/金融/"}]},{"title":"循环移位问题解析","date":"2018-01-27T06:23:51.000Z","path":"2018/01/27/循环移位问题解析/","text":"描述将一个n元1维向量左旋转（循环移位）i个 ，当n为6，i为3时，向量abcdefgh旋转为defghabc 各种解决方案2b做法-循环左移n次123456789101112void leftMove1(char *src, int i)&#123; int n = strlen(src); i %= n; for(int j = 0; j &lt; i; ++j) &#123; char t = src[0]; for(int k = 1; k &lt; n; ++k) src[k - 1] = src[k]; src[n - 1] = t; &#125;&#125; 自己实现的，书上没有。不多解释，显然缺点是效率低 普通做法-拷贝临时数组12345678910111213141516void leftMove2(char *src, int i)&#123; int n = strlen(src); i %= n; if(i &lt;= 0) return; char *temp = new char[i]; //先将前i个字符拷贝到临时数组 memcpy(temp, src, i); for(int j = 0; j &lt; n - i; ++j) src[j] = src[j + i]; char *p = src + n - i; //再将i个字符拷贝到原数组的后i位 memcpy(p, temp, i); delete []temp;&#125; 自己实现的，书上没有。也比较好理解，缺点是需要额外的空间。 文艺做法说明 拷贝x[0]到t 拷贝x[i]-&gt;x[0]，x[2i]-&gt;x[i]，…x[ki]-&gt;x[(k-1)i]…其中当ki超过数组长度时，与数组长度取模 本轮结束条件，当ki与数组长度取模后取到0时，改为取t值，然后结束 如果该过程没有移动全部元素，就从x[1]开始再次移动，直到所有的元素都已经移动 书中说这种做法像精巧的杂技动作。没有完全理解其精髓，但总体上感觉这么移动完之后每一个元素都左移了i个位置，这样整个移动就结束了 实现 我的实现方法 123456789101112131415161718192021222324252627282930void leftMove3(char *src, int i)&#123; int n = strlen(src); i %= n; if(i &lt;= 0) return; //移动次数 int times = 0; for(int j = 0; j &lt; i; ++j) &#123; char t = src[j]; int to = j, from = i + j; while(true) &#123; from %= n; to %= n; times++; if(from == j) &#123; src[to] = t; break; &#125; src[to] = src[from]; from += i; to += i; &#125; if(times &gt;= n) break; &#125;&#125; 标准答案将x[n]向左旋转rotdist个位置 12345678910111213for i = [0, gcd(rotdist, n)) /* move i-th values of block*/ t = x[i] j = i loop k = j + rotdist if k &gt;= n k -= n if k == i break x[j] = x[k] j = k x[j] = t rotdist和n的最大公约数是所需的置换次数（用近世代数术语来说，也就是旋转产生的置换群的陪集个数）太专业了 分析一下和标准答案的差距在哪1、循环次数应该取最大公约数，这个很难，不说肯定不知道2、标准答案里没有用模之类的，可能觉得效率差吧 用标准答案实现1234567891011121314151617181920212223242526272829303132int gcd(int a, int b)&#123; int t; while(b) &#123; t = a % b; a = b; b = t; &#125; return a;&#125;void leftMove3_standard(char *src, int rotdist)&#123; int n = strlen(src); for(int i = 0; i &lt; gcd(rotdist, n); ++i) &#123; char t = src[i]; int j = i; while(true) &#123; int k = j + rotdist; if(k &gt;= n) k -= n; if(k == i) break; src[j] = src[k]; j = k; &#125; src[j] = t; &#125;&#125; 牛b做法说明 旋转向量x其实就是交换向量AB-&gt;BA，其中A代表前i个元素 假设A比B短，则将B分为Bl和Br，其中Br和A一样长。 交换A和Br，即ABlBr-&gt;BrBlA，此时A的位置已经正确。 问题转化为交换B的两部分，递归解决。 若A比B长，则将A转化为AlAr，Al和B一样长同样的解决 实现 我的实现方法 1234567891011121314151617181920212223242526272829303132333435363738void swap(char &amp;a, char &amp;b)&#123; char t = a; a = b; b = t;&#125;void moveHelper(char *src, int begin, int mid, int end)&#123; int leftLen = mid - begin, rightLen = end - mid + 1; if(!leftLen || !rightLen) return; //正好对半分，则直接交换即可(完全可以合并到下面的任何一个分支里，放着只为清晰) if(leftLen == rightLen) &#123; for(int i = 0; i &lt; leftLen; ++i) swap(src[begin + i], src[begin + leftLen + i]); &#125; else if(leftLen &lt; rightLen)//右边长，右边分为BlBr &#123; for(int i = 0; i &lt; leftLen; ++i) swap(src[begin + i], src[end - leftLen + 1 + i]); moveHelper(src, begin, mid, end - leftLen); &#125; else if(leftLen &gt; rightLen)//左边长，左边分为AlAr &#123; for(int i = 0; i &lt; rightLen; ++i) swap(src[begin + i], src[mid + i]); moveHelper(src, begin + rightLen, mid, end); &#125;&#125;void leftMove4(char *src, int i)&#123; int n = strlen(src); moveHelper(src, 0, i, n - 1);&#125; 标准答案伪代码如下 123456789101112131415161718if rotdist == 0 || rotdist == n returni = p = rotdistj = n - pwhile i != j /* invariant x[0..p-i] in final position x[p-i..p-1]=a (to be swapped with b) x[p..p+j-1]=b (to be swapped with a) x[p+j..n-1] in final position */ if i &gt; j swap(p-i, p, j) i -= j else swap(p-i, p+j-i, i) j -= i swap(p-i, p, i) 有点难，还没有完全理解，实现一下123456789101112131415161718192021222324252627282930void swap(char *src, int a, int b, int m)&#123; if(a == b) return; for(int i = 0; i &lt; m; ++i) swap(src[a + i], src[b + i]);&#125;void leftMove4_standard(char *src, int rotdist)&#123; int n = strlen(src); if(rotdist == 0 || rotdist == n) return; int i = rotdist, p = rotdist; int j = n - p; while(i != j) &#123; if(i &gt; j) &#123; swap(src, p - i, p, j); i -= j; &#125; else &#123; swap(src, p - i, p + j - i, i); j -= i; &#125; &#125; swap(src, p - i, p, i);&#125; 终极吊炸天做法说明下面用Ar表示A的逆，对于数组AB 对A求逆得到ArB 再对B求逆得到ArBr 再整体求逆得到(ArBr)r 而向量(ArBr)r即为BA。 数组abcdefgh，i为3，n为8123reverse(0, i - 1) /*cbadefgh*/reverse(i, n - 1) /*cbahgfed*/reverse(0. n - 1) /*defghabc*/ 实现12345678910111213void reverse(char *src, int begin, int end)&#123; while(begin &lt; end) swap(src[begin++], src[end--]);&#125;void leftMove5(char *src, int i)&#123; int n = strlen(src); reverse(src, 0, i - 1); reverse(src, i, n - 1); reverse(src, 0, n - 1);&#125; 极其简单，不易出错。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"编程珠玑学习笔记","date":"2018-01-25T12:23:51.000Z","path":"2018/01/25/编程珠玑学习笔记/","text":"第一章开篇题目描述包含n个都小于n且相异的整数，要求排序后输出到另一个文件 解答123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;fstream&gt;#define BYTESPERWORD 32#define SHIFT 5#define MASK 0x1F#define N 10000000int array[1 + N / BYTESPERWORD];//精华为下面这三个函数void set(int i) &#123; array[i &gt;&gt; SHIFT] |= (1 &lt;&lt; (i &amp; MASK)); &#125;void clr(int i) &#123; array[i &gt;&gt; SHIFT] &amp;= ~(1 &lt;&lt; (i &amp; MASK)); &#125;//这里和原书中做了一点小改动，int-&gt;bool，应该没啥影响bool test(int i) &#123; return array[i &gt;&gt; SHIFT] &amp; (1 &lt;&lt; (i &amp; MASK)); &#125;//我的理解：//1、array长度为什么是[1+N/32]//每个int有32个位，每个位为1表示该位置对应的数存在。则每个int可以表示32个数是否存在。//额外加1是因为，比如表示33个数则需要2个int值//2、i &gt;&gt; SHIFT什么意思//相当于i/(2e5)即i/32，表示数字i对应的比特位，在数组中的第i/32个数中。//比如数31对应的比特位在第一个数的最后一个比特位上；数32对应的比特位在第二个数的第一个比特位上//3、(1 &lt;&lt; (i &amp; MASK))什么意思//其中(i &amp; MASK)即i%32，所以原表达式表示32个位中第(i%32)个位为1，其他位全为0//比如数31得到的值为10000000000000000000000000000000//数32得到的值为00000000000000000000000000000001void setDataFromFile(const char *fname)&#123; std::ifstream infile(fname); if(!infile) return; int data; while(!infile.eof()) &#123; infile &gt;&gt; data; set(data); &#125; infile.close();&#125;void saveDataToFile(const char *fname)&#123; std::ofstream outfile(fname); if(outfile.is_open()) &#123; for(int i = 0; i &lt; N; ++i) &#123; if(test(i)) outfile &lt;&lt; i &lt;&lt; std::endl; &#125; outfile.close(); &#125;&#125;int main()&#123; for(int i = 0; i &lt; N; ++i) clr(i); setDataFromFile(\"in.txt\"); saveDataToFile(\"out.txt\"); return 0;&#125; 生成0到n之间k个不同的随机顺序的随机整数难点在“不同”二字，伪代码如下12345for i = [0,n) x[i] = ifor i = [0,k) swap(i, randint(i, n-1)) print x[i] 注意到每次随机index的下界i都在递增，保证了不会出现重复的数。精妙 第二章问题1描述给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数（在文件中至少缺少一个这样的数为什么） 解题思路 首先为什么至少缺少这样一个数 因为2的32次方比40亿略大，即整数的每一位0、1互换，能表示40亿多个整数。 所以肯定至少缺少一个这样的数哦。 读入40亿个整数，起始位为0的写入文件A，为1的写入文件B A,B中有一个文件最多包含20亿个整数，选择这个文件继续 依次类推，总的运行时间正比于n 问题2参考循环移位问题解析 问题3描述给定一个英语词典，找出其中所有的变位词集合。例如“pots”，“stop”，“tops”互为变位词。因为每一个单词都可以通过改变其他单词中字母的顺序来得到 解题思路123456pans anps pans anps panspots opst pots anps snap pans snapopt -&gt;[sign] -&gt; opt opt -&gt; sort -&gt; opt opt -&gt; optsnap anps snap opst pots pots stop topsstop opst stop opst stoptops opst tops opst tops 输入文件经过sign标识文件后，每一行增加一个sign标识 其中sign程序如下12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;//原书：//int charcomp(char *x, char *y)//&#123; return *x - *y;&#125;//使用cl.exe直接编译时有error，这里简单修改了一下int charcomp(const void *x, const void *y)&#123; return *(const char *)x - *(const char *)y; &#125;#define WORDMAX 100int main()&#123; char word[WORDMAX], sig[WORDMAX]; while(scanf(\"%s\", word) != EOF) &#123; strcpy(sig, word); qsort(sig, strlen(sig), sizeof(char), charcomp); printf(\"%s %s\\n\", sig, word); &#125; return 0;&#125; 系统sort程序对sign标识进行排序，从而得到有序的输出 sort程序为系统程序 squash程序根据标识的异同将相应的单词输出 程序实现如下123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string&gt;#define WORDMAX 100int main()&#123; char word[WORDMAX], sig[WORDMAX], oldsig[WORDMAX]; strcpy(oldsig, \"\"); int linenum = 0; while(scanf(\"%s %s\", sig, word) != EOF) &#123; if(strcmp(oldsig, sig) != 0 &amp;&amp; linenum &gt; 0) printf(\"\\n\"); strcpy(oldsig, sig); linenum++; printf(\"%s \", word); &#125; printf(\"\\n\"); return 0;&#125; 命令行执行命令1sign &lt;dictonary | sort | squash&gt; gramlist 其中dictionary文件可以从这找words.txt 几点感想 原来scanf还能这么玩，从文件得到输出 原来系统还有sort这样的程序可以调用。如果没有的话感觉还是比较难将文件内容排序的。 原来一个程序的printf可以作为另一个程序的scanf。 才疏学浅啊。 第三章数据决定程序结构 k阶常系数方程计算描述an = c1an-1 + c2an-2 + … + ckan-k + ck+1其中c为常数，编写程序，输入为k，a1,…ak,c1,…ck+1和n，输出a1至am 实现书中没有实现，想了递归和非递归两种方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define K 15#define N 20int arrayA[N + 1];int arrayC[K + 2];int A_recursive(int n)&#123; if(n &lt;= K) return arrayA[n]; int sum = 0; for(int i = 1; i &lt;= K; ++i) sum += arrayC[i] * A_recursive(n - i); sum += arrayC[K + 1]; return sum;&#125;//这里其实可以优化，因为算a[16]时已经计算//而算a[18]时又把a[16]计算了一把int A_normal(int n)&#123; if(n &gt; K) &#123; for(int i = K + 1; i &lt;= n; ++i) &#123; int temp = 0; for(int j = 1; j &lt;= K; ++j) temp += arrayC[j] * arrayA[i - j]; arrayA[i] = temp + arrayC[K + 1]; &#125; &#125; return arrayA[n];&#125;int main()&#123; for(int i = 1; i &lt;= K; ++i) arrayA[i] = i + 1; for(int i = 1; i &lt;= K + 1; ++i) arrayC[i] = K + 1 - i; printf(\"%d\\n\", A_recursive(16)); printf(\"%d\\n\", A_normal(16)); printf(\"%d\\n\", A_recursive(18)); printf(\"%d\\n\", A_normal(18)); return 0;&#125; 第四章二分搜索的讨论实现实现了一把，考虑了泛型，可以同时比较整形，浮点，字符串等。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;template &lt;typename T&gt;int binarySearch(T array[], int size, T data, int(*cmp)(T, T))&#123; int begin = 0, end = size - 1; while(begin &lt;= end) &#123; int mid = (begin + end) / 2; int result = cmp(array[mid], data); if(result == 0) return mid; else if(result &lt; 0) begin = mid + 1; else end = mid - 1; &#125; return -1;&#125;int intCompare(int a, int b)&#123; return a - b;&#125;#define PRECISION 1e-9int doubleCompare(double a, double b)&#123; if(((a - b) &gt; -PRECISION) &amp;&amp; ((a - b) &lt; PRECISION)) return 0; else if(a &gt; b) return 1; else return -1;&#125;int strCompare(char *a, char *b)&#123; while(*a &amp;&amp; *b &amp;&amp; *a == *b) &#123; ++a; ++b; &#125; return *a - *b;&#125;int main()&#123; int intArray[] = &#123;1, 3, 5, 9, 10, 30&#125;; int result = binarySearch(intArray, sizeof(intArray)/sizeof(int), 4, intCompare); printf(\"int result :%d\\n\", result); char *strArray[] = &#123;\"I\", \"Love\", \"Money\"&#125;; result = binarySearch&lt;char *&gt;(strArray, sizeof(strArray)/sizeof(char*), \"Love1\", strCompare); printf(\"str result :%d\\n\", result); double doubleArray[] = &#123;3.14, 4.12, 6.00, 7.15&#125;; result = binarySearch(doubleArray, sizeof(doubleArray)/sizeof(float), 6.0, doubleCompare); printf(\"float result :%d\\n\", result); return 0;&#125; 2018-03-15更新函数原型声明为如下，更为合理12template &lt;typename T, typename Compare&gt;int binarySearch(T array[], int size, T data, Compare cmp) 调用的话还是和之前一样。 这才是泛型编程常用的声明形式。 与chromium源码比较在chromium源码中以binarysearch为关键字搜索到了几处 javascript/chromium/chrome/common/extensions/docs/examples/api/downloads/download_manager/popup.js 123456789101112131415function binarySearch(array, target, cmp) &#123; var low = 0, high = array.length - 1, i, comparison; while (low &lt;= high) &#123; i = (low + high) &gt;&gt; 1; comparison = cmp(target, array[i]); if (comparison &lt; 0) &#123; low = i + 1; &#125; else if (comparison &gt; 0) &#123; high = i - 1; &#125; else &#123; return i; &#125; &#125; return i; //这里为什么要返回i，没搞懂&#125;; JAVA/chromium/third_party/protobuf/javanano/src/main/java/com/google/protobuf/nano/FieldArray.java 12345678910111213141516private int binarySearch(int value) &#123; int lo = 0; int hi = mSize - 1; while (lo &lt;= hi) &#123; int mid = (lo + hi) &gt;&gt;&gt; 1; int midVal = mFieldNumbers[mid]; if (midVal &lt; value) &#123; lo = mid + 1; &#125; else if (midVal &gt; value) &#123; hi = mid - 1; &#125; else &#123; return mid; // value found &#125; &#125; return ~lo; // value not present&#125; C++/chromium/third_party/harfbuzz-ng/src/hb-open-type-private.hh 12345678910111213141516171819template &lt;typename SearchType&gt;inline int bsearch (const SearchType &amp;x) const&#123;/* Hand-coded bsearch here since this is in the hot inner loop. */const Type *array = this-&gt;array;int min = 0, max = (int) this-&gt;len - 1;while (min &lt;= max)&#123; int mid = (min + max) / 2; int c = array[mid].cmp (x); if (c &lt; 0) max = mid - 1; else if (c &gt; 0) min = mid + 1; else return mid;&#125;return -1;&#125; 可以看到js和C++也是使用了泛型编程。一点感想 前两者都是使用右移而没有使用除法，这个以后要注意。 第八章最大子序列求解问题描述比如序列{31, -41, 59, 26, -53, 58, 97, -93, -23, 84} 最大子序列和为x[2…6]，即187 解答在《数据结构与算法分析》2.4节也有相应描述，解答如下 12345678910111213int maxSubSum(const std::vector&lt;int&gt; &amp;a)&#123; int maxSum = 0, thisSum = 0; for(int j = 0; j &lt; a.size(); ++j) &#123; thisSum += a[j]; if(thisSum &gt; maxSum) maxSum = thisSum; else if(thisSum &lt; 0) thisSum = 0; &#125; return maxSum;&#125; 伪代码本书中给出的伪代码123456maxsofar = 0maxendinghere = 0for i = [0, n) /*invariant: maxending and maxsofar are accurate for x[0..i-1]*/ maxendinghere = max(maxendinghere + x[i], 0) maxsofar = max(maxsofar, maxendinghere) 可以看出，说的是一个意思 发散一下如果需要求出最大序列具体的起止索引呢。参考上面的做法，稍微修改了一下 1234567891011121314151617181920212223int maxSubSum(const std::vector&lt;int&gt; &amp;a)&#123; int maxSum = 0, thisSum = 0; int from = 0, to = 0; for(int j = 0; j &lt; a.size(); ++j) &#123; thisSum += a[j]; if(thisSum &gt; maxSum) &#123; maxSum = thisSum; //最大序列变化了，终止节点也相应变化 to = j; &#125; else if(thisSum &lt; 0) &#123; //这里from从下一个节点开始算 from = j + 1; thisSum = 0; &#125; &#125; printf(\"from :%d, to:%d\\n\", from, to); return maxSum;&#125; 习题5如何处理cumarr[-1]123float realarr[] = &#123;1.0, 3.0, 2.0&#125;;float *cumarr = realarr + 1;printf(\"%f\\n\", cumarr[-1]); //1.0 习题9说明原题中将负数组的最大子序列和定义为0，即空序列，现在将其定义为数组中的最大值。 比如数组为[-3, -2, -1, -9]，按照上面的做法，得出的maxSum为0.现在要求值为-1。 实现只需要将maxSum的初始值设为array[0]即可 为什么呢？ 我这么理解，对于一个全负数组，每次循环都会走到[thisSum=0]，所以每次thisSum就 代表了arr[i]的值，这样原函数就退化为了求数组最大值的函数咯 习题10说明原题修改为查找总和最接近实数t的向量 实现以t为0为例，即查找总和最接近0的向量 初始化累加数组cum，使得cum[i] = x[0] + … + x[i] 拷贝cum数组到临时数组cumtemp，并排序数组cumtemp 查找最接近的两项，这里书上没说怎么做，我想的做法是– 建立临时数组arr，– 从下标1开始，arr[i] = cumtemp[i] - cumtemp[i - 1]，注意到cum是已排序过的，所以arr每个值都不小于0– 查找arr中的最小值对应的index– 则cumtemp[index - 1]和cumtemp[index]是最接近的两项 根据最接近两项的值，再原cum数组中查找具体的leftIndex和rightIndex 则[leftIndex + 1, rightIndex]即为和最接近0的向量 感觉太啰嗦了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;void swap(int &amp;a, int &amp;b)&#123; int t = a; a = b; b = t;&#125;void qsort(int *array, int begin, int end)&#123; if(begin &gt;= end) return; int i = begin, j = end; swap(array[begin], array[(begin + end) / 2]); int curData = array[begin]; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; array[j] &gt;= curData) --j; while(i &lt; j &amp;&amp; array[i] &lt;= curData) ++i; if(i &lt; j) swap(array[i], array[j]); &#125; swap(array[i], array[begin]); qsort(array, begin, i - 1); qsort(array, i + 1, end);&#125;void findMinIndex(int *cumarr, int size, int t, int &amp;left, int &amp;right)&#123; int *subarr = new int[size]; for(int i = 1; i &lt; size; ++i) subarr[i] = abs(cumarr[i] - cumarr[i - 1] - t); int minIndex = 1, minVal = subarr[1]; for(int i = 2; i &lt; size; ++i) &#123; if(subarr[i] &lt; minVal) &#123; minIndex = i; minVal = subarr[i]; &#125; &#125; left = cumarr[minIndex - 1]; right = cumarr[minIndex]; delete []subarr;&#125;int findIndex(int *arr, int size, int data, bool reverse = false)&#123; if(reverse) &#123; for(int i = size - 1; i &gt;= 0; --i) if(data == arr[i]) return i; &#125; else &#123; for(int i = 0; i &lt; size; ++i) if(data == arr[i]) return i; &#125; return -1;&#125;void findMostNear(int *array, int size, int t)&#123; if(size &lt;= 1) return; int *cumarr = new int[size], *cumtemp = new int[size]; cumarr[0] = cumtemp[0] = array[0]; for(int i = 1; i &lt; size; ++i) cumarr[i] = cumtemp[i] = cumarr[i - 1] + array[i]; qsort(cumtemp, 0, size - 1); int leftVal, rightVal; findMinIndex(cumtemp, size, t, leftVal, rightVal); int leftIndex = findIndex(cumarr, size, leftVal, false), rightIndex = findIndex(cumarr, size, rightVal, true); delete []cumarr; delete []cumtemp; printf(\"left:%d\\n\", leftIndex); //5 printf(\"right:%d\\n\", rightIndex); //7&#125;int main()&#123; int array[] = &#123;31, -41, 59, 26, -53, 58, 97, -93, -23, 84&#125;; int size = sizeof(array) / sizeof(int); findMostNear(array, size, 4);&#125; 2018-03-15更新上面该算法是错误的，该算法仅对于t==0有效。虽然cumsum是递增的，但是并不能保证相邻两项的差和t最接近。比如有cumsum3 7 25 78而此时t为22，显然应当[0..2]为最接近的差值（和22相差为0）。目前并没有想到更好的算法，除了i，j两层循环，导致n * n的时间 第九章顺序搜索在未排序的数组中搜索数值t的索引 书中给出了设置哨兵的算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;chrono&gt;#include &lt;string&gt;#define N 10000int find_normal(int arr[], int t)&#123; for(int i = 0; i &lt; N; ++i) &#123; if(arr[i] == t) return i; &#125; return -1;&#125;int find_with_guard(int arr[], int t)&#123; //设置哨兵 arr[N] = t; int i; for(i = 0;; ++i) if(arr[i] == t) break; if(i == N) return -1; return i;&#125;int main()&#123; //这里留一个位置给哨兵 int arr[N + 1]; for(int i = 0; i &lt; N; ++i) arr[i] = i; int index; auto start = std::chrono::system_clock::now(); index = find_normal(arr, N / 2); auto end = std::chrono::system_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"find normal, result:%d elapse time :%d microseconds\\n\", index, duration.count()); start = std::chrono::system_clock::now(); index = find_with_guard(arr, N / 2); end = std::chrono::system_clock::now(); duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"find with guard, result:%d elapse time :%d microseconds\\n\", index, duration.count()); return 0;&#125; 但是很奇怪，我本地，使用哨兵时算法并没有变快，尝试过t为10、N/2、N-1，下面是t为N/2的输出12find normal, result:5000 elapse time :19 microsecondsfind with guard, result:5000 elapse time :18 microseconds 不知道原因 变形二分搜索：查找数字t在数组中第一次出现的位置注意到标准的二分搜索，可能返回任意一个数字t的索引，不一定是第一个 解决方法 我最初始的想法 还是利用标准的二分搜索，但是搜索到索引之后，一直前递减，直到找到第一个和t 相等的索引。因为数组是排序的，所以理论上应该没问题。可能效率较差。 123456789101112131415161718int findfirst(int arr[], int x, int size)&#123; int l = 0, u = size - 1; while(l &lt;= u) &#123; int m = (l + u) &gt;&gt; 1; if(arr[m] == x) &#123; while(arr[--m] == x); return ++m; &#125; else if(arr[m] &gt; x) u = m - 1; else l = m + 1; &#125; return -1;&#125; 标准答案1伪代码123456789101112l = -1; u = nwhile l + 1 != u /*invariant: x[l] &lt; t &amp;&amp; x[u] &gt;= t &amp;&amp; l &lt; u*/ m = (l + u) / 2 if x[m] &lt; t l = m else u = m/* assert l + 1 = u &amp;&amp; x[l] &lt; t &amp;&amp; x[u] &gt;= t*/p = uif p &gt;= n || x[p] != t p = -1 理解一下标答 初始l和u为数组边界外的两个值 循环直到l比u小1– l和u的中间值比t小，则下界设为中间值– 否则（不小于t），则上界设为中间值 如此循环结束后，得到条件l + 1 = u，且x[l] &lt; t，且x[u] &gt;= t。则存在几种情况– 1、上限u超过返回不合法，即u = n, l = n - 1;此时未找到，返回-1– 2、上限u合法，则x[u] &gt;= t,若x[u]&gt;t则也未找到，返回-1；若x[u] = t,则有x[l]&lt; t，可得u是第一个等于t的位置 实现12345678910111213141516int findfirst_standard1(int arr[], int t, int size)&#123; int l = -1, u = size; while(l + 1 != u) &#123; int m = (l + u) &gt;&gt; 1; if(arr[m] &lt; t) l = m; else u = m; &#125; int p = u; if(p &gt;= size || arr[p] != t) p = -1; return p;&#125; 标准答案2伪代码12345678910111213141516i = 512l = -1if x[511] &lt; t l = 1000 - 512while i != 1 /* invariant: x[l] &lt; t &amp;&amp; x[l + i] &gt;= t &amp;&amp; i = 2^j*/ nexti = i / 2 if x[l + nexti] &lt; t l = l + nexti i = nexti else i = nexti/* assert i == 1 &amp;&amp; x[l] &lt; t &amp;&amp; x[l + i] &gt;= t*/p = l + 1if p &gt; 1000 || x[p] != t p = -1 需要利用到n = 1000的已知条件。不使用l..u来表示区间的上下限，而是使用 下限l，增量i来表示，其中l + i = u，并且i总是为2的幂 注意到一开始i为512（因为1024已经大于1000了），所以最开始的区间要么 为-1..511，要么为488..1000 该方案一般比较慢，只是作为引子 标准答案3对上面程序进行优化，删除遍历nexti 伪代码12345678910111213i = 512l = -1if x[511] &lt; t l = 1000 - 512while i != 1 /* invariant: x[l] &lt; t &amp;&amp; x[l + i] &gt;= t &amp;&amp; i = 2^j*/ i = i / 2 if x[l + i] &lt; t l += i/* assert i == 1 &amp;&amp; x[l] &lt; t &amp;&amp; x[l + i] &gt;= t*/p = l + 1if p &gt; 1000 || x[p] != t p = -1 实现123456789101112131415161718#define N 1000int findfirst_standard2(int arr[], int t)&#123; int i = 512; int l = -1; if(arr[i - 1] &lt; t) l = N - i; while(i != 1) &#123; i = i &gt;&gt; 1; if(arr[l + i] &lt; t) l += i; &#125; int p = l + 1; if(p &gt;= N || arr[p] != t) p = -1; return p;&#125; 注意倒数第三行我这里写成[ p &gt;= N ]而不是[ p &gt; N ]，理由如下： 比如原arr为0..999，而待查找值为1000，此时进过循环结束之后，l的值为488+256+..+2+1=999 所以p的值为1000，此时已经为非法越界所以，再去取arr[p]比较危险 不知道原书中的大于号是什么意思 标准答案4继续将while循环和除法优化掉，因为在N为1000的情况下，需要循环几次是已知的 伪代码12345678910111213l = -1if(x[511] &lt; t) l = 1000 - 512 /* assert x[l] &lt; t &amp;&amp; x[l + 512] &gt;= t*/if(x[l + 256] &lt; t) l += 235 /* assert x[l] &lt; t &amp;&amp; x[l + 256] &gt;= t*/if(x[l + 128] &lt; t) l += 128...if(x[l + 2] &lt; t) l += 2if(x[l + 1] &lt; t) l += 1 /* assert x[l] &lt; t &amp;&amp; x[l + 1] &gt;= t*/p = l + 1if p &gt; 1000 || x[p] != t p = -1 没有什么好说的，牺牲了简洁性而为了调优吧 宏和函数求最值性能比较123456789101112131415161718192021222324252627282930313233343536373839float max(float a, float b)&#123; return a &gt; b ? a : b;&#125;//返回数组0..n-1中的最大值，其中n最大为sizefloat arrmax(float arr[], int size, int n)&#123; if(n == 1) return -1; return max(arr[n - 1], arrmax(arr, size, n - 1));&#125;#define max_macro(a, b) ((a) &gt; (b) ? (a) : (b))float arrmax_macro(float arr[], int size, int n)&#123; if(n == 1) return -1; return max_macro(arr[n - 1], arrmax_macro(arr, size, n - 1));&#125;int main()&#123; const int size = 28; float arr[size]; for(int i = 0; i &lt; size; ++i) arr[i] = (size - i) * 1.0; auto start = std::chrono::system_clock::now(); printf(\"max:%f\\n\", arrmax(arr, size, 28)); auto end = std::chrono::system_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"func max elapse time :%d microseconds\\n\", duration.count()); start = std::chrono::system_clock::now(); printf(\"max:%f\\n\", arrmax_macro(arr, size, 28)); end = std::chrono::system_clock::now(); duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"macro max elapse time :%d microseconds\\n\", duration.count()); return 0;&#125; 输出1234max:27.000000func max elapse time :138 microsecondsmax:27.000000macro max elapse time :1341535 microseconds 真是说明宏在某些情况下性能不好的极致例子了。 书中说“一组按降序排列的值可以使算法的时间开销约为2n”。 这个没理解 习题7-求解数的二进制中1的个数参考求解整数二进制数中1的个数 习题8-查找数组元素的最大值分别使用普通方法，和哨兵方法比较了一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define N 10000int findMax_normal(int arr[])&#123; printf(\"%d\\n\", N); int max = arr[0], maxIndex = 0; for(int i = 1; i &lt; N; ++i) &#123; if(arr[i] &gt; max) &#123; maxIndex = i; max = arr[i]; &#125; &#125; return max;&#125;int findMax_guard(int arr[])&#123; int index = 0; int max; while(index &lt; N) &#123; max = arr[index]; arr[N] = max; index++; while(arr[index] &lt; max) index++; &#125; return arr[N];&#125;int main()&#123; int arr[N + 1]; for(int i = 0; i &lt; N / 2; ++i) arr[i] = i; for(int i = N / 2; i &lt; N; ++i) arr[i] = N - i; int max; auto start = std::chrono::system_clock::now(); max = findMax_normal(arr); auto end = std::chrono::system_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"findMax normal, result:%d elapse time :%ld microseconds\\n\", max, duration.count()); start = std::chrono::system_clock::now(); max = findMax_guard(arr); end = std::chrono::system_clock::now(); duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"findMax guard, result:%d elapse time :%ld microseconds\\n\", max, duration.count()); return 0;&#125; 输出如下12findMax normal, result:5000 elapse time :171 microsecondsfindMax guard, result:5000 elapse time :40 microseconds 可以看出使用哨兵方法，优化的还是比较大的 习题12有时会从数学的角度，而不是代码的角度考虑优化，比如为了计算下面多项式 y = anxn + an-1xn-1 + ..+a1x1 + a0123456789101112131415161718192021222324252627282930313233343536373839404142434445#define N 25long y_bad(int a[], int x)&#123; long y = a[0]; int xi = 1; for(int i = 1; i &lt;= N; ++i) &#123; xi *= x; y += a[i]*xi; &#125; return y;&#125;long y_good(int a[], int x)&#123; long y = a[N]; for(int i = N - 1; i &gt;= 0; --i) &#123; y = y * x + a[i]; &#125; return y;&#125;int main()&#123; int a[N + 1]; for(int i = 0; i &lt;= N; ++i) a[i] = i; long y; auto start = std::chrono::system_clock::now(); y = y_bad(a, 2); auto end = std::chrono::system_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"y_bad, result:%ld elapse time :%ld microseconds\\n\", y, duration.count()); start = std::chrono::system_clock::now(); y = y_good(a, 2); end = std::chrono::system_clock::now(); duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"y_good, result:%ld elapse time :%ld microseconds\\n\", y, duration.count()); return 0;&#125; 很遗憾，实际两者都很快，输出12y_bad, result:1610612738 elapse time :0 microsecondsy_good, result:1610612738 elapse time :0 microseconds 第10章10.2示例问题描述在地理数据库中存储2000个邻居，编号0..1999，输入x,y（范围都是0..199） 需要确定用户选中了2000个点中的哪个。 书中介绍三种实现 直接二维数组 列数组加链表的稀疏矩阵 列数组加并行数组的稀疏矩阵 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#define N 200//以下func(x, y)表示取第x列，y行数据//方法一：直接存储成二维数组，优点是简单，缺点是对于稀疏矩阵，存在巨大空间浪费void storeAsNormalArray(int x, int y)&#123; assert(x &lt; N &amp;&amp; y &lt; N); int array[N][N] = &#123;-1&#125;; //input array[0][2] = 17; array[0][5] = 538; array[3][4] = 965; array[5][3] = 1171; array[7][1] = 162; //output printf(\"%d\\n\", array[x][y]);&#125;//方法二：利用链表//使用数组表示所有的列，并使用链表来表示给定列中的活跃元素//表面上记录数据的节点少了，但实际上由于节点指针，malloc/new的消耗，可能导致空间增大struct Node&#123; int data_; unsigned char row_; Node *next_; Node(unsigned char row, int d = 0) : row_(row), data_(d), next_(nullptr) &#123;&#125;&#125;;void addData(Node *&amp;colhead, unsigned char row, int data)&#123; if(colhead == nullptr) colhead = new Node(0, 0); Node *p = colhead; while(p-&gt;next_) p = p-&gt;next_; p-&gt;next_ = new Node(row, data);&#125;void storeWithList(int x, int y)&#123; assert(x &lt; N &amp;&amp; y &lt; N); Node *colhead[N] = &#123;nullptr&#125;; //input addData(colhead[0], 2, 17); addData(colhead[0], 5, 538); addData(colhead[3], 4, 965); addData(colhead[5], 3, 1171); addData(colhead[7], 1, 62); //output for(Node *p = colhead[x]; p != nullptr; p = p-&gt;next_) &#123; if(p-&gt;row_ == y) &#123; printf(\"%d\\n\", p-&gt;data_); break; &#125; &#125; //release for(int i = 0; i &lt; N; ++i) &#123; Node *head = colhead[i]; if(head == nullptr) continue; Node *p = head, *q; while(p) &#123; q = p-&gt;next_; delete p; p = q; &#125; &#125;&#125;//方法三：不使用指针和结构//使用201元的数组来表示列，并用2000元的并行数组表示这些点#define NUMSIZE 2000void addData(int firstincol[], unsigned char row[], int pointnum[], int x, int y, int data)&#123; int curcol = firstincol[x + 1]; row[curcol] = y; pointnum[curcol] = data; for(int i = x + 1; i &lt;= N; ++i) firstincol[i] += 1;&#125;void storeWithColArray(int x, int y)&#123; int firstincol[N + 1] = &#123;0&#125;; int pointnum[NUMSIZE]; unsigned char row[NUMSIZE]; //input addData(firstincol, row, pointnum, 0, 2, 17); addData(firstincol, row, pointnum, 0, 5, 17); addData(firstincol, row, pointnum, 3, 4, 965); addData(firstincol, row, pointnum, 5, 3, 1171); addData(firstincol, row, pointnum, 7, 1, 162); //output //第i列的点由数组row和pointnum中位于firstincol[i]和firstincol[i+1]-1 //之间的元素表示 for(int k = firstincol[x]; k &lt; firstincol[x + 1]; ++k) &#123; if(row[k] == y) &#123; printf(\"%d\\n\", pointnum[k]); break; &#125; &#125;&#125;int main()&#123; storeAsNormalArray(5, 3); storeWithList(5, 3); storeWithColArray(5, 3); return 0;&#125; 两个对称矩阵的压缩描述Brian Kernighan编写了一个旅行商程序，给出如下共享存储空间方法。 有150×150的矩阵（分别为a,b），都是用来表示点与点之间的距离，从而知道他们有如下特点 对角线为0值，即a[i, i] = 0 矩阵是对称的，即a[i, j] = a[j, i] 使用如下方阵c来共享 123450 b[0, 1] b[0, 2]a[0, 1] 0 b[1, 2]a[2, 0] a[2, 1] 0 举例如下123 0 1 3 0 4 5 0 4 5a: 1 0 2 b: 4 0 6 c: 1 0 6 3 2 0 5 6 0 3 2 0 则可得 a[i, j] = c[max(i, j), min(i, j)]b[i, j] = c[min(i, j), max(i, j)] 比如 a[1, 2] = c[2, 1] , b[1, 2] = c[1, 2] 第11章-排序对比之前的文章:常见排序算法C++实现 插入排序呵，将打牌时排列手中的牌类比成插入排序，有意思 伪代码 12345for i = [1, n) t = x[i] for (j = i; j &gt; 0 &amp;&amp; x[j - 1] &gt; t; j--) x[j] = x[j - 1] x[j] = t 实现 1234567891011void insertSort(int arr[], int size)&#123; for(int i = 1; i &lt; size; ++i) &#123; int curdata = arr[i]; int j; for(j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; curdata; --j) arr[j] = arr[j - 1]; arr[j] = curdata; &#125;&#125; 快速排序 简单的 伪代码12345678910111213void qsort1(l, u) if(l &gt;= u) return m = l for i = [l + 1, u] /* invariant: x[l+1..m] &lt; x[l] &amp;&amp; x[m+1..i-1] &gt;= x[l]*/ if(x[i] &lt; x[l]) swap(++m, i) swap(l, m) /* x[l..m-1] &lt; x[m] &lt;= x[m+1..u]*/ qsort(l, m - 1) qsort(m + 1, u) 实现123456789101112void qsort1(int arr[], int l, int u)&#123; if(l &gt;= u) return; int m = l; for(int i = l + 1; i &lt;= u; ++i) if(arr[i] &lt; arr[l]) swap(arr[++m], arr[i]); swap(arr[m], arr[l]); qsort1(arr, l, m - 1); qsort1(arr, m + 1, u);&#125; 其实和之前文章中的快排方法1是对应的。 对于随机输入，这种快速排序算法很快，但他也存在一个致命的问题，当输入是数组是全部相等的，则需要O(n2)时间。 原因很简单，上面的for循环里，if条件一次都不满足。 使用哨兵优化上面的快排书中有两个提示：1、使用x[l]作为哨兵；2、移除循环后的swap 看到这个说法时，我的想法12345678910111213141516void qsort2(int arr[], int l, int u)&#123; if(l &gt;= u) return; //不同点1、记录哨兵值 int hold = arr[l]; int m = l; for(int i = l + 1; i &lt;= u; ++i) //不同点2、待比较值不再是arr[l]，该值可能变化了 if(arr[i] &lt; hold) //不同点3、m使用后置自增 swap(arr[m++], arr[i]); //不同点4、这里不再进行swap。循环退出后到了这里，m指向不比hold小的值 qsort2(arr, l, m - 1); qsort2(arr, m + 1, u);&#125; 使用{1, 2, .. ,7}、{7, 6..1}、{3, 1, 2, 4, 7, 5, 6}测试都OK，正确性待验证 书中标准答案如下： 划分方案改为从右往左伪代码1234m = u + 1for(i = u; i &gt;= l; i--) if x[i] &gt;= t swap(--m, i) 循环终止时，即i为l时，x[i] &gt;= t成立，所以x[m]会被置为t，这样就不再需要额外的swap啦 使用x[l]作为哨兵伪代码 可以省去内循环中的一次测试 123456m = i = u + 1do while x[--i] &lt; t ; swap(--m, i)while i != l 实现123456789101112131415void qsort2(int arr[], int l, int u)&#123; if(l &gt;= u) return; int m = u + 1, i = u + 1; int t = arr[l]; do &#123; while(arr[--i] &lt; t); swap(arr[--m], arr[i]); &#125; while(i != l); qsort2(arr, l, m - 1); qsort2(arr, m + 1, u);&#125; 双向划分 伪代码12345678910111213void qsort3(l, u) if l &gt;= u return t = x[l]; i = l; j = u + 1 loop do i++ while i &lt;= u &amp;&amp; x[i] &lt; t do j-- while x[j] &gt; t if i &gt; j break swap(i, j) swap(l, j) qsort3(l, j - 1) qsort3(j + 1, u) 真是精妙无比，几个注意点– j从u + 1开始，因为do..while，先做j–– x[i],x[j]与t比较时都是绝对的大于小于。如果用了&gt;=或&lt;=会怎么样？ 如果数组值全部相等 1、将x[i] &lt; t改成x[i] &lt;= t，第一个do..while之后i等于u+1，第二个do..while第一次 就不满足，所以j等于u，走break，走qsort3(l, u-1)，这样整个复杂的为O(n2) 2、将x[j] &lt; t改成x[j] &lt;= t，第二个do..while不能正确地退出，原因参考下一条说明– 为什么第二个do..while，不需要j &gt;= l这样的判断？因为x[l] == t，所以x[l] 充当了哨兵的作用，无论如何，程序最差也会在j == l的时候退出，不会导致死循环 这么来看的话，前一篇文章中的快排都没有很好地考虑元素全相等的情况 结合插入排序再优化1234567891011121314void qsort4(l, u) if u - l &lt; cutoff return swap(l, randint(l, u)) i = l, j = u + 1, t = x[l] loop do i++ while i &lt;= u &amp;&amp; x[i] &lt; t do j-- while x[j] &gt; t if i &gt; j break temp = x[i]; x[i] = x[j]; x[j] = t swap(l, j) qsort4(l, j - 1) qsort4(j + 1, u) 然后程序结束之后再调用插入排序12qsort4(0, n - 1)isort() 参考书中习题，cutoff取50是个比较合理的值 第12章两个常用函数 bigrand()C库函数rand()通常返回15个随机位（最大值RAND_MAX 为32767），要求返回30个随机位 1234int bigrand()&#123; return rand() * RAND_MAX + rand();&#125; randint(l, u)返回l和u之间的随机值（包括l和u） 1234int randint(int l, int u)&#123; return l + bigrand() % (u - l + 1);&#125; 题目1：输出随机有序列表输入两个整数m和n，其中m &lt; n。输出是0~n-1范围内m个随机整数的有序列表，不允许重复 方案一 依次考虑整数0,1,2,…,n-1，并通过适当的随机测试对每个整数进行选择；通过按序进行 – 伪代码1234567select = mremaining = nfor i = [0, n) if (bigrand() % remaining) &lt; select print i select-- remaining-- 只要m&lt;=n，程序输出的整数就恰好为m个，因为1、不会选择更多的整数，因为select变为0时，if条件就永远为false了2、不会选择更好的数，因为当remaining == select时，if条件为true – 实现123456789101112void randseries1(int m, int n)&#123; assert(m &lt;= n); for(int i = 0; i &lt; n; ++i) &#123; if((bigrand() % (n - i)) &lt; m) &#123; printf(\"%d \", i); --m; &#125; &#125;&#125; – 存在问题很明显程序运行时间正比于n，当n很大，m很小时，存在较大浪费 方案二在初始为空的集合里插入随机整数，直到个数足够 – 伪代码12345678initialize set S to emptysize = 0while size &lt; m do t = bigrand() % n if t is not in S insert t into S size++print the elements of S in sorted order C++ stl里的set正好符合当前的需求。set有两个特点：1、不存在重复元素2、元素自动排序 – 实现12345678910111213#include &lt;set&gt;void randseries2(int m, int n)&#123; assert(m &lt;= n); std::set&lt;int&gt; s; while(s.size() != m) &#123; s.insert(bigrand() % n); &#125; for(auto i : s) printf(\"%d \", i);&#125; – 存在问题空间开销比较大。需要将全部m个数存储在一个set中，当m较大时，需要很多额外空间 方案三把包含0~n-1个整数的数组顺序打乱，把前m个元素排序输出 – 实现123456789101112131415161718#include &lt;algorithm&gt;void randseries3(int m, int n)&#123; assert(m &lt;= n); int i, j; int *x = new int[n]; for(i = 0; i &lt; n; ++i) x[i] = i; for(i = 0; i &lt; m; ++i) &#123; j = randint(i, n - 1); int t = x[i]; x[i] = x[j]; x[j] = t; &#125; std::sort(x, x + m); for(i = 0; i &lt; m; ++i) printf(\"%d \", x[i]); delete []x;&#125; 还是比较好理解的 建立长度为n的临时数组，并赋值为0~n-1 i从0到m-1循环，并从i到n-1之间随机出一个索引。将该索引与i对应的值交换 此时0~m-1之间的值是乱序的随机值，排序之后输出 但是性能通常不如方案一 习题 题目7递归方式输出顺序随机整数 伪代码12345678910void randselect(m, n) pre 0 &lt;= m &lt;= n post m distinct integers from 0..n-1 are printed in decreasing order if m &gt; 0 if (bigrand() % n) &lt; m print n - 1 randselect(m - 1, n - 1) else randselect(m, n - 1) 按照伪代码实现123456789101112void randselect1(int m, int n)&#123; if(m &lt;= 0 || m &gt; n) return; if(bigrand() % n &lt; m) &#123; printf(\"%d \", n - 1); randselect1(m - 1, n - 1); &#125; else randselect1(m, n - 1);&#125; 书中问题 该方法是降序排列，如何使得按升序输出我的想法123456789101112void randselect2(int m, int begin, int n)&#123; if(m &lt;= 0 || begin &gt;= n) return; if((bigrand() % (n - begin)) &lt; m) &#123; printf(\"%d \", begin); randselect2(m - 1, begin + 1, n); &#125; else randselect2(m, begin + 1, n);&#125; 简单测试了一下应该是对的，但是真的太丑陋了啊 标准答案：只要将printf和randselect对调位置就行了，这其实是最简单的递归原理举个最简单无聊的例子12345678910111213141516//逆序输出n..1void printn(int n)&#123; if(n &lt;= 0) return; printf(\"%d \", n); printn(n - 1);&#125;//顺序输出1..nvoid printn1(int n)&#123; if(n &lt;= 0) return; printn1(n - 1); printf(\"%d \", n);&#125; 利用该程序结构生成0..n-1的所有m元子集书中没有给出答案，原来这还是一个经典的算法题 我的做法123456789101112131415161718192021222324252627//m表示剩余选择的个数//begin表示从第几个开始选//n表示数组总长度，是固定不动的void selectm(int m, int begin, int n, std::set&lt;int&gt; s)&#123; //m为1时，表示从剩下的数中选择一个 if(m == 1) &#123; for(int i = begin; i &lt; n; ++i) &#123; //set里保存了前m-1个数 for(int j : s) printf(\"%d \", j); printf(\"%d\\n\", i); &#125; return; &#125; else if(n - begin &gt;= m) &#123; for(int i = begin; i &lt;= n - m; ++i) &#123; s.insert(i); //测试选择i的情况 selectm(m - 1, i + 1, n, s); s.erase(i); //测试完成之后需要删除i，从而后面选择i+1... &#125; &#125;&#125; 2018-03-15更新修改为如下，可能更清晰一些12345678910111213141516171819//在[begin..n-1]之间选择m个数void selectm(int m, int begin, int n, std::set&lt;int&gt; &amp;s)&#123; if(m == 0) &#123; for(int i : s) printf(\"%d \", i); printf(\"\\n\"); return; &#125; if(n - begin &lt; m) return; //剩下的数不够选了 for(int i = begin; i &lt; n; ++i) &#123; s.insert(i); selectm(m - 1, i + 1, n, s); s.erase(i); &#125;&#125; 经测试，selectm(4, 0, 7, s)的结果如下12345678910111213141516171819202122232425262728293031323334350 1 2 30 1 2 40 1 2 50 1 2 60 1 3 40 1 3 50 1 3 60 1 4 50 1 4 60 1 5 60 2 3 40 2 3 50 2 3 60 2 4 50 2 4 60 2 5 60 3 4 50 3 4 60 3 5 60 4 5 61 2 3 41 2 3 51 2 3 61 2 4 51 2 4 61 2 5 61 3 4 51 3 4 61 3 5 61 4 5 62 3 4 52 3 4 62 3 5 62 4 5 63 4 5 6 数目为35（Cnm=n!/(m! * (n - m)!)）个，应该是对的，只是还不够优雅。 为了便于理解，通过在首行加上相应log，相应输出如下1234567891011121314151617181920212223242526272829303132333435m:4, begin:0, n:7, cur set : //已选择数为空，从0~6选择4个数m:3, begin:1, n:7, cur set :0 //已选择数字0，从1~6选择3个数m:2, begin:2, n:7, cur set :0 1 //已选择数字0,1，从2~6选择2个数m:1, begin:3, n:7, cur set :0 1 2 //已选择数字0,1,2，从3~6选择1个数m:1, begin:4, n:7, cur set :0 1 3 //已选择数字0,1,3，从4~6选择1个数m:1, begin:5, n:7, cur set :0 1 4 //已选择数字0,1,4，从5~6选择1个数m:1, begin:6, n:7, cur set :0 1 5 //已选择数字0,1,5，从6~6选择1个数m:2, begin:3, n:7, cur set :0 2 //已选择数字0,2，从3~6选择2个数m:1, begin:4, n:7, cur set :0 2 3 //下同，不在赘述m:1, begin:5, n:7, cur set :0 2 4m:1, begin:6, n:7, cur set :0 2 5m:2, begin:4, n:7, cur set :0 3m:1, begin:5, n:7, cur set :0 3 4m:1, begin:6, n:7, cur set :0 3 5m:2, begin:5, n:7, cur set :0 4m:1, begin:6, n:7, cur set :0 4 5m:3, begin:2, n:7, cur set :1m:2, begin:3, n:7, cur set :1 2m:1, begin:4, n:7, cur set :1 2 3m:1, begin:5, n:7, cur set :1 2 4m:1, begin:6, n:7, cur set :1 2 5m:2, begin:4, n:7, cur set :1 3m:1, begin:5, n:7, cur set :1 3 4m:1, begin:6, n:7, cur set :1 3 5m:2, begin:5, n:7, cur set :1 4m:1, begin:6, n:7, cur set :1 4 5m:3, begin:3, n:7, cur set :2m:2, begin:4, n:7, cur set :2 3m:1, begin:5, n:7, cur set :2 3 4m:1, begin:6, n:7, cur set :2 3 5m:2, begin:5, n:7, cur set :2 4m:1, begin:6, n:7, cur set :2 4 5m:3, begin:4, n:7, cur set :3m:2, begin:5, n:7, cur set :3 4m:1, begin:6, n:7, cur set :3 4 5 网上别人的做法，参考：链接123456789101112131415161718192021222324252627int selectm(int m, int n)&#123; int *state = new int[m]; for(int i = 0; i &lt; m; ++i) state[i] = i; int count = 1; for(int i = 0; i &lt; m; ++i) printf(\"%d \", state[i]); printf(\"\\n\"); int npos = m - 1; while(state[0] &lt; n - m) &#123; if(state[m - 1] == n - 1) --npos; else npos = m - 1; state[npos]++; for(int i = npos + 1; i &lt; m; ++i) state[i] = state[i - 1] + 1; for(int i = 0; i &lt; m; ++i) printf(\"%d \", state[i]); printf(\"\\n\"); ++count; &#125; delete []state; return count;&#125; 也不是很优雅 题目9上面方案二基于集合的算法，当m接近于n时，生成的很多随机数都要丢掉，因为他们已经存在于集合中。Bob Floyd给出，在最坏情况下，也只需要生成m个随机数的算法 123456789101112131415void randseries4(int m, int n)&#123; std::set&lt;int&gt; s; for(int i = n - m; i &lt; n; ++i) &#123; int t = bigrand() % (i + 1); if(s.find(t) == s.end()) s.insert(t); // t is not in s else s.insert(i); // t in s &#125; for(int i : s) printf(\"%d \", i); printf(\"\\n\");&#125; 题目10如何从n个对象（可以依次看到这n个对象，但事先不知道n的值）中随机选择一个具体来说，如何在事先不知道文本文件行数的情况下读取该文件，从中速记选择并输出一行 思路总选择（以100%概率）第1行以概率1/2选择第2行（如果有的话）以概率1/3选择第3行（如果有的话）..如此结束后，每一行的选中概率都是相等的（1/n，n是文件的总行数） 伪代码 12345i = 0while more input lines with probability 1.0 / ++i choice = this input lineprint choice 实现 12345678910111213141516#include &lt;fstream&gt;#include &lt;string&gt;void printFileLine(const char *fname)&#123; std::ifstream in(fname); int i = 0; char line[50]; char choice[50]; while(!in.eof()) &#123; in &gt;&gt; line; if((bigrand() % (++i)) &lt; 1) strcpy(choice, line); &#125; printf(\"choice:%s\\n\", choice);&#125; 第13章本章讲搜索，主要讨论上一章的问题：生成[0, maxval]内m个随机整数生成，保存到集合中，该集合IntSet的实现方法。包含有序集合的创建，插入，遍历等。 通用接口如下：12345678class IntSetImp&#123; public: IntSetImp(int maxelements, int maxval); void insert(int t); int size(); void report(int *v);&#125; 其中，构造参数分别表示集合元素的最大个数和集合元素的最大值（加1）；insert函数向集合中添加一个新的整数（如果已存在就忽略）；size返回当前元素个数；report将元素写入向量v中。 实现方式有以下几种 利用标准库set 数组 链表 二叉搜索树 位向量 箱下面，一一实现一下 使用标准模板库set12345678910111213141516class IntSetSTL&#123;public: IntSetSTL(int maxelements, int maxval) &#123;&#125; void insert(int t) &#123; s.insert(t); &#125; int size() const &#123; return s.size(); &#125; void report(int *v) const &#123; int i = 0; //书中使用迭代器遍历，这里用C++11新特性 for(int data : s) v[i++] = data; &#125;private: std::set&lt;int&gt; s;&#125;; 优点简单清晰，但是时间空间效率都不高 使用数组123456789101112131415161718192021222324252627282930313233343536373839404142434445class IntSetArr&#123;public: IntSetArr(int maxelements, int maxval) &#123; arr_ = new int[1 + maxelements]; n_ = 0; //哨兵元素，放置在已排序元素的最后（maxval比集合中任何元素都大） //下面的insert利用了该哨兵 arr_[0] = maxval; &#125; ~IntSetArr() &#123; delete []arr_; &#125; //书中insert实现 void insert(int t) &#123; int i; for(i = 0; arr_[i] &lt; t; ++i) ; if(arr_[i] == t) //元素已存在 return; for(int j = n_; j &gt;= i; --j) arr_[j + 1] = arr_[j]; arr_[i] = t; n_++; &#125; //我本想实现成下面这样类似于插入排序的更简单的方式 //但这种方式不好避免元素出现重复的情况，要加很多判断，很啰嗦 void insert1(int t) &#123; int i; for(i = n_; i &gt; 0 &amp;&amp; arr_[i - 1] &gt; t; --i) arr_[i] = arr_[i - 1]; arr_[i] = t; n_++; &#125; int size() const &#123; return n_; &#125; void report(int *v) const &#123; for(int i = 0; i &lt; n_; ++i) v[i] = arr_[i]; &#125;private: int n_; int *arr_;&#125;; 在已知set大小的情况下，使用数组还比较合理。但是插入元素时，需要移动的元素比较多。 注意上面的insert方法 使用链表在集合大小未知的情况下，链表是首选，而且插入元素开销较小（不需要移动）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class IntSetList&#123;public: IntSetList(int maxelements, int maxval) &#123; n_ = 0; //sentinel_始终指向最大元素节点 //head_始终指向头结点(也是有效的数据节点) sentinel_ = head_ = new Node(maxval); &#125; ~IntSetList() &#123; Node *p = head_, *q; while(p) &#123; q = p-&gt;next_; delete p; p = q; &#125; &#125; int size() const &#123; return n_; &#125; //书中递归版 void insert(int t) &#123; head_ = rinsert(head_, t); &#125; //自写迭代版 void insert1(int t) &#123; Node *p = head_, *q = head_; while(p != sentinel_ &amp;&amp; p-&gt;data_ &lt; t) &#123; //q始终指向p的前一个（如果有的话） q = p; p = p-&gt;next_; &#125; //循环结束之后，p指向的data应当&gt;=t //如果==t，则已存在，返回 if(p-&gt;data_ == t) return; n_++; //如果p指向的是头结点，即待插入的节点值是最小的 //则需要将新建节点赋值给head if(p == head_) head_ = new Node(t, p); else q-&gt;next_ = new Node(t, q-&gt;next_); &#125; void report(int *v) const &#123; int i = 0; //for(Node *p = head_-&gt;next_; p != nullptr; p = p-&gt;next_) for(Node *p = head_; p != sentinel_; p = p-&gt;next_) v[i++] = p-&gt;data_; &#125;private: int n_; struct Node &#123; int data_; Node *next_; Node(int data = 0, Node *next = nullptr) : data_(data), next_(next) &#123;&#125; &#125;; Node *head_, *sentinel_; Node *rinsert(Node *p, int t) &#123; if(p-&gt;data_ &lt; t) p-&gt;next_ = rinsert(p-&gt;next_, t); else if(p-&gt;data_ &gt; t) &#123; p = new Node(t, p); n_++; &#125; return p; &#125;&#125;; 也比较好理解，需要注意的是insert函数，分别实现了递归版和迭代版，显然递归版更加清晰一些。 使用二分搜索树参考二叉查找树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class IntSetBST&#123;public: IntSetBST(int maxelements, int maxval) &#123; root_ = nullptr; n_ = 0; &#125; int size() const &#123; return n_; &#125; //书中递归版本 void insert(int t) &#123; rinsert(t, root_); &#125; //自写迭代版本 void insert1(int t) &#123; if(root_ == nullptr) &#123; root_ = new Node(t); n_++; return; &#125; Node *p = root_, *q = root_; bool isleft = true; while(p) &#123; if(t == p-&gt;data_) return; //相等，不插入 //q始终指向p的父节点（如果有的话） q = p; if(t &lt; p-&gt;data_) &#123; p = p-&gt;left_; isleft = true; &#125; else &#123; p = p-&gt;right_; isleft = false; &#125; &#125; n_++; if(isleft) q-&gt;left_ = new Node(t); else q-&gt;right_ = new Node(t); &#125; void report(int *v) const &#123; traverse(v, root_); &#125;private: struct Node &#123; int data_; Node *left_, *right_; Node(int data=0, Node *left=nullptr, Node *right=nullptr) : data_(data), left_(left), right_(right) &#123;&#125; &#125;; Node *root_; int n_; //和书中略有不同，书中rinsert有返回值，从而Node *p不需要使用引用参数 //本质是一样的 void rinsert(int t, Node *&amp;p) &#123; if(!p) &#123; p = new Node(t); n_++; &#125; else if(t &lt; p-&gt;data_) rinsert(t, p-&gt;left_); else if(p-&gt;data_ &lt; t) rinsert(t, p-&gt;right_); &#125; //和书中略有不同，书中使用成员变量索引vn //每次访问索引vn自增，从而不需要传递数组指针参数 void traverse(int *&amp;v, Node *p) const &#123; if(!p) return; traverse(v, p-&gt;left_); *v++ = p-&gt;data_; traverse(v, p-&gt;right_); &#125;&#125;; 二分搜索树支持快速插入和搜索。 之前这几个数据结构都是比较好想的，下面的才是真正快速的，前方高能。 使用位向量位向量的妙用在第一章已经见识过了1234567891011121314151617181920212223242526272829303132333435363738class IntSetBitVec&#123;public: IntSetBitVec(int maxelements, int maxval) &#123; hi_ = maxval; n_ = 0; arr_ = new int[1 + hi_ / BITSPERWORD]&#123;0&#125;; //书中这里还加上了clr处理，但我觉得这是不必要的 //因为new int[n]&#123;0&#125;，已经将每一项置为0了 &#125; ~IntSetBitVec() &#123; delete []arr_; &#125; int size() const &#123; return n_; &#125; void insert(int t) &#123; if(test(t)) return; set(t); n_++; &#125; void report(int *v) &#123; int j = 0; for(int i = 0; i &lt; hi_; ++i) &#123; if(test(i)) v[j++] = i; &#125; &#125;private: enum &#123;BITSPERWORD = 32, SHIFT = 5, MASK = 0x1F&#125;; void set(int i) &#123; arr_[i &gt;&gt; SHIFT] |= (1 &lt;&lt; (i &amp; MASK)); &#125; void clr(int i) &#123; arr_[i &gt;&gt; SHIFT] &amp;= ~(1 &lt;&lt; (i &amp; MASK)); &#125; int test(int i) &#123; return arr_[i &gt;&gt; SHIFT] &amp; (1 &lt;&lt; (i &amp; MASK)); &#125; int n_; int hi_; int *arr_;&#125;; 完美的利用了位向量的特点，相对于纯数组来说，存储空间大大减小。但是对于最大值很大的情况，存储空间消耗依然非常严重，比如要在232个数中选择两个，所需要的数组长度竟然是1+227，这显然是巨大的浪费 使用箱序列箱，听名字感觉好高大上，其实就是就是结合了链表和位向量。怎么理解？比如要在0~99范围内选择4个整数，则需要4个箱： 箱0表示 0~24范围内的整数 箱1表示25~49范围内的整数 箱2表示50~74范围内的整数 箱3表示75~99范围内的整数如果选出的4个数正好分别落在4个区间内，则每个箱正好有1个整数。可是如果选出的数是{20, 31, 41, 59}呢，那么箱1就需要表示两个整数（用链表表示），箱3表示0个整数 但是由于整数是均匀分别的，索引每个链表的期望长度都为1。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class IntSetBins&#123;public: IntSetBins(int maxelements, int maxval) &#123; maxval_ = maxval; //表示有多少个箱子 bins_ = maxelements; //指针数组，每个成员指向每个箱子的头结点 bin = new Node*[maxelements]; sentinel_ = new Node(maxval); //每个箱子的头结点初始化为哨兵节点 for(int i = 0; i &lt; bins_; ++i) bin[i] = sentinel_; n_ = 0; &#125; int size() const &#123; return n_; &#125; void insert(int t) &#123; //接下来就需要映射了，类似于位向量那样，将t映射到某个箱子 int i = t /(1 + maxval_ / bins_); //书中说如下映射会带来麻烦，还没理解 //int i = t * bins / maxval_; bin[i] = rinsert(bin[i], t); &#125; void report(int *v) &#123; int j = 0; for(int i = 0; i &lt; bins_; ++i) &#123; for(Node *p = bin[i]; p != sentinel_; p = p-&gt;next_) v[j++] = p-&gt;data_; &#125; &#125;private: int n_, bins_; int maxval_; struct Node &#123; int data_; Node *next_; Node(int data = 0, Node *next = nullptr) : data_(data), next_(next) &#123;&#125; &#125;; Node **bin, *sentinel_; //类似于纯链表的情况 Node *rinsert(Node *p, int t) &#123; if(p-&gt;data_ &lt; t) p-&gt;next_ = rinsert(p-&gt;next_, t); else if(p-&gt;data_ &gt; t) &#123; p = new Node(t, p); n_++; &#125; return p; &#125;&#125;; 还是比较好理解的，其实总结而言就一句：将单纯的链表映射到各个箱的分散的单链表中。由于数据分散的特点，每个单链表长度期望为1 习题 题目4实现链表、箱、二分搜索树插入的迭代版本 链表的插入迭代版本我自己的实现参考上面的，书中给出两种实现实现1123456789101112131415161718192021void insert(int t)&#123; //head节点值等于带插入节点值，返回 if(head_-&gt;data_ == t) return; //head节点值比待插入节点大，则新增节点要设为head if(head_-&gt;data_ &gt; t) &#123; head_ = new Node(t, head_); n_++; return; &#125; Node *p; for(p = head_; p-&gt;next_-&gt;data_ &lt; t; p = p-&gt;next_) ; //循环结束之后p的下一个节点的值&gt;=t if(p-&gt;next_-&gt;data_ == t) return; p-&gt;next_ = new Node(t, p-&gt;next_); n_++;&#125; 使用指向指针的指针来去除重复12345678910void insert(int t)&#123; Node **p; for(p = &amp;head_; (*p)-&gt;data_ &lt; t; p = &amp;((*p)-&gt;next_)); ; if((*p)-&gt;data_ == t) return; n_++; *p = new Node(t, *p);&#125; 这段代码还是比较精妙的，为什么使用指针的指针就可以消除重复了？来看几种情况一开始链表为空，head指向最大元素200. 这时插入元素100，则for循环一次不走退出；p为指向head的指针 则最后一个赋值语句等价于head = new Node(t, head)，成功赋值头结点. 再插入元素90，等价于上面的情况. 再插入元素95，for循环退出时，p为指向节点100的指针。 最后一个赋值语句，将原本的节点100，修改成了节点95，并且节点95的下一个节点为节点100，则插入完成 题目7使用哨兵节点和整块申请内存，优化二叉搜索树 题目9用低开销的逻辑移位替代高开销的除法运算。 第14章本章主要讲堆，参考 优先队列（堆） 堆排序 结合两本书所述，再给出堆排序算法（index从0开始）12345678910111213141516171819202122232425262728293031323334353637void siftdown(int arr[], int size, int hole)&#123; int child; int t = arr[hole]; for(;hole &lt;= size / 2 - 1; hole = child) &#123; child = 2 * hole + 1; if(child &lt; size - 1 &amp;&amp; arr[child + 1] &gt; arr[child]) child++; if(arr[child] &gt; t) arr[hole] = arr[child]; else break; &#125; arr[hole] = t;&#125;void swap(int &amp;a, int &amp;b)&#123; if(a == b) return; a = a ^ b; b = a ^ b; a = a ^ b;&#125;void hsort(int arr[], int size)&#123; //build heap for(int i = size / 2 - 1; i &gt;= 0; --i) siftdown(arr, size, i); for(int i = size - 1; i &gt; 0; --i) &#123; swap(arr[0], arr[i]); siftdown(arr, i, 0); &#125;&#125; 第15章单词主要比较了C++标准库map/set和直接写C散列表的性能区别，参考散列表 短语 查找字符串中最长重复子字符串例如”Ask not what your country can do for you, but what you can do for your country”，中最长的重复字符串是”can do for you”，第二长的是”your country” 看到这道题，我最初的想法 从最长的子串（长度为size-1）到最短的子串（长度为1）循环，找到则退出，则退出时找到的子串就是最长的 以查找长度为len的子串为例，从首字母开始的子串开始，将每一个子串放到一个set中，如果set中已经包含该子串，则表示子串重复 123456789101112131415161718192021void findMaxDuplicate(const std::string &amp;src)&#123; int size = src.size(); std::set&lt;std::string&gt; substrs; for(int len = size - 1; len &gt;= 1; --len) &#123; substrs.clear(); for(int i = 0; i &lt;= size - len; ++i) &#123; std::string subs = src.substr(i, len); if(substrs.find(subs) != substrs.end()) &#123; std::cout &lt;&lt; \"max sub is: \" &lt;&lt; subs &lt;&lt; std::endl; return; &#125; else substrs.insert(subs); &#125; &#125; std::cout &lt;&lt; \"max sub is empty\" &lt;&lt; std::endl;&#125; 测试了一下结果应该是对的，但有两个缺点 太依赖标准库set、string 题目的意思应该是重复的单词，而按这种方式求出来的前后可能带有空格，想要trim还有点麻烦 书中算法一：最直接的算法就是强行遍历每一个子串伪代码12345678910111213maxlen = -1for i = [0, n) for j = (i, n) if (thislen = comlen(&amp;c[i], &amp;c[j])) &gt; maxlen maxlen = thislen maxi = i maxj = j//comlen原型int comlen(char *p, char *q) i = 0 while *p &amp;&amp; (*p++ == *q++) i++ return i 一个注意点：while循环是不需要同时判断p和q不指向’\\0’的（后一个相等性判断已经保证），多写浪费实现123456789101112131415161718192021222324252627void findMaxDuplicate2(const char *src)&#123; int size = strlen(src), maxlen = -1, maxi = 0, maxj = 0, thislen = 0; for(int i = 0; i &lt; size; ++i) &#123; for(int j = i + 1; j &lt; size; ++j) &#123; if((thislen = comlen(src + i, src + j)) &gt; maxlen) &#123; maxlen = thislen; maxi = i; maxj = j; printf(\"maxlen:%d, maxi:%d, maxj:%d\\n\", thislen, i, j); &#125; &#125; &#125; if(maxlen != -1) &#123; printf(\"max sub is: \"); for(int i = 0; i &lt; maxlen; ++i) printf(\"%c\", src[maxi+ i]); printf(\"\\n\"); &#125; else printf(\"max sub is empty\\n\");&#125; 很明显，效率也比较低 书中算法二：使用后缀数组 什么是后缀数组？假设有字符串char c[] = “banana”;和字符指针数组char * a[];令a[0] = &amp;c[0], a[1] = &amp;c[1], a[2] = &amp;c[2]…则a中每个字符串指向的字符串分别为a[0] : bananaa[1] : ananaa[2] : nanaa[3] : anaa[4] : naa[5] : a数组a中的指针包含了字符串中的每一个后缀，因此称为后缀数组。从为文件中读取字符串时，可以这样初始化a和c12345678910111213#define MAXN 5000000char c[MAXN], *a[MAXN];int init()&#123; int n = 0; char ch; while((ch = getchar()) != EOF) &#123; a[n] = &amp;c[n]; c[n++] = ch; &#125; c[n] = '\\0';&#125; 执行指令(参考第二章中的做法)test.exe &lt; in.txt &gt; out.txt 排序数组a如果某个字符串在数组c中出现两次，那么他将出现在两个不同的后缀中，因此对数组排序以寻找相同的后缀（参考2.4），以”banana”为例，排序后a为a[0] : aa[1] : anaa[2] : ananaa[3] : bananaa[4] : naa[5] : nana这样就可以扫描a，比较相邻元素来找出最长的重复字符串 ** 小插曲：使用qsort排序字符串数组和字符指针数组的不同参考qsort用法字符串数组1234567891011int arrstrcmp(const void *x, const void *y)&#123; //这里传入的每个x类型其实为字符串数组类型，所以强转为char*即可 return strcmp((char *)x, (char *)y);&#125;static const int n = 6;char s[n][7] = &#123;\"banana\", \"anana\", \"nana\", \"ana\", \"na\", \"a\"&#125;;//打印typeid(s[0])可知，s[0]的类型为char[7]，长度自然为7qsort(s, n, sizeof(s[0]), arrstrcmp);//a, ana, anana, banana, na, nana 这其中应该有不少字符串拷贝，消耗较大 字符串指针数组123456789int pstrcmp(const void *x, const void *y)&#123; //这里传过来的每一项应该是字符串指针 return strcmp(*(char **)x , *(char **)y);&#125;char *s[n] = &#123;\"banana\", \"anana\", \"nana\", \"ana\", \"na\", \"a\"&#125;;//打印typeid(s[0])可知，s[0]的类型为char*，长度为1qsort(s, n, sizeof(s[0]), pstrcmp); 这其中应该只是指针的变化，消耗较小 由上面的讨论可知，本例中的数组a显然是后一种类型 扫描数组a，查找相邻元素的重复字符串1234567891011//扫描数组a int maxlen = -1, maxi = 0, thislen = 0; for(int i = 0; i &lt; n - 1; ++i) &#123; if((thislen = comlen(a[i], a[i + 1])) &gt; maxlen) &#123; maxlen = thislen; maxi = i; &#125; &#125; printf(\"max sub is %.*s\\n\", maxlen, a[maxi]); 注意点：可以在printf语句使用” * “精度输出字符串maxlen个字符。闻所未闻啊！！ 查找不包含重复字符的最长子串这个是想到的之前遇到的一个面试题，和本章其实没什么关系，只是题目名字有点相似例如”abcbcdeda”，则最长子串为”bcde” 12345678910111213141516171819202122232425262728293031323334353637383940//check src[begin..end] has the same char with chbool contains(const char *src, int begin, int end, char ch)&#123; for(int i = begin; i &lt;= end; ++i) if(src[i] == ch) return true; return false;&#125;void findMaxSub(const char *src)&#123; int size = strlen(src); if(size == 0) &#123; printf(\"str is empty\\n\"); return; &#125; int maxlen = 1, thislen, maxi = 0; for(int i = 0; i &lt; size - 1; ++i) &#123; thislen = 1; int j = i; while(j &lt; size - 1 &amp;&amp; !contains(src, i, j, src[j + 1])) &#123; j++; if(j - i + 1 &gt; maxlen) &#123; maxlen = j - i + 1; maxi = i; &#125; &#125; &#125; printf(\"max substr:%.*s\\n\", maxlen, src + maxi); &#125;findMaxSub(\"abcbcdedacgb\"); //edacgbfindMaxSub(\"bcad\"); //bcadfindMaxSub(\"abcadc\"); //bcadfindMaxSub(\"aaaa\"); //afindMaxSub(\"\"); //str is empty 效率不甚高啊，再想想有没有优化的方法","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"几种语言实现socket例子","date":"2018-01-21T12:23:51.000Z","path":"2018/01/21/几种语言实现socket例子/","text":"参考： windows环境下用c++实现socket编 linux下C/C++网络编程基本：socket实现tcp和udp的例子 Windows Socket TCP/UDP写在前面参考《Python核心编程》中关于TCP、UDP介绍的例子。不管用什么语言，在什么系统下，万变不离其宗，都是类似于下面伪代码的逻辑。TCP服务器123456789ss = socket() # 创建服务器套接字ss.bind() # 套接字与地址绑定ss.listen() # 监听连接inf_loop: # 服务器无限循环 cs = ss.accept() # 接收客户端连接 comm_loop: # 通信循环 cs.recv/cs.send() # 对话（接收/发送） cs.close() # 关闭客户端套接字ss.close() # 关闭服务器套接字（可选） TCP客户端12345cs = socket() # 创建客户端套接字cs.connect() # 尝试连接服务器comm_loop: # 通信循环 cs.send()/cs.recv() # 对话（发送/接收）cs.close() # 关闭客户端套接字 UDP服务器12345ss = socket() # 创建服务器套接字ss.bind() # 绑定服务器套接字inf_loop: # 服务器无限循环 cs = ss.recvfrom()/ss.sendto() # 对话（接收/发送）ss.close() # 关闭服务器套接字 UDP客户端1234cs = socket() # 创建客户端套接字comm_loop: # 通信循环 cs.sendto()/cs.recvfrom() # 对话（发送/接收）cs.close() # 关闭客户端套接字 下面实现的例子功能都是 客户端发送一条消息之后 服务端在原消息基础上增加时间戳并返回给客户端 客户端发送#之后退出 TCPwindows C/C++服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#include &lt;time.h&gt;# pragma comment(lib, \"ws2_32.lib\")# define BUFFSIZE 255const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;int main()&#123; //step-1:加载套接字库（WSAStartup()）; WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"init socket fail\\n\"); exit(-1); &#125; //step-2:创建服务器套接字(socket()) SOCKET serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(serverSocket == INVALID_SOCKET) &#123; printf(\"socket error!\\n\"); exit(-1); &#125; sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(sockaddr)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = INADDR_ANY; //step-3:绑定套接字到一个IP地址和一个端口上(bind()) //这里绑定到任意的ip和固定的8888端口 if(bind(serverSocket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(\"bind error\\n\"); closesocket(serverSocket); exit(-1); &#125; //step-4:将套接字设置为监听模式等待连接请求(listen()) if(listen(serverSocket, 5) == SOCKET_ERROR) &#123; printf(\"listen error\\n\"); exit(-1); &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) //服务器无限循环 &#123; printf(\"waiting for connect...\\n\"); //step-5:等待连接请求，并返回对应于此连接的socket(accept()) sockaddr_in remoteAddr; int addrLen = sizeof(remoteAddr); SOCKET clientSocket = accept(serverSocket, (SOCKADDR*)&amp;remoteAddr, &amp;addrLen); if(clientSocket == INVALID_SOCKET) &#123; printf(\"accept error\\n\"); continue; &#125; printf(\"receive a connect :%s\\n\", inet_ntoa(remoteAddr.sin_addr)); while(true) //对话循环 &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); //step-6:等待接收客户端发送过来的数据（recv()） int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len &gt; 0) &#123; recvData[len] = '\\0'; //收到#则退出本次对话 if(strcmp(recvData,\"#\") == 0) &#123; printf(\"recv exit symbol, exit...\\n\"); break; &#125; printf(\"%s\\n\", recvData); &#125; else &#123; printf(\"recv data fail\\n\"); break; &#125; const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); //step-7:向客户端发送响应（send()） if(send(clientSocket, sendData, strlen(sendData), 0) == SOCKET_ERROR) &#123; printf(\"send data fail\\n\"); break; &#125; &#125; //step-8:关闭此次连接请求的socket closesocket(clientSocket); &#125; //step-9：关闭服务端socket closesocket(serverSocket); //step-10：关闭加载的socket库 WSACleanup(); return 0;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#pragma comment(lib, \"ws2_32.lib\")#define BUFFSIZE 255int main()&#123; WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; //step-1:加载套接字库 if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"socket start fail\\n\"); exit(-1); &#125; //step-2:创建套接字 SOCKET clientSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(clientSocket == INVALID_SOCKET) &#123; printf(\"invalid socket\\n\"); exit(-1); &#125; sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(sockaddr_in)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); //step-3:向服务端发送连接请求 if(connect(clientSocket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(\"connect error\\n\"); closesocket(clientSocket); exit(-1); &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) &#123; memset(sendData, 0, BUFFSIZE); memset(recvData, 0, BUFFSIZE); scanf(\"%s\", &amp;sendData); //step-4:向服务端发送数据 if(send(clientSocket, sendData, strlen(sendData), 0) == SOCKET_ERROR) &#123; printf(\"send data fail\\n\"); exit(-1); &#125; //输入#则退出 if(strcmp(sendData, \"#\") == 0) &#123; break; &#125; //step-5:收到服务器的响应 int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; //step-6:关闭本次连接socket closesocket(clientSocket); //step-7:关闭加载的套接字库 WSACleanup(); return 0;&#125; linux C/C++服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;#define BUFFSIZE 255int main()&#123; //step-1：创建服务器端套接字 int serverSocket = socket(AF_INET, SOCK_STREAM, 0); if(serverSocket &lt; 0) &#123; printf(\"invalid socket\\n\"); return -1; &#125; struct sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(serAddr)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.s_addr = INADDR_ANY; //step-2:绑定套接字到一个地址 if(bind(serverSocket, (struct sockaddr*)&amp;serAddr, sizeof(serAddr)) &lt; 0) &#123; printf(\"bind error\\n\"); return -1; &#125; //step-3:将套接字设置为监听模式等待连接请求 if(listen(serverSocket, 5) &lt; 0) &#123; printf(\"listen error\\n\"); return -1; &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) &#123; printf(\"waiting for connect...\\n\"); struct sockaddr_in remoteAddr; int addrLen = sizeof(struct sockaddr_in); //step-4:等待连接请求，并返回对应于此连接的socket int clientSocket = accept(serverSocket, (struct sockaddr*)&amp;remoteAddr, (socklen_t*)&amp;addrLen); if(clientSocket &lt; 0) &#123; perror(\"accept error\"); continue; &#125; printf(\"receive a connect :%s\\n\", inet_ntoa(remoteAddr.sin_addr)); while(true) &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); //step-5:等待接收客户端发送过来的数据 int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len&gt; 0) &#123; recvData[len] = '\\0'; //收到#则退出本次对话 if(strcmp(recvData,\"#\") == 0) &#123; printf(\"recv exit symbol, exit...\\n\"); break; &#125; printf(\"%s\\n\", recvData); &#125; else &#123; printf(\"recv data fail\\n\"); break; &#125; const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); //step-6:向客户端发送响应（send()） if(send(clientSocket, sendData, strlen(sendData), 0) &lt; 0) &#123; printf(\"send data fail\\n\"); break; &#125; &#125; //step-7:关闭此次连接请求的socket close(clientSocket); &#125; //step-8：关闭服务端socket close(serverSocket); return 0;&#125; 客户端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#define BUFFSIZE 255int main()&#123; //step-1:创建套接字 int clientSocket = socket(AF_INET, SOCK_STREAM, 0); if(clientSocket &lt; 0) &#123; printf(\"invalid socket\\n\"); return -1; &#125; sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(serAddr)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); //step-2:向服务端发送连接请求 if(connect(clientSocket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) &lt; 0) &#123; printf(\"connect error\\n\"); close(clientSocket); return -1; &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) &#123; memset(sendData, 0, BUFFSIZE); memset(recvData, 0, BUFFSIZE); scanf(\"%s\", &amp;sendData); //step-3:向服务端发送数据 if(send(clientSocket, sendData, strlen(sendData), 0) &lt; 0) &#123; printf(\"send data fail\\n\"); return -1; &#125; //输入#则退出 if(strcmp(sendData, \"#\") == 0) &#123; break; &#125; //step-4:收到服务器的响应 int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; //step-5:关闭本次连接socket close(clientSocket); return 0;&#125; Python服务端12345678910111213141516171819202122232425262728#!/usr/bin/env python3from socket import *from time import ctimeHOST = ''PORT = 8888BUFFSIZE = 1024ADDR = (HOST, PORT)serSock = socket(AF_INET, SOCK_STREAM)serSock.bind(ADDR)serSock.listen(5)while True: print('waiting for connection...') cliSock, addr = serSock.accept() print('...connected from:', addr) while True: data = cliSock.recv(BUFFSIZE) print(data) if data == b'#': break cliSock.send(b'[%s] %s' % (bytes(ctime(), 'utf-8'), data)) cliSock.close()serSock.close() 客户端123456789101112131415161718192021#!/usr/bin/env python3from socket import *HOST = '127.0.0.1'PORT = 8888ADDR = (HOST, PORT)BUFFSIZE = 1024cliSock = socket(AF_INET, SOCK_STREAM)cliSock.connect(ADDR)while True: data = input('&gt;') cliSock.send(bytes(data, 'utf-8')) if data == '#': break data = cliSock.recv(BUFFSIZE); print(data)cliSock.close() udpwindows C/C++服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#include &lt;time.h&gt;#pragma comment(lib, \"ws2_32.lib\")#define BUFFSIZE 255const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;int main()&#123; WSADATA wsaData; WORD sockVersion = MAKEWORD(2, 2); if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"init socket fail\\n\"); exit(-1); &#125; SOCKET serSoket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); if(serSoket == INVALID_SOCKET) &#123; printf(\"socket error\\n\"); exit(-1); &#125; sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(serSoket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(\"bind error\\n\"); closesocket(serSoket); exit(-1); &#125; char recvData[BUFFSIZE]; char sendData[BUFFSIZE]; while(true) &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); printf(\"waiting for message...\\n\"); sockaddr_in remoteAddr; int nAddrLen = sizeof(remoteAddr); int len = recvfrom(serSoket, recvData, BUFFSIZE, 0, (sockaddr*)&amp;remoteAddr, &amp;nAddrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); sendto(serSoket, sendData, strlen(sendData), 0, (sockaddr*)&amp;remoteAddr, nAddrLen); &#125; &#125; closesocket(serSoket); WSACleanup(); return 0;&#125; 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#pragma comment(lib, \"ws2_32.lib\")#define BUFFSIZE 255int main()&#123; WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"init socket fail\\n\"); exit(-1); &#125; SOCKET sClient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8888); sin.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); int addrLen = sizeof(sockaddr_in); char sendData[BUFFSIZE]; char recvData[BUFFSIZE]; while(true) &#123; scanf(\"%s\", &amp;sendData); if(strcmp(sendData, \"#\") == 0) &#123; printf(\"exit...\\n\"); break; &#125; sendto(sClient, sendData, strlen(sendData), 0, (sockaddr*)&amp;sin, addrLen); int len = recvfrom(sClient, recvData, BUFFSIZE, 0, (sockaddr*)&amp;sin, &amp;addrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; closesocket(sClient); WSACleanup(); return 0;&#125; linux C/C++服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#define BUFFSIZE 255const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;int main()&#123; int serSoket = socket(AF_INET, SOCK_DGRAM, 0); if(serSoket &lt; 0) &#123; printf(\"socket error\\n\"); return -1; &#125; sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.s_addr = INADDR_ANY; if(bind(serSoket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) &lt; 0) &#123; printf(\"bind error\\n\"); close(serSoket); return -1; &#125; char recvData[BUFFSIZE]; char sendData[BUFFSIZE]; while(true) &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); printf(\"waiting for message...\\n\"); sockaddr_in remoteAddr; int addrLen = sizeof(remoteAddr); int len = recvfrom(serSoket, recvData, BUFFSIZE, 0, (sockaddr*)&amp;remoteAddr, (socklen_t*)&amp;addrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); sendto(serSoket, sendData, strlen(sendData), 0, (sockaddr*)&amp;remoteAddr, addrLen); &#125; &#125; close(serSoket); return 0;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#define BUFFSIZE 255int main()&#123; int sClient = socket(AF_INET, SOCK_DGRAM, 0); sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8888); sin.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); int addrLen = sizeof(sockaddr_in); char sendData[BUFFSIZE]; char recvData[BUFFSIZE]; while(true) &#123; scanf(\"%s\", &amp;sendData); if(strcmp(sendData, \"#\") == 0) &#123; printf(\"exit...\\n\"); break; &#125; sendto(sClient, sendData, strlen(sendData), 0, (sockaddr*)&amp;sin, addrLen); int len = recvfrom(sClient, recvData, BUFFSIZE, 0, (sockaddr*)&amp;sin, (socklen_t*)&amp;addrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; close(sClient); return 0;&#125; Python服务端123456789101112131415161718192021#!/usr/bin/env python3from socket import *from time import ctimeHOST = ''PORT = 8888ADDR = (HOST, PORT)BUFFSIZE = 1024serSock = socket(AF_INET, SOCK_DGRAM)serSock.bind(ADDR)while True: print('waiting for message...') data, addr = serSock.recvfrom(BUFFSIZE) serSock.sendto(b'[%s] %s' % (bytes(ctime(), 'utf-8'), data), addr) print('...received from and returned to:', addr)serSock.close() 客户端12345678910111213141516171819#!/usr/bin/env python3from socket import *HOST = '127.0.0.1'PORT = 8888ADDR = (HOST, PORT)BUFFSIZE = 1024cliSock = socket(AF_INET, SOCK_DGRAM)while True: data = input('&gt;') if data == \"#\": break cliSock.sendto(bytes(data, 'utf-8'), ADDR) data, addr = cliSock.recvfrom(BUFFSIZE) print(data)cliSock.close() websocket参考： 非常有趣的理解websocket HTML5 WebSocket 说明 是什么：HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议 什么用：解决http轮询等的资源消耗，建立连接后，服务器和客户端可以快速地互相传输数据 怎么用：参考下面的例子 例子 服务端各个语言都有实现，仅Python就发现了两种实现1、pywebsocket2、python-websocket-server 打个标记，后面有时间啃一下 客户端比较简单，上面的例子都有","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"二叉树C++实现","date":"2018-01-15T11:23:51.000Z","path":"2018/01/15/二叉树C++实现/","text":"类声明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;iostream&gt;template &lt;class T&gt;class BinaryTree&#123;public: enum ORDER &#123; LEVELORDER, //层次 PREORDER, //先序 &#125;; BinaryTree() : root_(nullptr), size_(0) &#123;&#125; //通过数组构造，其中数组里的值默认按照层次优先排列; //nullVal表示为空的值，order表示传入数组的排列顺序 //下面以T为int，nullVal为-1时举例 // 3 // / \\ // 2 7 // \\ / \\ // 4 5 1 //要构造这样一个二叉树，则各种顺序下需要传入的数组为 //层次：&#123;3, 2, 7, -1, 4, 5, 1&#125; //先序：&#123;3, 2, -1, 4, -1, -1, 7, 5, -1, -1, 1&#125; //目前只想到这两种初始化的方式。 //因为必须先构造父，再构造左右孩子，所以应该只能先序吧 BinaryTree(const std::vector&lt;T&gt; &amp;array, const T &amp;nullVal, ORDER order=LEVELORDER); //前序遍历 std::vector&lt;T&gt; preOrder(bool useRecursive=true) const; //中序遍历 std::vector&lt;T&gt; inOrder(bool useRecursive=true) const; //后序遍历 std::vector&lt;T&gt; postOrder(bool useRecursive=true) const; //层次遍历 std::vector&lt;T&gt; levelOrder() const; ~BinaryTree();private: struct Node &#123; T data_; Node *lchild_; Node *rchild_; Node(const T&amp; data) : data_(data), lchild_(nullptr), rchild_(nullptr) &#123;std::cout &lt;&lt; \"Node constructor: \" &lt;&lt; data_ &lt;&lt; std::endl;&#125; ~Node() &#123;std::cout &lt;&lt; \"Node destructor: \" &lt;&lt; data_ &lt;&lt; std::endl; &#125; &#125;; void levelOrderInit(const std::vector&lt;T&gt; &amp;array, const T &amp;nullVal); void preOrderInit(const std::vector&lt;T&gt; &amp;array, Node *&amp;root, int &amp;index, const T &amp;nullVal); //xxx_recursive表示递归方式遍历；xxx_loop表示循环方式遍历 void preOrder_recursive(Node *, std::vector&lt;T&gt; &amp;) const; void preOrder_loop(std::vector&lt;T&gt; &amp;) const; void inOrder_recursive(Node *, std::vector&lt;T&gt; &amp;) const; void inOrder_loop(std::vector&lt;T&gt; &amp;) const; void postOrder_recursive(Node *, std::vector&lt;T&gt; &amp;) const; void postOrder_loop(std::vector&lt;T&gt; &amp;) const; void clearTree(Node *node); Node *root_; int size_;&#125;; 构造构造函数1234567891011121314151617181920212223template&lt;class T&gt;BinaryTree&lt;T&gt;::BinaryTree(const std::vector&lt;T&gt; &amp;array, const T&amp; nullVal, ORDER order)&#123; size_ = array.size(); if(!size_) &#123; root_ = nullptr; return; &#125; int index = 0; switch(order) &#123; case LEVELORDER: levelOrderInit(array, nullVal); break; case PREORDER: preOrderInit(array, root_, index, nullVal); break; default: break; &#125;&#125; 层次数组初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445template&lt;class T&gt;void BinaryTree&lt;T&gt;::levelOrderInit(const std::vector&lt;T&gt; &amp;array, const T&amp; nullVal)&#123; root_ = new Node(array[0]); std::queue&lt;Node*&gt; q; q.push(root_); int start = 1; //每一层级节点的个（第二层有2个） int levelNums = 2; while(start &lt; size_) &#123; for(int i = start; i &lt; (start + levelNums) &amp;&amp; i &lt; size_; i += 2) &#123; if(q.empty()) &#123; printf(\"input array not valid\\n\"); return; &#125; //从左到右依次取出上一层的父节点 Node *node = q.front(); q.pop(); const T&amp; lVal = array.at(i); if(lVal != nullVal) &#123; Node *lchild = new Node(lVal); node-&gt;lchild_ = lchild; q.push(lchild); &#125; //最后一个右孩子可能没给出，导致i+1越界，这里判断 if(i + 1 &gt;= size_) break; const T&amp; rVal = array.at(i + 1); if(rVal != nullVal) &#123; Node *rchild = new Node(rVal); node-&gt;rchild_ = rchild; q.push(rchild); &#125; &#125; start += levelNums; //每层节点数都是上一层的两倍，即使是无效值，也必须用nullVal给出 levelNums *= 2; &#125;&#125; 2018-03-11更新层次顺序数据初始化时，使用递归更为方便（数据结构类似于堆）1234567891011121314template &lt;typename T&gt;void BinaryTree&lt;T&gt;::levelOrderInit(const std::vector&lt;T&gt; &amp;array, const T &amp;nullVal, Node *&amp;root, int index)&#123; if(index &gt;= array.size() || array[index] == nullVal) return; root = new Node(array[index]); //更新左节点，注意到左节点数据的索引为2i+1 levelOrderInit(array, nullVal, root-&gt;left, 2 * index + 1); //更新右节点 levelOrderInit(array, nullVal, root-&gt;right, 2 * index + 2);&#125;//调用levelOrderInit(array, nullVal, root_, 0); 先序数组初始化123456789101112131415161718template &lt;class T&gt;void BinaryTree&lt;T&gt;::preOrderInit(const std::vector&lt;T&gt; &amp;array, Node *&amp;root, int &amp;index, const T &amp;nullVal)&#123; if(index &lt; size_) &#123; const T &amp;curData = array.at(index); if(curData != nullVal) &#123; //构造父 root = new Node(curData); //递归构造左孩子 preOrderInit(array, root-&gt;lchild_, ++index, nullVal); //递归构造右孩子 preOrderInit(array, root-&gt;rchild_, ++index, nullVal); &#125; &#125;&#125; 析构1234567891011121314151617//后序遍历递归删除所有节点//这里应该只能使用后序吧，毕竟要把左右孩子删除，才能删除父嘛template &lt;class T&gt;void BinaryTree&lt;T&gt;::clearTree(Node *node)&#123; if(!node) return; clearTree(node-&gt;lchild_); clearTree(node-&gt;rchild_); delete node;&#125;template &lt;class T&gt;BinaryTree&lt;T&gt;::~BinaryTree()&#123; clearTree(root_);&#125; 遍历下面的几种遍历方式都分了递归和循环两种方式。显然递归方式更简单清晰； 但是有些公司是不允许使用递归的，这样就只能使用循环啦 先序遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::preOrder(bool useRecursive) const&#123; std::vector&lt;T&gt; result; if(useRecursive) preOrder_recursive(root_, result); else preOrder_loop(result); return result;&#125;//递归先序遍历，先访问父，再访问左孩子，再访问右孩子template &lt;class T&gt;void BinaryTree&lt;T&gt;::preOrder_recursive(Node *root, std::vector&lt;T&gt; &amp;result) const&#123; if(!root) return; result.push_back(root-&gt;data_); preOrder_recursive(root-&gt;lchild_, result); preOrder_recursive(root-&gt;rchild_, result);&#125;//循环先序遍历template &lt;class T&gt;void BinaryTree&lt;T&gt;::preOrder_loop(std::vector&lt;T&gt; &amp;result) const&#123; Node *root = root_; std::stack&lt;Node*&gt; stk; while(root || !stk.empty()) &#123; if(root) &#123; result.push_back(root-&gt;data_); stk.push(root); root = root-&gt;lchild_; &#125; else &#123; root = stk.top()-&gt;rchild_; stk.pop(); &#125; &#125;&#125; 2018-03-11更新先序循环变量，也可以写成这样(只输出了)123456789101112131415161718template &lt;typename T&gt;void BinaryTree&lt;T&gt;::preOrder_loop()&#123; if(!root_) return; std::stack&lt;Node *&gt; stk; stk.push(root_); while(!stk.empty()) &#123; Node *p = stk.top(); stk.pop(); std::cout &lt;&lt; p-&gt;data &lt;&lt; \" \"; if(p-&gt;right) stk.push(p-&gt;right); if(p-&gt;left) stk.push(p-&gt;left); &#125;&#125; 中序遍历12345678910111213141516171819202122232425262728293031323334353637383940414243template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::inOrder(bool useRecursive) const&#123; std::vector&lt;T&gt; result; if(useRecursive) inOrder_recursive(root_, result); else inOrder_loop(result); return result;&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::inOrder_recursive(Node *root, std::vector&lt;T&gt; &amp;result) const&#123; if(!root) return; inOrder_recursive(root-&gt;lchild_, result); result.push_back(root-&gt;data_); inOrder_recursive(root-&gt;rchild_, result);&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::inOrder_loop(std::vector&lt;T&gt; &amp;result) const&#123; Node *root = root_; std::stack&lt;Node*&gt; stk; while(root || !stk.empty()) &#123; if(root) &#123; stk.push(root); root = root-&gt;lchild_; &#125; else &#123; Node *tmp = stk.top(); stk.pop(); result.push_back(tmp-&gt;data_); root = tmp-&gt;rchild_; &#125; &#125;&#125; 后序遍历后序遍历的非递归有点难,参考 二叉树递归与非递归遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::postOrder(bool useRecursive) const&#123; std::vector&lt;T&gt; result; if(useRecursive) postOrder_recursive(root_, result); else postOrder_loop(result); return result;&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::postOrder_recursive(Node *root, std::vector&lt;T&gt; &amp;result) const&#123; if(!root) return; postOrder_recursive(root-&gt;lchild_, result); postOrder_recursive(root-&gt;rchild_, result); result.push_back(root-&gt;data_);&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::postOrder_loop(std::vector&lt;T&gt; &amp;result) const&#123; std::stack&lt;Node*&gt; stk; stk.push(root_); Node *cur = nullptr, *pre = nullptr; while(!stk.empty()) &#123; cur = stk.top(); if((!cur-&gt;lchild_ &amp;&amp; !cur-&gt;rchild_) || (pre &amp;&amp; (pre == cur-&gt;lchild_ || pre == cur-&gt;rchild_))) &#123; result.push_back(cur-&gt;data_); stk.pop(); pre = cur; &#125; else &#123; if(cur-&gt;rchild_) stk.push(cur-&gt;rchild_); if(cur-&gt;lchild_) stk.push(cur-&gt;lchild_); &#125; &#125;&#125; 层次遍历123456789101112131415161718template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::levelOrder() const&#123; std::vector&lt;T&gt; result; std::queue&lt;Node*&gt; q; q.push(root_); while(!q.empty()) &#123; Node *t = q.front(); q.pop(); result.push_back(t-&gt;data_); if(t-&gt;lchild_) q.push(t-&gt;lchild_); if(t-&gt;rchild_) q.push(t-&gt;rchild_); &#125; return result;&#125; 测试1234567891011121314151617181920212223242526template &lt;class T&gt;void test(char *desc, std::vector&lt;T&gt; &amp;array)&#123; printf(\"%s\", desc); for(int val : array) printf(\"%d \", val); printf(\"\\n\");&#125;int main()&#123; std::vector&lt;int&gt; array&#123;3, 2, 7, -1, 4, 5, 1&#125;; BinaryTree&lt;int&gt; tree(array, -1); //std::vector&lt;int&gt; array&#123;3, 2, -1, 4, -1, -1, 7, 5, -1, -1, 1&#125;; //BinaryTree&lt;int&gt; tree(array, -1, BinaryTree&lt;int&gt;::PREORDER); std::vector&lt;int&gt; result; test(\"pre order recursive: \", tree.preOrder()); //3 2 4 7 5 1 test(\"pre order loop: \", tree.preOrder(false)); //3 2 4 7 5 1 test(\"in order recursive: \", tree.inOrder()); //2 4 3 5 7 1 test(\"in order loop: \", tree.inOrder(false)); //2 4 3 5 7 1 test(\"post order recursive: \", tree.postOrder()); //4 2 5 1 7 3 test(\"post order loop: \", tree.postOrder(false)); //4 2 5 1 7 3 test(\"level order: \", tree.levelOrder()); //3 2 7 4 5 1 return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"C++中常见数据结构的实现","date":"2018-01-05T12:23:51.000Z","path":"2018/01/05/C++中常见数据结构的实现/","text":"vector说明类似于基本数组，但是内存的回收在类内进行 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106template &lt;class T&gt;class Vector&#123;public: explicit Vector(int size = 0) : size_(size), capacity_(size + SPACE_CAPACITY), array_(new T[capacity_]) &#123; &#125; Vector(const Vector &amp;rhs) :array_(nullptr) &#123; operator=(rhs); &#125; ~Vector() &#123; if(array_) delete []array_; &#125; Vector &amp;operator=(const Vector &amp;rhs) &#123; //判断是否自己赋给自己 if(this != &amp;rhs) &#123; if(array_) delete []array_; size_ = rhs.size_; capacity_ = rhs.capacity_; array_ = new T[capacity_]; for(int i = 0; i &lt; size_; ++i) array_[i] = rhs.array_[i]; //这里用memcpy应该也可以吧 //memcpy(array_, rhs.array_, size_*sizeof(T)) &#125; return *this; &#125; void resize(int newSize) &#123; if(newSize &gt; capacity_) reverse(newSize * 2 + 1); size_ = newSize; &#125; void reverse(int newCapacity) &#123; if(newCapacity &lt; size_) return; T *newArray = new T[newCapacity]; for(int i = 0; i &lt; size_; ++i) newArray[i] = array_[i]; capacity_ = newCapacity; delete []array_; array_ = newArray; &#125; T &amp;operator[](int index) &#123; return array_[index]; &#125; //这里两个[]函数分别返回引用和常引用 const T &amp;operator[](int index) const &#123; return array_[index]; &#125; bool empty() &#123; return size_ == 0; &#125; int size()&#123; return size_;&#125; int capacity() &#123; return capacity_;&#125; void push_back(const T &amp;data) &#123; if(size_ == capacity_) reverse(2 * capacity_ + 1); array_[size_++] = data; &#125; void pop_back()&#123; size_--; &#125; const T &amp;back() const &#123; return array_[size_ - 1]; &#125; typedef T* iterator; typedef const T* const_iterator; iterator begin() &#123; return &amp;array_[0];&#125; const_iterator begin() const &#123; return &amp;array_[0];&#125; iterator end() &#123; return &amp;array_[size_]; &#125; const_iterator end() const &#123; return &amp;array_[size_]; &#125; private: enum &#123; SPACE_CAPACITY = 16 &#125;; T *array_; int size_; int capacity_;&#125;; 链表说明此为双向链表的实现 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193template &lt;class T&gt;class List&#123;private: struct Node &#123; Node(const T &amp;data = T(), Node *p=nullptr, Node *q=nullptr) : data_(data), prev_(p), next_(q) &#123;&#125; T data_; Node *prev_; Node *next_; &#125;;public: class const_iterator &#123; public: const_iterator()&#123;&#125; const T &amp;operator*() const &#123; return retrieve(); &#125; //前置++itr const_iterator &amp;operator++() &#123; currentPos_ = currentPos_-&gt;next_; return *this; &#125; //后置itr++ //注意这里不能返回引用了,因为函数返回后old变量已经不存在 const_iterator operator++(int) &#123; const_iterator old = *this; ++(*this); return old; &#125; bool operator==(const const_iterator &amp;rhs) const &#123; return currentPos_ == rhs.currentPos_;&#125; bool operator!=(const const_iterator &amp;rhs) const &#123; return !(*this == rhs);&#125; protected: const_iterator(Node *pos) : currentPos_(pos) &#123;&#125; T &amp;retrieve() const &#123; return currentPos_-&gt;data_; &#125; Node *currentPos_; friend class List&lt;T&gt;; &#125;; class iterator : public const_iterator &#123; public: iterator()&#123;&#125; T &amp;operator*() &#123; return retrieve(); &#125; const T &amp;operator*() const &#123; return const_iterator::operator*();&#125; iterator &amp;operator++() &#123; currentPos_ = currentPos_-&gt;next_; return *this; &#125; iterator operator++(int) &#123; iterator old = *this; ++(*this); return old; &#125; protected: iterator(Node *pos) : const_iterator(pos) &#123;&#125; friend class List&lt;T&gt;; &#125;;public: List() &#123; init(); &#125; List(const List &amp;rhs) &#123; init(); *this = rhs; &#125; ~List() &#123; clear(); delete header_; delete tail_; &#125; const List &amp;operator=(const List &amp;rhs) &#123; if(this != &amp;rhs) &#123; clear(); for(auto itr = rhs.begin(); itr != rhs.end(); ++itr) push_back(*itr); &#125; return *this; &#125; iterator begin() &#123; return iterator(header_-&gt;next_); &#125; const_iterator begin() const &#123; return const_iterator(header_-&gt;next_); &#125; iterator end() &#123; return iterator(tail_); &#125; const_iterator end() const &#123; return const_iterator(tail_); &#125; int size() &#123; return size_; &#125; bool empty() &#123; return size_ == 0; &#125; void clear() &#123; while(size_) pop_front(); &#125; T &amp;front() &#123; return *begin(); &#125; const T &amp;front() const &#123; return *begin(); &#125; T &amp;back() &#123; return *--end(); &#125; const T &amp;back() const &#123; return *--end(); &#125; void push_front(const T &amp;data) &#123; insert(begin(), data); &#125; void push_back(const T &amp;data) &#123; insert(end(), data);&#125; void pop_front() &#123; erase(begin()); &#125; void pop_back() &#123; erase(--end()); &#125; //insert data before itr iterator insert(iterator itr, const T &amp;data) &#123; Node *p = itr.currentPos_; ++size_; Node *newNode = new Node(data, p-&gt;prev_, p); p-&gt;prev_-&gt;next_ = newNode; p-&gt;prev_ = newNode; return iterator(newNode); //或者简写如下 //return iterator(p-&gt;prev_ = p-&gt;prev_-&gt;next_ = new Node(data, p-&gt;prev_, p)) &#125; iterator erase(iterator itr) &#123; if(itr == end()) return end(); Node *p = itr.currentPos_; iterator retVal(p-&gt;next_); --size_; p-&gt;prev_-&gt;next_ = p-&gt;next_; p-&gt;next_-&gt;prev_ = p-&gt;prev_; delete p; return retVal; &#125; iterator erase(iterator from, iterator to) &#123; for(auto itr = begin; i != to;) itr = erase(itr); return to; &#125; private: Node *header_; Node *tail_; int size_; void init() &#123; header_ = new Node; tail_ = new Node; header_-&gt;next_ = tail_; tail_-&gt;prev_ = header_; size_ = 0; &#125;&#125;; stack说明只能通过top元素操作，基本操作是push(进栈)和pop(出栈)。遵循LIFO(后进先出)原则 实现分别可以通过链表和数组实现，较简单书上没有实现。这里借助之前的Vector类简单实现一下。12345678910111213141516171819202122232425262728293031template &lt;class T&gt;class Stack&#123;public: Stack()&#123; topOfArray_ = -1; &#125; //因为Vector和int都为数值类型，所以理论上析构函数，复制构造函数， //operator=都可以使用默认的，无需显示写出 const T &amp;top() &#123; return stack_[topOfArray_];&#125; void push(const T&amp; data) &#123; stack_[++topOfArray_] = data; &#125; const T&amp; pop() &#123; return stack_[topOfArray_--]; &#125; bool empty() &#123; return topOfArray_ == -1;&#125;private: Vector&lt;T&gt; stack_; int topOfArray_;&#125;;int main()&#123; Stack&lt;int&gt; stack; stack.push(5); stack.push(10); stack.push(3); printf(\"%d\\n\", stack.top()); //3 while(!stack.empty()) printf(\"%d \", stack.pop()); //3 10 5 return 0;&#125; 应用检查代码中的平衡符号如[()]合法，而[(])非法。检查方法如下– 初始化一个空栈，读取字符至文件尾。– 若字符是开放符号，则压栈– 若字符是封闭符号，则如果栈为空则报错，若果栈非空则弹出栈元素，如果不是对应的开放符号，则报错– 如果到文件尾，且栈非空则报错 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//检查是否为一组开闭符号bool isPairSymbol(char left, char right)&#123; return (left == '(' &amp;&amp; right == ')') || (left == '&#123;' &amp;&amp; right == '&#125;') || (left == '&lt;' &amp;&amp; right == '&gt;') || (left == '[' &amp;&amp; right == ']');&#125;//是否开放符号bool isOpenSymbol(char ch)&#123; return ch == '(' || ch == '&#123;' || ch == '&lt;' || ch == '[';&#125;//是否封闭符号bool isCloseSymbol(char ch)&#123; return ch == ')' || ch == '&#125;' || ch == '&gt;' || ch == ']';&#125;//函数功能：检查平衡符号是否合法//入参str：包含平衡符号的字符串//返回值：合法为true，非法为falsebool checkEquSymbol(std::string str)&#123; Stack&lt;char&gt; stack; for(int i = 0; i &lt; str.size(); ++i) &#123; char ch = str[i]; if(isOpenSymbol(ch)) stack.push(ch); else if(isCloseSymbol(ch)) &#123; if(stack.empty()) return false; else if(!isPairSymbol(stack.pop(), ch)) return false; &#125; &#125; return stack.empty();&#125;int main()&#123; printf(\"%d\\n\", checkEquSymbol(\"2esvdf&#123;&#125;&lt;^&amp;&gt;\")); //1 printf(\"%d\\n\", checkEquSymbol(\"3&lt;[&#123;()&#125;]&gt;\")); //1 printf(\"%d\\n\", checkEquSymbol(\"2&lt;12&lt;&gt;\")); //0 printf(\"%d\\n\", checkEquSymbol(\"2&gt;\")); //0 return 0;&#125; 后缀表达式比如一个计算表达式为位[4 + 5 + 6 2 ]可转换为如下后缀（逆波兰)记法[4 5 + 6 2 +] 求值过程如下： 遇到一个数时压入栈 遇到操作符时从栈中弹出两个数，求得结果再入栈 为简单起见，假设所有数字都是一位，且只有+ - * /四则运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//通过操作符返回结果值（简单起见这里就不用工厂模式了）double calc(int num1, int num2, char op)&#123; switch(op) &#123; case '+': return num1 + num2; case '-': return num1 - num2; case '*': return num1 * num2; case '/': return num1 / num2; default: return 0; &#125;&#125;bool isOperator(char ch)&#123; return ch == '+' || ch == '-' || ch == '*' || ch == '/';&#125;//函数功能：计算表达式的数值结果，其中表达式为逆波兰记法，数字为1位int calcExp(std::string str)&#123; Stack&lt;double&gt; stack; for(int i = 0; i &lt; str.size(); ++i) &#123; char ch = str[i]; if(isOperator(ch)) &#123; //这里应当判空 double num1 = stack.pop(), num2 = stack.pop(); stack.push(calc(num1, num2, ch)); &#125; else stack.push(ch - '0'); &#125; return stack.pop();&#125;int main()&#123; printf(\"%d\\n\", calcExp(\"6523+8*+3+*\")); //288 return 0;&#125; 从中缀转换为后缀表达式作用：将一个标准形式的（中缀）表达式，转换成上面提到的后缀表达式 为了简化问题假设只包含+*()三种操作符 求值过程如下 读到一个操作数时立即输出 读到一个右括号’)’时，弹出栈元素，直到遇到一个对应的左括号。且左括号不输出 读到其他字符’+’,’*’,’(‘时，弹出栈元素直到发现优先级更低的；并且不能弹出’(‘元素。弹出工作完成之后，再将当前操作符入栈 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//运算符的优先级int priority(char op)&#123; switch(op) &#123; case '+': return 1; case '*': return 2; case '(': case ')': return 999; default: return 0; &#125;&#125;//函数功能：中缀表达式到后缀表达式//入参str：中缀表达式，其中只包含+*()三种运算符，其他数字用字母代替void infixToPostfix(std::string str)&#123; Stack&lt;char&gt; stack; char op; for(int i = 0; i &lt; str.size(); ++i) &#123; char ch = str[i]; if(ch == '+' || ch == '*' || ch == '(') &#123; //1、栈非空 //2、栈顶元素不是'(' //3、栈顶元素优先级不小于当前元素优先级 while(!stack.empty() &amp;&amp; stack.top() != '(' &amp;&amp; priority(stack.top()) &gt;= priority(ch)) printf(\"%c\", stack.pop()); //当前操作符入栈 stack.push(ch); &#125; else if(ch == ')') &#123; while(!stack.empty()) &#123; //出栈直到遇到'('，且'('不输出 op = stack.pop(); if(op != '(') printf(\"%c\", op); else break; &#125; &#125; else &#123; //其他即为操作数，立即输出 printf(\"%c\", ch); &#125; &#125; while(!stack.empty()) printf(\"%c\", stack.pop());&#125;int main()&#123; infixToPostfix(\"a+b*c+(d*e+f)*g\"); //abc*+de*f+g*+ return 0;&#125; 函数调用queue说明队列（queue）也是一种表，基本操作有 enqueue(入队)，在表的末端（队尾）插入一个元素 dequeue(出队)，删除并返回表的开头（队头）元素 实现链表实现较简单1234567891011121314151617181920212223242526template &lt;class T&gt;class Queue&#123;public: Queue()&#123;&#125; void enqueue(const T &amp;data) &#123; queue_.push_back(data); &#125; const T &amp;dequeue() &#123; const T &amp;data = queue_.front(); queue_.pop_front(); return data; &#125; bool empty()&#123; return queue_.empty(); &#125;private: List&lt;T&gt; queue_;&#125;;int main()&#123; Queue&lt;int&gt; queue; queue.enqueue(15); queue.enqueue(4); printf(\"%d\\n\",queue.dequeue());//15 return 0;&#125; 数组实现需要考虑循环数组的问题 二叉树参考:二叉树的C++实现 二叉查找树说明对于每个节点X，其左子树节点的值都小于X对应的值，右子树节点的值都大于X对应的值 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;iostream&gt;#include &lt;stdio.h&gt;template &lt;typename T&gt;class BinarySearchTree&#123;public: BinarySearchTree() : root_(nullptr) &#123;&#125; BinarySearchTree(const BinarySearchTree &amp;rhs) &#123; root_ = clone(rhs.root_); &#125; ~BinarySearchTree() &#123; makeEmpty(); &#125; const T &amp;findMin() const &#123; BinaryNode *t = findMin(root_); return t ? t-&gt;element_ : T(); &#125; const T &amp;findMax() const &#123; BinaryNode *t = findMax(root_); return t ? t-&gt;element_ : T(); &#125; bool contains(const T &amp;x) const &#123; return contains(x, root_); &#125; bool isEmpty() const &#123; return root_ == nullptr; &#125; void printTree() const &#123; printTree(root_); &#125; void makeEmpty() &#123; makeEmpty(root_); &#125; void insert(const T &amp;x) &#123; insert(x, root_); &#125; void remove(const T &amp;x) &#123; remove(x, root_); &#125; const BinarySearchTree &amp;operator=(const BinarySearchTree &amp;rhs) &#123; if(this != &amp;rhs) &#123; makeEmpty(); root_ = clone(rhs.root_); &#125; return *this; &#125;private: struct BinaryNode &#123; T element_; BinaryNode *left_; BinaryNode *right_; BinaryNode(const T &amp;ele, BinaryNode *l, BinaryNode *r) : element_(ele), left_(l), right_(r) &#123;&#125; &#125;; BinaryNode *root_; BinaryNode *findMin(BinaryNode *t) const &#123; if(!t) return nullptr; if(!t-&gt;left_) return t; return findMin(t-&gt;left_); &#125; BinaryNode *findMax(BinaryNode *t) const &#123; if(t) &#123; while(t-&gt;right_) t = t-&gt;right_; &#125; return t; &#125; bool contains(const T &amp;x, BinaryNode *t) const &#123; if(!t) return false; else if(x &lt; t-&gt;element_) return contains(x, t-&gt;left_); else if(t-&gt;element_ &lt; x) return contains(x, t-&gt;right_); return true; //match &#125; void insert(const T &amp;x, BinaryNode *&amp;t) const &#123; if(!t) t = new BinaryNode(x, nullptr, nullptr); else if(x &lt; t-&gt;element_) insert(x, t-&gt;left_); else if(t-&gt;element_ &lt; x) insert(x, t-&gt;right_); else std::cout &lt;&lt; \"already has node :\" &lt;&lt; x &lt;&lt; std::endl; &#125; void remove(const T &amp;x, BinaryNode *&amp;t) const &#123; if(!t) return; // can not find item else if(x &lt; t-&gt;element_) remove(x, t-&gt;left_); else if(t-&gt;element_ &lt; x) remove(x, t-&gt;right_); else if(t-&gt;left_ &amp;&amp; t-&gt;right_) //has two children &#123; //策略：将当前节点的值设为右子树最小节点的值 //并删除右子树最小节点 t-&gt;element_ = findMin(t-&gt;right_)-&gt;element_; remove(t-&gt;element_, t-&gt;right_); &#125; else &#123; //没有或只有一个子节点的情况 //若t没有子节点，删除后t置为空 //若t只有右子节点，删除后t置为其右子节点 //若t只有左子节点，删除后t置为其左子节点 BinaryNode *oldNode = t; t = t-&gt;left_ ? t-&gt;left_ : t-&gt;right_; delete oldNode; &#125; &#125; void makeEmpty(BinaryNode *&amp;t) &#123; if(t) &#123; makeEmpty(t-&gt;left_); makeEmpty(t-&gt;right_); delete t; &#125; t = nullptr; &#125; void printTree(BinaryNode *t) const &#123; if(!t) return; printTree(t-&gt;left_); std::cout &lt;&lt; t-&gt;element_ &lt;&lt; std::endl; printTree(t-&gt;right_); &#125; BinaryNode *clone(BinaryNode *t) &#123; if(!t) return nullptr; return new BinaryNode(t-&gt;element_, clone(t-&gt;left_), clone(t-&gt;right_)); &#125;&#125;;int main()&#123; BinarySearchTree&lt;int&gt; btree; btree.insert(5); btree.insert(3); btree.insert(6); btree.insert(2); btree.insert(1); btree.insert(7); btree.printTree(); btree.remove(2); auto tree2 = btree; tree2.printTree(); return 0;&#125; 散列说明以常数平均时间执行插入、删除和查找的技术。 分离链接法将所有散列到同一个值的所有元素保存到一个链表中。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;string&gt;//判断素数bool isPrime(int num)&#123; if(num &lt;= 1) return false; else if(num == 2) return true; for(int i = 2; i &lt;= num / 2; ++i) if(num % i == 0) return false; return true;&#125;//这里设包含自身，即如果num为101则返回101int nextPrime(int num)&#123; while(!isPrime(num)) num++; return num;&#125;//使用书中第三种hash方法int hash(const std::string &amp;key)&#123; int hashVal = 0; for(const char &amp;c : key) hashVal = 37 * hashVal + c; return hashVal;&#125;template &lt;typename HashedObj&gt;class HashTable&#123;public: HashTable(int size = 101) : currentSize_() &#123; theLists_.resize(nextPrime(size)); &#125; bool contains(const HashedObj &amp;x) const; void makeEmpty(); bool insert(const HashedObj &amp;x); bool remove(const HashedObj &amp;x);private: std::vector&lt;std::list&lt;HashedObj&gt;&gt; theLists_; int currentSize_; void rehash(); int myhash(const HashedObj &amp;x) const;&#125;;template &lt;typename HashedObj&gt;int HashTable&lt;HashedObj&gt;::myhash(const HashedObj &amp;x) const&#123; int hashVal = hash(x); hashVal %= theLists_.size(); if(hashVal &lt; 0) hashVal += theLists_.size(); return hashVal;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::contains(const HashedObj &amp;x) const&#123; const std::list&lt;HashedObj&gt; &amp;lst = theLists_[myhash(x)]; return find(lst.begin(), lst.end(), x) != lst.end();&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::makeEmpty()&#123; for(auto &amp;lst : theLists_) lst.clear();&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::insert(const HashedObj &amp;x)&#123; std::list&lt;HashedObj&gt; &amp;lst = theLists_[myhash(x)]; if(find(lst.begin(), lst.end(), x) != lst.end()) return false; lst.push_back(x); if(++currentSize_ &gt; theLists_.size()) rehash();&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::remove(const HashedObj &amp;x)&#123; std::list&lt;HashedObj&gt; &amp;lst = theLists_[myhash(x)]; auto itr = find(lst.begin(), lst.end(), x); if(itr == lst.end()) return false; //not found lst.erase(itr); --currentSize_; return true;&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::rehash()&#123; auto oldLists = theLists_; theLists_.resize(nextPrime(2 * oldLists.size())); for(auto &amp;lst : theLists_) lst.clear(); currentSize_ = 0; for(const auto &amp;lst : oldLists) &#123; auto itr = lst.begin(); while(itr != lst.end()) insert(*itr++); &#125;&#125; 测试1234567891011121314151617181920212223242526272829class Employee&#123;public: explicit Employee(std::string name=\"\") : name_(name) &#123;&#125; const std::string &amp;getName() const &#123; return name_;&#125; bool operator==(const Employee &amp;rhs) const &#123; return getName() == rhs.getName(); &#125; bool operator!=(const Employee &amp;rhs) const &#123; return !(*this == rhs); &#125;private: std::string name_; double salary_;&#125;;int hash(const Employee &amp;x)&#123; return hash(x.getName());&#125;int main()&#123; HashTable&lt;Employee&gt; htable; Employee ea(\"kdb\"); Employee eb(\"fff\"); Employee ec(\"ddd\"); htable.insert(ea); htable.insert(eb); htable.insert(ec); printf(\"%d\\n\", htable.contains(ea));&#125; 探测散列表方法解决冲突的办法：当冲突发生时，尝试选择另外一个单元，直到找到另外一个单元。 即通过h0(x),h1(x)…一依次试选，其中hi(x) = (hash(x) + f(i)) mod TableSize,且f(0) = 0。 这里就有线性探测f(i) = i，和平方探测f(i) = i*i两种啦。书中以平方探测举例 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//平方探测法template &lt;typename HashedObj&gt;class HashTable&#123;public: explicit HashTable(int size = 101); enum EntryType &#123;ACTIVE, EMPTY, DELETED&#125;; bool contains(const HashedObj &amp;x) const; void makeEmpty(); bool insert(const HashedObj &amp;x); bool remove(const HashedObj &amp;x);private: struct HashEntry &#123; HashedObj element_; EntryType info_; HashEntry(const HashedObj &amp;e=HashedObj(), EntryType type=EMPTY) : element_(e), info_(type) &#123;&#125; &#125;; std::vector&lt;HashEntry&gt; array_; int currentSize_; int findPos(const HashedObj &amp;x) const; bool isActive(int pos) const; void rehash(); int myhash(const HashedObj &amp;x) const;&#125;;template &lt;typename HashedObj&gt;HashTable&lt;HashedObj&gt;::HashTable(int size) : array_(nextPrime(size))&#123; makeEmpty();&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::makeEmpty()&#123; currentSize_ = 0; for(auto &amp;entry : array_) entry.info_ = EMPTY;&#125;template&lt;typename HashedObj&gt;int HashTable&lt;HashedObj&gt;::myhash(const HashedObj &amp;x) const&#123; int hashVal = hash(x); hashVal %= array_.size(); if(hashVal &lt; 0) hashVal += array_.size(); return hashVal;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::contains(const HashedObj &amp;x) const&#123; return isActive(findPos(x));&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::isActive(int pos) const&#123; return array_[pos].info_ == ACTIVE;&#125;template &lt;typename HashedObj&gt;int HashTable&lt;HashedObj&gt;::findPos(const HashedObj &amp;x) const&#123; int offset = 1; int currentPos = myhash(x); while(array_[currentPos].info_ != EMPTY &amp;&amp; array_[currentPos].element_ != x) &#123; //f(i) = f(i - 1) + 2i - 1 currentPos += offset; offset += 2; if(currentPos &gt;= array_.size()) currentPos -= array_.size(); &#125; return currentPos;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::insert(const HashedObj &amp;x)&#123; int pos = findPos(x); if(isActive(pos)) return false; array_[pos] = HashEntry(x, ACTIVE); //这里注意大于表大小一半的时候，就需要rehash了 if(++currentSize_ &gt; array_.size()/2) rehash(); return true;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::remove(const HashedObj &amp;x)&#123; int pos = findPos(x); if(!isActive(pos)) return false; array_[pos].info = DELETED; return true;&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::rehash()&#123; std::vector&lt;HashEntry&gt; oldArray = array_; array_.resize(nextPrime(2 * array_.size())); for(auto &amp;entry : array_) entry.info_ = EMPTY; currentSize_ = 0; for(auto &amp;entry : oldArray) &#123; if(entry.info_ = ACTIVE) insert(entry.element_); &#125;&#125; 测试与分离链接法相同 优先队列（堆）一种特殊的队列，包括以下操作 insert，类似于入队操作 deleteMin，找出，返回，删除队列中的最小元素（或者最大元素） 实现通过binary heap(二叉堆)实现。特点 通过数组表示的完全二叉树 首元素索引为1，当节点索引为i时，左儿子索引为2i，右儿子索引为2i+1,父节点索引i/2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;exception&gt;template &lt;typename T&gt;class BinaryHeap&#123;public: BinaryHeap(int capacity = 100); BinaryHeap(const std::vector&lt;T&gt; &amp;items); bool empty() const &#123; return currentSize_ == 0;&#125; const T &amp;findMin() const; void insert(const T &amp;x); void deleteMin(); void deleteMin(T &amp; minItem); void makeEmpty();private: int currentSize_; std::vector&lt;T&gt; array_; void buildHeap(); void percolateDown(int hole);&#125;;template &lt;typename T&gt;BinaryHeap&lt;T&gt;::BinaryHeap(int capacity) : array_(capacity), currentSize_(0) &#123;&#125;template &lt;typename T&gt;BinaryHeap&lt;T&gt;::BinaryHeap(const std::vector&lt;T&gt; &amp;items) : array_(items.size() + 10), currentSize_(items.size())&#123; for(int i = 0; i &lt; items.size(); ++i) array_[i + 1] = items[i]; buildHeap();&#125;template &lt;typename T&gt;const T &amp;BinaryHeap&lt;T&gt;::findMin() const&#123; if(empty()) throw std::underflow_error(\"under flow\"); return array_[1];&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::insert(const T &amp;x)&#123; if(currentSize_ == array_.size() - 1) array_.resize(array_.size() * 2); //percolate up 上滤 int hole = ++currentSize_; //array[hole/2]为父节点的值 //如果当前节点的值小于父节点的值，则交换 for(; hole &gt; 1 &amp;&amp; x &lt; array_[hole / 2]; hole /= 2) array_[hole] = array_[hole / 2]; array_[hole] = x;&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::deleteMin()&#123; if(empty()) throw std::underflow_error(\"under flow\"); array_[1] = array_[currentSize_--]; percolateDown(1);&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::deleteMin(T &amp;minItem)&#123; if(empty()) throw std::underflow_error(\"under flow\"); minItem = array_[1]; array_[1] = array_[currentSize_--]; percolateDown(1);&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::makeEmpty()&#123; currentSize_ = 0;&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::buildHeap()&#123; for(int i = currentSize_ / 2; i &gt;= 1; --i) percolateDown(i);&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::percolateDown(int hole)&#123; T tmp = array_[hole]; int child; for(; hole * 2 &lt;= currentSize_; hole = child) &#123; //左子节点为 2*hole child = hole * 2; //右子节点为2*hole+1，注意要先判断右子节点是否存在 if(child != currentSize_ &amp;&amp; array_[child + 1] &lt; array_[child]) ++child; if(array_[child] &lt; tmp) array_[hole] = array_[child]; else break; &#125; array_[hole] = tmp;&#125; 测试1234567891011121314151617int main()&#123; std::vector&lt;int&gt; array&#123;3, 1&#125;; BinaryHeap&lt;int&gt; heap(array); printf(\"min:%d\\n\", heap.findMin()); heap.deleteMin(); printf(\"min:%d\\n\", heap.findMin()); heap.deleteMin(); try &#123; heap.deleteMin(); &#125; catch(std::underflow_error &amp;e) &#123; printf(\"catch exception :%s\\n\", e.what()); &#125;&#125; 不相交集类说明基本的想法是使用数来表示每一个集合，因为树上的每一个元素都有相同的根，根即可以用来命名所在的集合。假设树被非显式地存储在数组中，数组的每个成员s[i]表示元素i的父亲 初始令每个数组成员值为-1，比如以下8个成员的数组0 1 2 3 4 5 6 7-1 -1 -1 -1 -1 -1 -1 -1 union(x, y)操作则令s[y] = x，比如union(4,5),union(6,7),union(4,6)之后0 1 2 3 4 5 6 7-1 -1 -1 -1 -1 4 4 6 find(x)操作返回包含x的树的根完成。操作花费时间与x节点的深度成正比。比如find(7)-&gt;find(6)-&gt;find(4)=-1得7所在树的根节点为4 实现1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;vector&gt;class DisjSets&#123;public: explicit DisjSets(int numElements); int find(int x) const; int find(int x); void unionSets(int root1, int root2);private: std::vector&lt;int&gt; arr_;&#125;;DisjSets::DisjSets(int numElements) : arr_(numElements)&#123; for(int i = 0; i &lt; numElements; ++i) arr_[i] = -1;&#125;int DisjSets::find(int x) const&#123; if(arr_[x] &lt; 0) return x; return find(arr_[x]);&#125;void DisjSets::unionSets(int root1, int root2)&#123; arr_[root2] = root1;&#125;int main()&#123; DisjSets dset(8); dset.unionSets(4, 5); dset.unionSets(6, 7); dset.unionSets(4, 6); printf(\"%d\\n\", dset.find(7));&#125; 灵巧求并算法 按大小求并，使得总是较小的树成为较大的树的子树 基本思想是让每个根的数组元素，包含他的树的大小的负值（初始时数组元素都为-1），书中没有给出算法仅需修改union算法即可，find无需修改1234567891011121314151617void DisjSets::unionSets(int root1, int root2)&#123; //root2对应的树的size更小一些 if(-arr_[root1] &gt;= -arr_[root2]) &#123; //root1的size加上root2的size arr_[root1] += arr_[root2]; //将root2对应的根节点设为root1 arr_[root2] = root1; &#125; else //root1对应的树的size更小一些 &#123; //root1的size加上root2的size arr_[root2] += arr_[root1]; //将root2对应的根节点设为root1 arr_[root1] = root2; &#125;&#125; 例子123456索引 0 1 2 3 4 5 6 7初始 -1 -1 -1 -1 -1 -1 -1 -1union(4, 5)后 -1 -1 -1 -1 -2 4 -1 -1union(6, 7)后 -1 -1 -1 -1 -2 4 -2 6union(4, 6)后 -1 -1 -1 -1 -4 4 4 6union(3, 4)后 -1 -1 -1 4 -5 4 4 6 按高度求并，跟踪每棵树的高度而不是大小，使得浅的树成为深的树的子树数组每个项存储高度的负值减去1。初始时所有项都是-1，表示高度为01234567891011void DisjSets::unionSets(int roo1, int root2)&#123; if(arr_[root2] &lt; arr_[root1]) //-a[root1]&lt;-a[root2] root2 is deeper arr_[root1] = root2; //Make root2 new root else &#123; if(arr_[root2] == arr_[root1]) arr_[root1]--; //Update height if same arr_[root2] = root1; //Make root1 new root &#125;&#125; 例子123456索引 0 1 2 3 4 5 6 7初始 -1 -1 -1 -1 -1 -1 -1 -1union(4, 5)后 -1 -1 -1 -1 -2 4 -1 -1union(6, 7)后 -1 -1 -1 -1 -2 4 -2 6union(4, 6)后 -1 -1 -1 -1 -3 4 4 6union(3, 4)后 -1 -1 -1 4 -3 4 4 6 路径压缩在依次find操作期间执行，压缩的效果是从x到根的路径上的每个节点都使他的父节点变成根需要注意的是路径压缩与按大小求并完全兼容，而与按高度求并不完全兼容，因为路径压缩可以改变树的高度123456int DisjSets::find(int x)&#123; if(arr_[x] &lt; 0) return x; return arr_[x] = find(arr_[x]);&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"常见排序算法C++实现","date":"2017-12-30T09:23:51.000Z","path":"2017/12/30/常见排序算法C++实现/","text":"先写出简单的交换两个值的swap函数123456void swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125; 各种排序算法的原理及实现冒泡排序原理已升序为例，依次比较相邻两个数，大数放后。则一轮排序后最后一个值已为最大值。此时再以同样的方法比较前(size - 1)个数。 实现1234567891011121314151617//冒泡排序void bubbleSort(int *array, int size)&#123; for(int i = 0; i &lt; size - 1; ++i) &#123; int swapped = false; for(int j = 0; j &lt; size - i - 1; ++j) &#123; if(array[j] &gt; array[j+1])&#123; swap(array[j], array[j + 1]); swapped = true; &#125; &#125; if(!swapped) break; &#125;&#125; 说明： 此为升序排列，若要降序，则将{array[j] &gt; array[j+1]}改为{array[j] &lt; array[j+1]}即可 swapped标志量的说明：如果该标志量为false，表示某一次循环，每一个a[j]都小于等于a[j + 1]，即已经是排序好的，所以跳出循环 鸡尾酒排序原理冒泡排序的改进，进行双向排序，大数往后放，小数往前放（像摇晃的鸡尾酒） 实现12345678910111213141516//鸡尾酒排序void cocktailSort(int *array, int size)&#123; int begin = 0, end = size - 1; while(begin &lt; end) &#123; for(int i = begin; i &lt; end; ++i) if(array[i] &gt; array[i + 1]) swap(array[i], array[i + 1]); --end;//最后一个已排序好 for(int i = end; i &gt; begin; --i) if(array[i] &lt; array[i - 1]) swap(array[i - 1], array[i]); ++begin;//第一个位置已排序好 &#125;&#125; 选择排序原理已升序为例 第一次从整个数组中选择最小的一个，与第1个值交换，这时第一个值已排序好 第二次从第一个之外剩下的数中选择最小的与第二个值交换，这时第二个值也排序好依次类推 实现12345678910111213141516//选择排序void selectSort(int *array, int size)&#123; for(int i = 0; i &lt; size - 1; ++i) &#123; int minIndex = i; //前i个数已排序好，而第i个值是最小基准值，所以从i + 1开始 for(int j = i + 1; j &lt; size; ++j) &#123; if(array[j] &lt; array[minIndex]) minIndex = j; &#125; if(minIndex != i) swap(array[i], array[minIndex]); &#125;&#125; 直接插入排序原理将原数组想象分为两部分，第一部分是已排序好的，第二部分是乱序的。 每次从乱序的部分取出第一个值，在已排序的部分找出一个合适的位置插入进去。 其中，第一次排序排序时，已排序的部分为一个值 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344//直接插入排序：方法1void insertSort1(int *array, int size)&#123; //未排序的部分，从1开始往后遍历 for(int i = 1; i &lt; size; ++i) &#123; //从未排序的部分取出第一个，为待比较的值 int curData = array[i]; //在第一部分中插入的索引 int insertIndex = i; //已排序的部分为前i个值 for(int j = 0; j &lt; i; ++j) &#123; if(array[j] &gt; curData) &#123; insertIndex = j; break; &#125; &#125; //第一部分从最后一个位置，到待插入的位置，统统向后移一个位置 for(int j = i; j &gt; insertIndex; --j) array[j] = array[j - 1]; //将待比较的值插入 array[insertIndex] = curData; &#125;&#125;//第一种方法稍微有点啰嗦，可以更简略一些//直接插入排序：方法2void insertSort2(int *array, int size)&#123; //未排序的部分，从1开始往后遍历 for(int i = 1; i &lt; size; ++i) &#123; //从未排序的部分取出第一个，为待比较的值 int curData = array[i]; //在第一部分中插入的索引 int j = i; //从已排序部分的最后一个往前遍历，若比标准值大，则往后移一个 for(j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; curData; --j) array[j + 1] = array[j]; array[j + 1] = curData; &#125;&#125; 归并排序原理将数组的排序拆分成小的有序数组的合并。有点抽象，举个例子 原数组有8个无序值-&gt;拆分成2组，每组4个 -&gt; 拆分成4组，每组两个 -&gt; 拆分成8组，每组1个成员。 此时每个组都是包含一个成员的有序数组，将1,2个有序组合并成2个成员的有序组A， 将第3,4个有序组合并成2个成员的有序组B，再将有序组A,B合并，如此返回 实现12345678910111213141516171819202122232425262728293031323334353637//归并排序//将起，中，止范围的数组分为两部分，将这两部分合并void merge(int *array, int p, int q, int r)&#123; //第一部分的起止 int begin1 = p, end1 = q; //第二部分的起止 int begin2 = q + 1, end2 = r; int k = 0; //临时数组，存放p到r之间排序好的数组 int *temp = new int[r - p + 1]; while(begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123; if(array[begin1] &lt; array[begin2]) temp[k++] = array[begin1++]; else temp[k++] = array[begin2++]; &#125; while(begin1 &lt;= end1) temp[k++] = array[begin1++]; while(begin2 &lt;= end2) temp[k++] = array[begin2++]; for(int i = 0; i &lt; k; ++i) array[p + i] = temp[i]; delete []temp;&#125;void mergeSort(int *array, int begin, int end)&#123; if(begin &lt; end) &#123; int mid = (begin + end)/2; mergeSort(array, begin, mid); mergeSort(array, mid + 1, end); printf(\"begin:%d, mid:%d, end:%d\\n\", begin, mid, end); merge(array, begin, mid, end); &#125;&#125; 原数组为{9, 3, 1, 7, 2, 5, 4, 10}，上述打印如下1234567begin:0, mid:0, end:1begin:2, mid:2, end:3begin:0, mid:1, end:3begin:4, mid:4, end:5begin:6, mid:6, end:7begin:4, mid:5, end:7begin:0, mid:3, end:7 可以看到大致的归并过程 优化上述在merge函数中每次去new,delete数组是非常耗时的，可以考虑在排序之前new好一个大数组，排序之后再delete一次就行了。 123456789101112131415161718192021222324252627282930313233343536373839//归并排序-临时数组优化void merge(int *array, int p, int q, int r, int *temp)&#123; //第一部分的起止 int begin1 = p, end1 = q; //第二部分的起止 int begin2 = q + 1, end2 = r; int k = 0; while(begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123; if(array[begin1] &lt; array[begin2]) temp[k++] = array[begin1++]; else temp[k++] = array[begin2++]; &#125; while(begin1 &lt;= end1) temp[k++] = array[begin1++]; while(begin2 &lt;= end2) temp[k++] = array[begin2++]; for(int i = 0; i &lt; k; ++i) array[p + i] = temp[i];&#125;void mergeSort(int *array, int begin, int end, int *temp)&#123; if(begin &lt; end) &#123; int mid = (begin + end)/2; mergeSort(array, begin, mid, temp); mergeSort(array, mid + 1, end, temp); merge(array, begin, mid, end, temp); &#125;&#125;void mergeSort(int *array, int size)&#123; int *temp = new int[size]; mergeSort(array, 0, size - 1, temp); delete []temp;&#125; 不用递归实际上递归会非常耗时的，网上的例子都是使用递归的。自己想了一下，可不可以这样呢： 还是假设数组长度为8 第一轮，待排序子数组长度都为1。(1,2),(3,4),(5,6),(7,8)分别合并。 第二轮，待排序子数组长度都为2。((1,2),(3,4)),((5,6),(7,8))分别合并。 第三轮，待排序子数组长度为4。这时只需合并((1,2,3,4),(5,6,7,8)) 下面来实现一下 123456789101112131415161718192021222324void mergeSort3(int *array, int size)&#123; //每个已排序子数组的大小 int gap = 1; int *temp = new int[size]; //循环，直到分成只有两个数组了 while(gap &lt; size) &#123; for(int i = 0; i &lt; size; i += gap*2)&#123; int begin = i, mid = i + gap - 1, end = std::min(size - 1, i + gap*2 -1); //如果中间值已经超过size，则最后一个数组已不需合并 //比如数组长度为11，begin为8，mid为11，end为15 //则(11到15)的数组已不在范围 if(mid &gt;= size - 1) continue; merge(array, begin, mid, end, temp); printf(\"begin:%d, mid:%d, end:%d\\n\", begin, mid, end); &#125; gap *= 2; &#125; delete []temp;&#125; 以8个成员的数组为例，输出如下，可参考排序的过程1234567begin:0, mid:0, end:1begin:2, mid:2, end:3begin:4, mid:4, end:5begin:6, mid:6, end:7begin:0, mid:1, end:3begin:4, mid:5, end:7begin:0, mid:3, end:7 直观上还是比较好理解这种排序的思想的，感觉就是没有分治和归并的过程了。 直接以2的次方的间隔的数组进行合并排序，类似于希尔排序了。至于具体性能如何，后面再统一讨论。 引申：将n个已排序的数组合并成一个有序数组注：不能使用std的list等类型 先定义一些初始化的值，假设需要合并8个有序数组12345678910111213141516171819int array1[] = &#123;1, 3, 5&#125;;int array2[] = &#123;2, 4, 7, 9&#125;;int array3[] = &#123;8, 10, 11, 19, 23, 56&#125;;int array4[] = &#123;0, 3&#125;;int array5[] = &#123;13&#125;;int array6[] = &#123;32, 42, 52, 79, 86, 111, 222, 333&#125;;int array7[] = &#123;23, 25, 27&#125;;int array8[] = &#123;-10, -1, 7, 10&#125;;//存放n个数组的数组，因为每个数组大小不一定一样，所以不能使用2维数组int *arrays[] = &#123;array1, array2, array3, array4, array5, array6, array7, array8&#125;;//存放每个数组size的数组int sizes[] = &#123;sizeof(array1)/sizeof(int), sizeof(array2)/sizeof(int), sizeof(array3)/sizeof(int), sizeof(array4)/sizeof(int), sizeof(array5)/sizeof(int), sizeof(array6)/sizeof(int), sizeof(array7)/sizeof(int), sizeof(array8)/sizeof(int) &#125;;//数组的个数int size = sizeof(arrays)/sizeof(int*); 方法一：两两合并即第一个和第二个合并，合并好的大数组和第三个合并，以此类推。 这种方法比较好想，但是也比较效率低。就和排序的时候第1,2个数先排序， 再和第三个数排序一样。 实现123456789101112131415161718192021222324252627282930313233343536373839404142//函数功能：合并两个已排序数组//其中array2足够大，可以存放两个数组中的全部元素。void mergeTwoArray(int *array1, int size1, int *array2, int size2)&#123; int i = 0, j = 0, k = 0; int *temp = new int[size1 + size2]; while(i &lt; size1 &amp;&amp; j &lt; size2) &#123; if(array1[i] &lt; array2[j]) temp[k++] = array1[i++]; else temp[k++] = array2[j++]; &#125; while(i &lt; size1) temp[k++] = array1[i++]; while(j &lt; size2) temp[k++] = array2[j++]; for(int i = 0; i &lt; k; ++i) array2[i] = temp[i]; delete []temp;&#125;void mergeArrays(int *arrays[], int size, int sizes[])&#123; int totalSize = 0; for(int i = 0; i &lt; size; ++i) &#123; totalSize += sizes[i]; &#125; int *totalArray = new int[totalSize]; int currentSize = 0; for(int i = 0; i &lt; size; ++i) &#123; mergeTwoArray(arrays[i], sizes[i], totalArray, currentSize); currentSize += sizes[i]; &#125; for(int i = 0; i &lt; totalSize; ++i) printf(\"%d \", totalArray[i]); delete []totalArray;&#125; 其中合并两个数组的方法可以优化成如下12345678910111213141516171819202122//反过来想，从最后一个元素往前遍历//参考http://blog.csdn.net/f81892461/article/details/8583983void mergeTwoArray(int *array1, int size1, int *array2, int size2)&#123; //第一个数组的最后一个元素 int i = size1 - 1; //第二个数组的最后一个元素 int j = size2 - 1; //合成新数组的最后一个元素 int k = size1 + size2 - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; //从后往前遍历 if(array1[i] &gt; array2[j]) array2[k--] = array1[i--]; else array2[k--] = array2[j--]; &#125; while(i &gt;= 0) array2[k--] = array1[i--]; //注意这里不需要再遍历array2中的元素，因为他们已经在array2中&#125; 方法二：利用分治归并的思想网上有例子是用链表做的 http://www.cnblogs.com/TenosDoIt/p/3673188.html https://leetcode.com/problems/merge-k-sorted-lists/ 123456789101112131415161718192021222324252627//合并两个有序链表（这里设head节点不是数据节点）void merge2list(Node *head1, Node *head2)&#123; if(!head1 || !head1-&gt;next_ || !head2 || !head2-&gt;next_) return; Node node(0), *tail = &amp;node; Node *p = head1-&gt;next_, *q = head2-&gt;next_; while(p &amp;&amp; q) &#123; if(p-&gt;key_ &lt;= q-&gt;key_) &#123; tail-&gt;next_ = p; p = p-&gt;next_; &#125; else &#123; tail-&gt;next_ = q; q = q-&gt;next_; &#125; tail = tail-&gt;next_; &#125; if(p) tail-&gt;next_ = p; else if(q) tail-&gt;next_ = q; head1-&gt;next_ = node.next_;&#125; 然后按照下面的思路(以8个链表为例) L0和L1合并到L0，L2和L3合并到L2，L4和L5合并到L4，L6和L7合并到L6 再将L0和L2合并到L0，L4和L6合并到L4 再将L0和L4合并到L012345678910111213//结果保存在lists[0]中void mergeKList(std::vector&lt;Node*&gt; &amp;lists)&#123; int size = lists.size(); int gap = 1; while(gap &lt; size) &#123; for(int i = 0; i &lt; size - gap; i += 2 * gap)&#123; merge2list(lists[i], lists[i + gap]); &#125; gap *= 2; &#125;&#125; 用数组应该也能做，只是每个数组的空间是固定的，不是太好扩充。 快速排序原理依然是分治的思想 将原数组分为3部分，(begin, X - 1), X, (X + 1, end)。其中(begin, X - 1)部分的每个值都比X对应的值要小，(X + 1, end)对应的每个值都比X对应的值要大 对左右两部分数组再进行如上类似操作，进行分治 关键的问题是要找到X的位置，分治还是比较简单的。 对了，好像快速排序是各种库里默认的排序算法。 实现目前看到两种实现 第一种只设置一个向后移动的索引 1234567891011121314151617181920void qsort1(int *array, int begin, int end)&#123; if(begin &gt;= end) return; //记录的就是X对应的位置 //即last左边的都比last对应的值小，last右边的都比last对应的值大 int last = begin; //将第一个值和中间的值交换，即将中间的值作为比较值。并不是必须的。 swap(array[begin], array[(begin + end)/2]); int xData = array[begin]; //索引从第二个值往后，分别与第一个值比较 for(int i = begin + 1; i &lt;= end; ++i) if(array[i] &lt; xData) swap(array[++last], array[i]); //这里没交换之前(begin + 1, last)之间的值都比xData小 swap(array[begin], array[last]); //将begin和last值交换后，(begin, last - 1)的值都比last值小了 qsort1(array, begin, last - 1); qsort1(array, last + 1, end);&#125; 第二种设置前后两个移动的索引 123456789101112131415161718192021222324252627void qsort2(int *array, int begin, int end)&#123; if(begin &gt;= end) return; int i = begin, j = end; //依然设置第一个值为待比较值 int xData = array[begin]; while(i &lt; j) &#123; //当右边索引对应的值一直比待比较值大时，索引左移 while(i &lt; j &amp;&amp; array[j] &gt;= xData) --j; //此时若j没超过范围，则array[j]是右侧第一个比待比较值小的元素 //交换与左侧索引对应的值，并且左侧索引自增 if(i &lt; j) swap(array[i++], array[j]); //左侧索引自增，直到找到一个比待比较值大的元素 while(i &lt; j &amp;&amp; array[i] &lt;= xData) ++i; if(i &lt; j) swap(array[i], array[j--]); &#125; //跳出循环后，索引i对应的就是xData的值 array[i] = xData; qsort2(array, begin, i - 1); qsort2(array, i + 1, end);&#125; 第三种类似于第二种，参考：http://developer.51cto.com/art/201403/430986.htm 12345678910111213141516171819202122232425void qsort3(int *array, int begin, int end)&#123; if(begin &gt;= end) return; int i = begin, j = end; //依然设置第一个值为待比较值 int xData = array[begin]; while(i &lt; j) &#123; //当右边索引对应的值一直比待比较值大时，索引左移 while(i &lt; j &amp;&amp; array[j] &gt;= xData) --j; //左侧索引自增，直到找到一个比待比较值大的元素 while(i &lt; j &amp;&amp; array[i] &lt;= xData) ++i; if(i &lt; j) swap(array[i], array[j]); &#125; //此时array[i]对应的值是要比xData小的 //交换之后xData左边的值都比xData小了 swap(array[begin], array[i]); qsort2(array, begin, i - 1); qsort2(array, i + 1, end);&#125; 2018-03-15更新需要注意的是，这里的“swap(array[i], array[j]);”是不能改成“swap(array[i++], array[j–]);”为什么呢，考虑这样一种情况，在pivot为3，而i指向5，j指向2，i和j中间为4时i和j交换之后，都指向4，此时不满足条件循环退出。但i指向的不是比pivot小的值，导致错误。 参考qt-everywhere中的原码，可以在退出循环之后，加上如下判断12if(array[i] &gt; pivot) i--; 希尔排序原理是一种复杂的插入排序。简单插入排序是每次步长都为1的，而希尔排序选取的步进是一个递减的序列，最后一个值为1。为什么希尔排序比较快还是没搞懂，参考知乎：https://www.zhihu.com/question/24637339 实现有两种排序方法，类似12345678910111213141516void shellSort1(int *array, int size)&#123; int gap = size/2; while(gap &gt;= 1) &#123; //下面这部分逻辑和简单插入排序是类似的 for(int i = gap; i &lt; size; ++i) &#123; for(int j = i - gap; (j &gt;= 0) &amp;&amp; (array[j] &gt; array[j + gap]); j -= gap)&#123; swap(array[j + gap] ,array[j]); &#125; &#125; gap /= 2; //步进每次除2，直到步进为1则退化为简单插入排序 &#125;&#125; 1234567891011121314151617void shellSort2(int *array, int size)&#123; int gap = size/2; while(gap &gt;= 1) &#123; //下面这部分逻辑和简单插入排序是类似的 for(int i = gap; i &lt; size; ++i) &#123; int curData = array[i]; int j = 0; for(j = i - gap; j &gt;= 0 &amp;&amp; array[j] &gt; curData; j -= gap) array[j + gap] = array[j]; array[j + gap] = curData; &#125; gap /= 2; //步进每次除2，直到步进为1则退化为简单插入排序 &#125;&#125; 20180301更新还有一种比较迷惑人的错误写法，被坑几次123456789101112131415161718void shellSort_error(int arr[], int size)&#123; int gap = size / 2; while(gap &gt;= 1) &#123; for(int i = gap; i &lt; size; ++i) &#123; int j; int temp = arr[i]; //这里可能导致越界 //比如gap=4，j = 3时，j&gt;0任然满足，但是j-gap已经越界 for(j = i; j &gt; 0 &amp;&amp; arr[j - gap] &gt; temp; j -= gap) arr[j] = arr[j - gap]; arr[j] = temp; &#125; gap /= 2; &#125;&#125; 堆排序原理 首先什么是堆。堆是一棵完全二叉树，若任意一个节点的值不小于子节点的值，称为大根堆；若任意节点的值不大于子节点的值，称为小根堆。 堆排序的步骤，以升序为例– 将数组构造成大根堆– 交换根节点的值（最大值）与最后一个节点的值– 调整除最后一个节点之外的n-1个值为大根堆– 重复步骤2 参考：https://jingyan.baidu.com/article/5225f26b057d5de6fa0908f3.html 实现1234567891011121314151617181920212223242526272829303132333435363738394041void adjustHeap(int *array, int parent, int size)&#123; //若大于这个值，则其已没有子节点，不需要调整 if(parent &gt; (size/2 - 1)) return; //左右节点的索引 int lchild = parent * 2 + 1, rchild = parent * 2 + 2; //父，左，右三个节点最大值的索引 int max = parent; if(lchild &lt; size &amp;&amp; array[lchild] &gt; array[max]) max = lchild; if(rchild &lt; size &amp;&amp; array[rchild] &gt; array[max]) max = rchild; //最大节点不是父节点时 if(max != parent) &#123; //交换父节点与最大节点的值 swap(array[parent], array[max]); //被交换的最大节点对应的子树，可能不是一个大根堆了，所以需要调整 adjustHeap(array, max, size); &#125;&#125;void buildHeap(int *array, int size)&#123; //这里i的起始值为，非叶子节点的最后一个节点的值。 //画一个图表示一下就知道了 for(int i = size/2 - 1; i &gt;= 0; --i) adjustHeap(array, i, size);&#125;void heapSort(int *array, int size)&#123; buildHeap(array, size); for(int i = size - 1; i &gt;= 0; --i) &#123; //交换根节点和当前无序区最后一个节点的值 swap(array[0], array[i]); adjustHeap(array, 0, i); &#125;&#125; -2018-01-22更新 参考《数据结构与算法分析》所述下滤过程，可将调整堆的过程写为如下，不用递归:123456789101112131415161718192021inline int leftchild(int i)&#123; return 2 * i + 1;&#125;void percolateDown(std::vector&lt;int&gt; &amp;array, int index, int size)&#123; int temp; int child; for(temp = array[index]; leftchild(index) &lt; size; index = child) &#123; child = leftchild(index); if(child != size - 1 &amp;&amp; array[child] &lt; array[child + 1]) child++; if(array[child] &gt; temp) array[index] = array[child]; else break; &#125; array[index] = temp;&#125; 性能比较与总结使用srand和rand函数生成10万个随机数，分别使用以上的各种排序算法，进行排序。 并使用GetTickCount函数计算函数运行时间，结果如下 1234567891011121314bubbleSort elapse time: 55422 mscocktailSort elapse time: 47234 msselectSort elapse time: 20250 msinsertSort1 elapse time: 18141 msinsertSort2 elapse time: 10969 msmergeSort1 elapse time: 46 msmergeSort2 elapse time: 32 msmergeSort3 elapse time: 31 msqsort1 elapse time: 31 msqsort2 elapse time: 16 msqsort3 elapse time: 31 msshellSort1 elapse time: 47 msshellSort2 elapse time: 11516 msheapSort elapse time: 46 ms 可以看出归并排序，快速排序，希尔排序，堆排序，真的是很快。 （希尔排序的第二种写法可以放弃了） 膜拜各位发明算法的大神。 上面这些排序算法，虽然都用代码实现了，但没有图表示，有些还是比较难理解的。后面有时间的话补上。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++常用知识点","date":"2017-12-24T09:23:51.000Z","path":"2017/12/24/C++常用知识点/","text":"使用C++实现单链表操作SingleList.h 123456789101112131415161718192021222324252627282930#ifndef SINGLELIST_H#define SINGLELIST_H#include \"stdio.h\"class SingleList&#123;public: SingleList(); ~SingleList() &#123; clear(); &#125; void print(); int length(); void insert(int pos, int data); void append(int data); void remove(int pos); void reverse();private: struct Node &#123; int data; Node *next; Node(int d) : data(d), next(nullptr) &#123;&#125; ~Node() &#123; printf(\"node released. data:%d\\n\", data); &#125; &#125;; void clear(); int len; Node *head;&#125;;#endif // !SINGLELIST_H SingleList.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include \"stdafx.h\"#include \"SingleList.h\"SingleList::SingleList()&#123; len = 0; head = new Node(0);&#125;void SingleList::clear()&#123; Node *p = head, *q; while (p) &#123; q = p-&gt;next; delete p; p = q; &#125;&#125;int SingleList::length()&#123; return len;&#125;void SingleList::append(int data)&#123; insert(length(), data);&#125;void SingleList::insert(int pos, int data)&#123; if (pos &lt; 0 || pos &gt; len) &#123; printf(\"insert pos:%d is not valid.\\n\", pos); return; &#125; Node *p = head; while (pos) &#123; pos--; p = p-&gt;next; &#125; Node *q = new Node(data); q-&gt;next = p-&gt;next; p-&gt;next = q; len++;&#125;void SingleList::print()&#123; Node *p = head-&gt;next; if (!p) &#123; printf(\"List is null\\n\"); return; &#125; int i = 0; while (p) &#123; printf(\"Node(%d):%d\\n\", i++, p-&gt;data); p = p-&gt;next; &#125;&#125;void SingleList::remove(int pos)&#123; if (pos &lt; 0 || pos &gt;= len) &#123; printf(\"insert pos:%d is not valid.\\n\", pos); return; &#125; Node *p = head, *q; if (pos == 0) &#123; q = p-&gt;next; head-&gt;next = q-&gt;next; delete q; len--; return; &#125; while (pos) &#123; p = p-&gt;next; pos--; &#125; q = p-&gt;next; p-&gt;next = q-&gt;next; delete q; len--;&#125;void SingleList::reverse()&#123; if (len == 0 || len == 1) return; Node *p = head-&gt;next, *q = head-&gt;next-&gt;next, *t; p-&gt;next = nullptr; while (q) &#123; t = q-&gt;next; q-&gt;next = p; p = q; q = t; &#125; head-&gt;next = p;&#125; 使用多态时的注意点 待继承的函数必须为virtual 父类的引用或指针才能实现多态，变量不行 1234567891011121314151617181920212223class A&#123;public: //必须是virtual virtual void print() &#123; printf(\"this is A\\n\"); &#125;;class B : public A&#123;public: void print() &#123; printf(\"this is B\\n\"); &#125;&#125;;int main()&#123; A &amp;a = B(); a.print(); //或者 // A *a = new B() // a-&gt;print() // 若使用A a = B(),则不能实现多态 return 0;&#125; 汉诺塔问题123456789101112131415161718192021222324252627282930313233void move(int num, char from, char to)&#123; printf(\"move %d from %c to %c\\n\", num, from, to);&#125;//正常答案//n:深度, from:起始，to:终止，mid:借助的中间void hannoi(int depth, char from, char mid, char to)&#123; if(depth == 1) move(1, from, to); else &#123; hannoi(depth-1, from, to, mid); move(depth, from, to); hannoi(depth-1, mid, from, to); &#125;&#125;//我一开始理解成只能相邻两个之间移动时的做法//即不能从A-&gt;C,只能A-&gt;B-&gt;Cvoid func(int depth, char from, char to)&#123; if(depth &lt;= 0 || from == to) &#123; return; &#125; else &#123; func(depth-1, from, to); move(depth, from, 'B'); func(depth-1, to, from); move(depth, 'B', to); func(depth-1, from, to); &#125; &#125; 重载输入输出流12345678910111213141516171819202122232425262728293031323334353637//必须声明为友元函数,这样就能不创建对象而直接调用函数。class Fruit&#123;public: Fruit(string name, string color) &#123; name_ = name; color_ = color; &#125; friend istream&amp; operator&gt;&gt;(istream &amp;, Fruit &amp;); friend ostream&amp; operator&lt;&lt;(ostream &amp;, Fruit &amp;); private: string name_; string color_;&#125;;istream&amp; operator&gt;&gt;(istream &amp;in, Fruit &amp;fruit)&#123; in &gt;&gt; fruit.color_ &gt;&gt; fruit.name_; if(!in) cerr &lt;&lt; \"Wrong input\" &lt;&lt; endl; return in;&#125;ostream&amp; operator&lt;&lt;(ostream &amp;out, Fruit &amp;fruit)&#123; out &lt;&lt; fruit.color_ &lt;&lt; \" \" &lt;&lt; fruit.name_ &lt;&lt; endl; return out;&#125;int main()&#123; Fruit apple(\"\", \"\"); cin &gt;&gt; apple; cout &lt;&lt; apple; return 0;&#125; 读写文件读取文件12345678910111213141516171819202122232425262728293031323334void readfile()&#123; char *fname = \"log.txt\"; ifstream inFile(fname); if(!inFile) &#123; printf(\"open file %s file failed\\n\", fname); return; &#125; //逐个读取 /*char ch; while(!inFile.eof()) &#123; inFile.read(&amp;ch, 1); cout &lt;&lt; ch; &#125;*/ //逐行读取 char line[1024]; while(!inFile.eof()) &#123; inFile.getline(line, 100); cout &lt;&lt; line &lt;&lt; endl; &#125; inFile.close(); //以空格为分隔符，将数据读到数组中 /*std::vector&lt;int&gt; array; int data; while(!inFile.eof()) &#123; inFile &gt;&gt; data; array.push_back(data); &#125;*/ &#125; 写文件12345678910void writeFile()&#123; ofstream out(\"out.txt\"); if (out.is_open()) &#123; out &lt;&lt; \"This is a line.\\n\"; out &lt;&lt; \"This is another line.\\n\"; out.close(); &#125; &#125; 指向常量的指针和常指针12345678910const int constData = 15;//指向常量的指针，或者int const *ptr = &amp;constData;const int *ptr = &amp;constData;*ptr = 10; //编译错误ptr = nullptr; //okint data = 10;int *const ptr2 = &amp;data;*ptr2 = 5; //okptr2 = nullptr; // 编译错误 指针数组与数组指针123456789int array[3] = &#123;1, 3, 5&#125;;//数组指针，指向数组的指针int (*arrayPtr)[3];arrayPtr = &amp;array;printf(\"data 0 :%d\\n\", **arrayPtr);//指针数组，每一个元素都是指针char *arrayPtr2[3] = &#123;\"I\", \"Love\", \"China\"&#125;;printf(\"data 1 :%s\\n\", arrayPtr2[1]); 函数指针指向函数的指针1234567891011int func(int in)&#123; return in + 10;&#125;void testFuncPtr()&#123; int (*funcPtr)(int); funcPtr = func; printf(\"%d\\n\", (*funcPtr)(5));&#125; 类的静态成员需要在类外初始化，即使是private1234567891011121314class Object&#123;public: static int shareData() &#123; return shareData_; &#125;private: static int shareData_;&#125;;//不加会报unresolved externalsint Object::shareData_ = 0;void testStaticMember()&#123; printf(\"%d\\n\", Object::shareData());&#125; 求最大公约数1234567891011void gcd(int numA, int numB)&#123; int temp; while(numB) &#123; temp = numB; numB = numA % numB; numA = temp; &#125; printf(\"gcd is %d\\n\", numA);&#125; 数组定义及初始化定义 静态12345678910111213141516171819//静态一维数组int array1[100]; //定义int array2[2] = &#123;1, 3&#125;; //定义并初始化int array3[] = &#123;1, 3, 5, 7&#125;; //可以不指定长度//静态二维数组int array4[10][10];int array5[3][2] = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;int array6[][3] = &#123;&#123;1, 2, 3&#125;, &#123;2, 3, 4&#125;&#125;; //第一个维度可以不指定//动态一数组int *array7 = new int[5]; delete[] array7; //定义int *array8 = new int[3]&#123;1, 3, 5&#125;; delete []array8;//定义并初始化//动态二维数组int (*array10)[2] = new int[3][2]; delete []array10;int (*array11)[2] = new int[3][2]&#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;delete []array11;//变长动态二维数组int **array = new int*[n];for(int i = 0; i &lt; n; ++i) array[i] = new int[n]; 参数传递12345void func1(int *array)&#123;&#125;void func2(int array[])&#123;&#125;void func3(int array[][10])&#123;&#125;void func4(int (*array)[2])&#123;&#125;void func5(int **array)&#123;&#125; 使用std::min时报错添加了windows.h和algorithm头文件时，如下使用报错12int a = 1, b = 2;int c = std::min(a, b); error C2589: ‘(‘: illegal token on right side of ‘::’ 可以修改成如下，解决错误1(std::min)(a, b) 参考：http://www.cppblog.com/matrix/archive/2010/08/05/122329.html 递归的性能到底有多差来看下面计算斐波那契数列时递归和非递归的差距1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;windows.h&gt;long fib_recurisive(int n)&#123; if(n &lt;= 0) &#123; printf(\"error num:%d\\n\", n); return 0; &#125; else if(n &lt;= 2) return n; else return fib_recurisive(n - 1) + fib_recurisive(n - 2);&#125;long fib_normal(int n)&#123; if(n &lt;= 0) &#123; printf(\"error num:%d\\n\", n); &#125; else if(n &lt;= 2) return n; long temp[2] = &#123;1, 2&#125;; for(int i = 3; i &lt;= n; ++i) &#123; int t = temp[0]; temp[0] = temp[1]; temp[1] += t; &#125; return temp[1];&#125;int main()&#123; long begin, end, result; begin = GetTickCount(); result = fib_recurisive(45); end = GetTickCount(); printf(\"fib_recurisive(%d):%ld elapse time :%ld ms\\n\", 45, result, end - begin); begin = GetTickCount(); result = fib_normal(45); end = GetTickCount(); printf(\"fib_normal(%d):%ld elapse time :%ld ms\\n\", 45, result, end - begin); return 0;&#125; 输出12fib_recurisive(45):1836311903 elapse time :9062 msfib_normal(45):1836311903 elapse time :0 ms 以后还是能不用递归就不用递归吧。 求解序列的最大子序列和比如{-2, 11, -4, 13, -5, -2}的最大子序列和为20 1234567891011121314//最大子序列和void maxSubSum(int *array, int size)&#123; int thisSum = 0, maxSum = 0; for(int i = 0; i &lt; size; ++i) &#123; thisSum += array[i]; if(thisSum &gt; maxSum) maxSum = thisSum; else if(thisSum &lt; 0) thisSum = 0; &#125; printf(\"maxSum : %d\\n\", maxSum);&#125; 字符串逆序 方法一123456789101112void reverse(char *str)&#123; int len = strlen(str); //分别指向第一个和最后一个字符 char *p = str, *q = str + len -1; while(p &lt; q) &#123; char t = *p; *p++ = *q; *q-- = t; &#125;&#125; 需要注意的是，不能像下面这么调用12char *str = \"hello, world\";reverse(str)； 这么调用编译可以通过，但是运行会崩溃，因为这里的str其实应该是const char*，值是不可更改的。可以像下面这么调用12char str[] = \"hello, world\";reverse(str)； 方法二1234567891011121314char *reverse2(const char *src)&#123; const int size = strlen(src); char *dst = new char[size + 1]; //指向原数组最后一个字符 const char *p = src + size - 1; //指向目标数组 char *q = dst; int len = size; while(len--) *q++ = *p--; *q = '\\0'; return dst;&#125; 注意额外分配的内存，用完后需要释放的 奶牛生子问题描述：一只刚出生的奶牛，第4年开始生一只奶牛，以后每年生一只。现在给你一只刚出生的奶牛，求20年后有多少奶牛？ 方法一123456789101112//递归最简单int cowCount(int year)&#123; if(year &lt; 0) return 0; if(year == 1 || year == 2 || year == 3) return 1; if(year == 4) return 2; //前一年的数量，加上4年前生产的小牛数量（因为4年后小牛也开始生产了） return cowCount(year - 1) + cowCount(year - 4);&#125; 打印N * N矩阵1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//输入长度n，打印矩阵，格式为螺旋型如下（n为4时）// 1 2 3 4// 12 13 14 5// 11 16 15 6// 10 9 8 7//想法是将矩阵数据先保存到二维数组中，然后统一打印。//保存的方法上将整个矩阵分解成一层一层嵌套的正方形。//比如上面的矩阵可以分解成(1~12)和(13~16)的两个正方形//其中每个正方形的数据又可以分为四条边的数据void printMatrix(int n)&#123; std::vector&lt;std::vector&lt;int&gt;&gt; array(n, std::vector&lt;int&gt;(n)); //每个正方形最左上角开始的值 int start = 1; //最多有(n+1)/2 个正方形 for(int i = 0; i &lt; (n + 1) / 2; ++i) &#123; //正方形的宽度，每层递减2 int width = n - 2 * i; //宽度小于1，异常了退出 if(width &lt; 1) break; //宽度为1，最中心的一个点，特殊处理 if(width == 1) array[i][i] = n*n; //这里开始计算每条边的数据 //注意为了防止重复计算，每条边只计算(width-1)个数据 for(int j = 0; j &lt; width - 1; ++j) &#123; //上边，横坐标为i，因为第一个正方形横坐标为0，第二个正方形横坐标为1.. //纵坐标同样要加上初始值i，理由同上 array[i][j + i] = start + j; //右边 array[j + i][n - 1 - i] = start + j + width- 1; //下边 array[n - 1 - i][ width + i - 1 - j] = start + j + 2 * width - 2; //左边 array[width + i - 1 - j][i] = start + j + 3 * width - 3; &#125; start += 4 * width - 4; &#125; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; printf(\"%3d \", array[i][j]); &#125; printf(\"\\n\"); &#125;&#125; 算法2123456789101112131415161718192021222324252627282930void printMatrix2(int n) &#123; std::vector&lt;std::vector&lt;int&gt;&gt; array(n, std::vector&lt;int&gt;(n)); int i, j, round=0; int m = 1; //这里不设置的话，n为1时不正确 array[0][0] = 1; for(i=n-1;i&gt;=n/2;i--) &#123; //上边（注意每个边只计算k-1个值，这样四条边正好可以首尾连接起来） for(j = round; j &lt; i; ++j) array[round][j] = m++; //右边 for(j = round; j&lt; i; j++) array[j][i] = m++; //下边 for(j = i; j &gt; round; --j) array[i][j] = m++; //左边 for(j = i; j &gt; round; --j) array[j][round] = m++; round++; &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) printf(\"%3d\",array[i][j]); printf(\"\\n\"); &#125;&#125; 2018-03-15更新上面算法二是错误的，对于奇数的n，最后一个值，不能正确地赋值。更新如下123456789101112131415161718192021222324252627282930void printMatrix2(int n) &#123; std::vector&lt;std::vector&lt;int&gt;&gt; array(n, std::vector&lt;int&gt;(n)); int i, j, round = 0; int m = 1; for(i = n - 1; i &gt;= n / 2; i--) &#123; if(i == round) array[round][round] = m++; //上边（注意每个边只计算k-1个值，这样四条边正好可以首尾连接起来） for(j = round; j &lt; i; ++j) array[round][j] = m++; //右边 for(j = round; j&lt; i; j++) array[j][i] = m++; //下边 for(j = i; j &gt; round; --j) array[i][j] = m++; //左边 for(j = i; j &gt; round; --j) array[j][round] = m++; round++; &#125; for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; n; j++) printf(\"%3d\", array[i][j]); printf(\"\\n\"); &#125;&#125; 找出两个数中的大者，不用判断1int max = ((a + b) + abs(a - b))/2 各种字符串操作原型strcpy原型12345678910char *strcpy(char *dst, char *src)&#123; if(!dst || !src) return nullptr; if(dst == src) return dst; char *tmp = dst; while((*dst++ = *src++) != '\\0'); return tmp;&#125; strcat原型123456789101112131415char *mystrcat(char *dst, const char *src)&#123; if(!dst || !src) return dst; char *p = dst; while(*++p); while((*p++ = *src++) != '\\0'); return dst;&#125;void test()&#123; char dst[50] = \"i love \"; const char *src = \"China\"; printf(\"%s\\n\", mystrcat(dst, src));&#125; strcmp原型123456789101112131415161718int strcmp(const char *left, const char *right)&#123; assert(left != nullptr &amp;&amp; right != nullptr); while(*left &amp;&amp; *right &amp;&amp; (*left == *right)) &#123; ++left; ++right; &#125; return *left - *right;&#125;void test()&#123; char *s1 = \"#\"; char *s2 = \"#\"; printf(\"%d\\n\", strcmp(s1, s2)); //0 //这里要注意 printf(\"%d\\n\", s1 == \"#\"); //false&#125; 判断单链表有环定义指针slow和fast，slow每次移动一格，fast每次移动两格，如果有环，则两者必然重逢。 这就像圆形跑道，跑的快的一定会和跑的跑的慢点相逢，只要时间够长1234567891011121314bool checkHasLoop(Node *head)&#123; if(!head) return false; Node *slow = head, *fast = head-&gt;next_; while(fast &amp;&amp; fast-&gt;next_) &#123; slow = slow-&gt;next_; fast = fast-&gt;next_-&gt;next_; if(slow == fast) return true; &#125; return false;&#125; 求解整数二进制数中1的个数123456789101112int getCountOf1(unsigned int n)&#123; int count = 0; //n为0时则没有1了 while(n) &#123; ++count; //清除最右边的1 n = n &amp; (n - 1); &#125; return count;&#125; 变长数组问题一直以来的一个印象就是，C中定义的数组长度不能是变量比如123int n = 5;...int arr[n]; 应当是不合法的，毕竟n可以改变。但是实际测试发现，这种写法在g++中是合法的，在cl中不合法。cl中必须声明为const int n=5这种才行。感觉微软的这种比较严谨啊。参考：https://www.zhihu.com/question/267434944","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++智能指针","date":"2017-12-18T12:23:51.000Z","path":"2017/12/18/C++智能指针/","text":"2018-3-24根据《C++ Primer第五版》相关内容更新 定义智能指针是在 标头文件中的 std 命名空间中定义的。 C++标准库智能指针 测试对象定义1234567891011121314151617181920212223class Object&#123;public: explicit Object(const std::string &amp;name) &#123; name_ = name; &#125; ~Object() &#123; printf(\"~Object\\n\"); &#125; void print() const &#123; printf(\"hello :%s\\n\", name_.c_str()); &#125; void setChild(std::shared_ptr&lt;Object&gt; child) &#123; child_ = child; &#125;private: std::shared_ptr&lt;Object&gt; child_; std::string name_;&#125;; unique_ptr只允许基础指针的一个所有者，某个时刻只能有一个unique_ptr指向一个给定对象 创建 123456//使用指针直接创建，不推荐auto unique1 = std::unique_ptr&lt;Object&gt;(new Object(\"kdb\"));unique1-&gt;print();//使用make_unique创建，推荐auto unique2 = std::make_unique&lt;Object&gt;(\"kdb\");unique2-&gt;print(); 赋值 12345678910111213auto unique1 = std::make_unique&lt;Object&gt;(\"kdb\");auto unique2 = unique1; //编译错误auto unique1 = std::make_unique&lt;Object&gt;(\"kdb\");std::unique_ptr&lt;Object&gt; unique2(unique1); //编译错误//使用同一裸指针定义多个unique_ptr，会导致崩溃。//因为裸指针指向的内存会被删除多次Object *rawPtr = new Object(\"kdb\");std::unique_ptr&lt;Object&gt; unique1(rawPtr);unique1-&gt;print();std::unique_ptr&lt;Object&gt; unique2(rawPtr);unique2-&gt;print();//调用完成之后崩溃 移动 1234auto unique1 = std::make_unique&lt;Object&gt;(\"kdb\");auto unique2 = std::move(unique1);unique2-&gt;print(); //OKunique1-&gt;print(); //崩溃，原unique_ptr已无效 示例：向量中使用unique_ptr 123456789std::vector&lt;std::unique_ptr&lt;Object&gt;&gt; objects;objects.push_back(std::make_unique&lt;Object&gt;(\"123\"));objects.push_back(std::make_unique&lt;Object&gt;(\"334\"));objects.push_back(std::make_unique&lt;Object&gt;(\"567\"));//主要这里不使用引用会导致编译错误for(auto const &amp;object : objects)&#123; object-&gt;print();&#125; 示例，创建指向数组的unique_ptr 123456789101112//裸指针方式//int *array = new int[5];//unique_ptr方式auto array = std::make_unique&lt;int[]&gt;(5);for(int i = 0; i &lt; 5; i++)&#123; array[i] = i;&#125;for(int i = 0; i &lt; 5; i++)&#123; cout &lt;&lt; array[i] &lt;&lt; endl;&#125; 总结而言：可移动，但不可复制 返回unique_ptr不能拷贝unique_ptr的规则有一个例外，可以拷贝或赋值给一个将要被销毁的unique_ptr 1234567891011121314151617std::unique_ptr&lt;Object&gt; clone1(const Object &amp;obj)&#123; return std::make_unique&lt;Object&gt;(obj);&#125;std::unique_ptr&lt;Object&gt; clone2(const Object &amp;obj)&#123; Object *pobj = new Object(obj); return std::unique_ptr&lt;Object&gt;(pobj);&#125;void test_unique_ptr_return()&#123; Object obj(\"11\"); auto pobj = clone1(obj); auto pobj2 = clone2(obj);&#125; 向unique_ptr传递删除器参考下面shared_ptr的例子 123456void f2(destination &amp;d)&#123; connection c = connect(&amp;d); std::unique_ptr&lt;connection, decltype(end_connection)*&gt; p(&amp;c, end_connection);&#125; 它比shared_ptr要麻烦点，为什么会产生这种区别？总结而言就一句话，shared_ptr是运行时绑定删除器，unique_ptr是编译时绑定删除器 shared_ptr采用引用计数的智能指针。 创建 12345678910//推荐auto shared1 = std::make_shared&lt;Object&gt;(\"kdb\");shared1-&gt;print();//传入裸指针，不推荐auto shared2 = std::shared_ptr&lt;Object&gt;(new Object(\"kdb\"));shared2-&gt;print();//声明和初始化需要分开时，传入nullptrstd::shared_ptr&lt;Object&gt; shared3(nullptr);shared3 = std::make_shared&lt;Object&gt;(\"kdb\");shared3-&gt;print(); 复制与C++对象类似 123456auto shared1 = std::make_shared&lt;Object&gt;(\"kdb\");auto shared2 = shared1;auto shared3(shared1);shared1-&gt;print();shared2-&gt;print();shared3-&gt;print(); 存在问题：嵌套引用时导致内存泄漏 123456auto shared1 = std::make_shared&lt;Object&gt;(\"kdb\");auto shared2 = std::make_shared&lt;Object&gt;(\"233\");shared1-&gt;setChild(shared2);shared2-&gt;setChild(shared1);cout &lt;&lt; \"shared1 count:\" &lt;&lt; shared1.use_count() &lt;&lt; endl; //2cout &lt;&lt; \"shared2 count:\" &lt;&lt; shared2.use_count() &lt;&lt; endl; //2 吐槽一下，这是之前找的例子，其实非常不好，没有哪个神经病会把A设为B的孩子，又把B设为A的孩子吧。还是双链表的例子有代表性。 神奇的引用计数引用计数（reference count）到底是什么，为什么有了它，资源就可以共享，而且能被自动释放呢？来看Primer中的描述的规则 拷贝一个shared_ptr，计数器会递增，比如以下几种情况 用一个shared_ptr初始化另一个shared_ptr 将shared_ptr作为参数传递给一个函数 shared_ptr作为返回值 给shared_ptr赋予一个新值或是shared_ptr被销毁，计数器会递减，比如离开作用域 一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象 光看描述还是有点抽象，还是用例子说明吧。(shared_ptr的成员函数use_count用来表示引用计数) 12345678910111213141516171819void test_case_1()&#123; auto pobj1 = std::make_shared&lt;Object&gt;(\"11\"); //拷贝构造，引用计数+1 auto pobj2(pobj1); //这里有一个新的作用域 &#123; //注意这里的赋值其实还是拷贝构造，引用计数+1 auto pobj3 = pobj1; assert(pobj1.use_count() == 3 &amp;&amp; pobj2.use_count() == 3 &amp;&amp; pobj3.use_count() == 3); &#125;// 出作用域之后pobj3对应的shared_ptr被销毁，引用计数-1 //此时还剩下两个shared_ptr指向创建的Object对象 assert(pobj1.use_count() == 2 &amp;&amp; pobj2.use_count() == 2); //原shared_ptr被赋予一个新值，引用计数-1 pobj2 = std::make_shared&lt;Object&gt;(\"22\"); //注意这里的pobj1和pobj2是指向的两个不同的Object对象 assert(pobj1.use_count() == 1 &amp;&amp; pobj2.use_count() == 1);&#125;//到这里退出作用域之后，pobj1和pobj2的引用计数分别-1，为0之后析构原对象 函数传参，返回等的例子1234567891011121314151617181920212223242526272829303132333435363738void func_by_value_no_return(std::shared_ptr&lt;Object&gt; pobj)&#123; //这里引用计数会变成2，因为函数的参数为值传递时，会有一次拷贝 assert(pobj.use_count() == 2); //do some stuff with pobj...&#125;//退出作用域之后，这里的pobj被销毁，引用计数-1void func_by_refer_no_return(const std::shared_ptr&lt;Object&gt; &amp;pobj)&#123; //传引用时，不会存在参数的拷贝，引用计数也不会改变 assert(pobj.use_count() == 1); //do some stuff with pobj...&#125;std::shared_ptr&lt;Object&gt; func_by_value_has_return(std::shared_ptr&lt;Object&gt; pobj)&#123; //这里引用计数会变成2，原因同上 assert(pobj.use_count() == 2); //do some stuff with pobj... //将参数返回 return pobj; //参数返回时，会存在一次拷贝，引用计数+1&#125;//pobj本身退出作用域之后，引用计数-1。void test_case_2()&#123; auto pobj = std::make_shared&lt;Object&gt;(\"11\"); //初始创建后，引用计数为1 assert(pobj.use_count() == 1); func_by_value_no_return(pobj); //函数退出之后，引用计数依然为1（有一次+1，一次-1的过程） assert(pobj.use_count() == 1); func_by_refer_no_return(pobj); //函数退出之后，引用计数依然为1（一直未动） assert(pobj.use_count() == 1); auto pobj2 = func_by_value_has_return(pobj); //函数退出之后，引用计数为2（有两次+1，一次-1的过程） assert(pobj.use_count() == 2);&#125; 按我的理解，大白话说引用计数就是：表示总共有多少个指针指向实际对象；有拷贝时，表示多了一个指针指向实际对象，自然计数+1；有销毁时，表示少了一个指针指向实际对象，自然计数-1；没有指针指向实际对象时（计数为0），自然要销毁实际对象 使用shared_ptr来管理资源shared_ptr不仅可以用来管理内存，也可以管理相关资源，书中有个非常好的例子 123456789101112131415struct destination &#123;&#125;; //表示我们正在连接什么struct connection &#123;&#125;; //表示我们连接所需的信息connection connect(destination*) //打开连接&#123; return connection(); &#125; void disconnect(connection) &#123;&#125; //关闭给定的连接void end_connection(connection *p) // 删除器函数&#123; disconnect(*p); &#125;void f(destination &amp;d)&#123; //获得一个连接；记住使用完记得要关闭它 connection c = connect(&amp;d); std::shared_ptr&lt;connection&gt; p(&amp;c, end_connection); //使用连接 //f退出时（即使是因为异常），connection也会被正确关闭&#125; weak_ptr结合 shared_ptr 使用的特例智能指针。 weak_ptr 提供对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。 将类中的成员变量类型改成weak_ptr类型，则上述嵌套引用导致的内存泄漏不存在了 再来看一个循环引用的例子12345678910111213141516171819202122232425//双向链表struct Node&#123; Node(int data) :data_(data) &#123;&#125; ~Node() &#123; printf(\"Node deconstructor, data:%d\\n\", data_); &#125; int data_; std::shared_ptr&lt;Node&gt; prev_; std::shared_ptr&lt;Node&gt; next_;&#125;;void testDoubleList()&#123; auto node1 = std::make_shared&lt;Node&gt;(1); auto node2 = std::make_shared&lt;Node&gt;(2); node1-&gt;next_ = node2; node2-&gt;prev_ = node1; //引用计数为2导致资源泄漏 printf(\"node1 count:%d\\n\", node1.use_count()); //2 printf(\"node2 count:%d\\n\", node2.use_count()); //2&#125; 修改Node中的成员为weak_ptr则可以解决该问题123456789101112131415161718192021222324252627//双向链表struct Node&#123; Node(int data) :data_(data) &#123;&#125; ~Node() &#123; printf(\"Node deconstructor, data:%d\\n\", data_); &#125; int data_; std::weak_ptr&lt;Node&gt; prev_; std::weak_ptr&lt;Node&gt; next_; //shared_ptr&lt;Node&gt; prev_; //shared_ptr&lt;Node&gt; next_;&#125;;void testDoubleList()&#123; auto node1 = std::make_shared&lt;Node&gt;(1); auto node2 = std::make_shared&lt;Node&gt;(2); node1-&gt;next_ = node2; node2-&gt;prev_ = node1; //资源释放 printf(\"node1 count:%d\\n\", node1.use_count()); //1 printf(\"node2 count:%d\\n\", node2.use_count()); //1&#125; weak_ptr本身没有重载operator * 和-&gt;，所以不具有普通指针的行为 lock函数可以获得一个可用的shared_ptr，从而操作资源。 参考 C++中智能指针的学习 智能指针（现代 C++） 创建和使用 unique_ptr 实例 创建和使用 shared_ptr 实例 创建和使用共享 weak_ptr 实例 shared_ptr造成的循环引用 立个flag，有时间一定按照自己的理解把三个智能指针自己实现一遍","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"大话设计模式笔记","date":"2017-12-06T12:23:51.000Z","path":"2017/12/06/大话设计模式/","text":"以下为使用C++实现《大话设计模式》中的各种设计模式 简单工厂模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;class Operation&#123;public: virtual ~Operation() &#123; cout &lt;&lt; \"~Operation\" &lt;&lt; endl; &#125; void setNum1(double num) &#123; num1_ = num; &#125; void setNum2(double num) &#123; num2_ = num; &#125; virtual double getResult() &#123; return 0.0; &#125;protected: double num1_; double num2_;&#125;;class OperationAdd : public Operation&#123;public: ~OperationAdd() &#123; cout &lt;&lt; \"~OperationAdd\" &lt;&lt; endl; &#125; double getResult() &#123; return num1_ + num2_; &#125;&#125;;class OperationSub : public Operation&#123;public: ~OperationSub() &#123; cout &lt;&lt; \"~OperationSub\" &lt;&lt; endl; &#125; double getResult() &#123; return num1_ - num2_; &#125;&#125;;class OperationMulti : public Operation&#123;public: ~OperationMulti() &#123; cout &lt;&lt; \"~OperationMulti\" &lt;&lt; endl; &#125; double getResult() &#123; return num1_ * num2_; &#125;&#125;;class OperationDiv : public Operation&#123;public: ~OperationDiv() &#123; cout &lt;&lt; \"~OperationDiv\" &lt;&lt; endl; &#125; double getResult() &#123; if(fabs(num2_) &lt; 1e-15) &#123; cout &lt;&lt; \"div num cannot be zero\" &lt;&lt; endl; return 0.0; &#125; else &#123; return num1_ / num2_; &#125; &#125;&#125;;unique_ptr&lt;Operation&gt; opFactory(string op)&#123; if(op == \"+\") return make_unique&lt;OperationAdd&gt;(); else if(op == \"-\") return make_unique&lt;OperationSub&gt;(); else if(op == \"*\") return make_unique&lt;OperationMulti&gt;(); else if(op == \"/\") return make_unique&lt;OperationDiv&gt;(); else &#123; cout &lt;&lt; \"unsupported operation:\" &lt;&lt; op &lt;&lt; endl;; return nullptr; &#125;&#125;int main()&#123; double num1, num2; string op_s; cout &lt;&lt; \"please input num1:\"; cin &gt;&gt; num1; cout &lt;&lt; \"please input num2:\"; cin &gt;&gt; num2; cout &lt;&lt; \"please input operation:\"; cin &gt;&gt; op_s; auto op = opFactory(op_s); op-&gt;setNum1(num1); op-&gt;setNum2(num2); cout &lt;&lt; \"result:\" &lt;&lt; op-&gt;getResult() &lt;&lt; endl; return 0;&#125; 策略模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Strategy&#123;public: virtual ~Strategy() &#123; cout &lt;&lt; \"~Strategy\" &lt;&lt; endl; &#125; virtual void AlgorithmInterface() = 0;&#125;;class ConcreteStrategyA : public Strategy&#123;public: ~ConcreteStrategyA() &#123; cout &lt;&lt; \"~ConcreteStrategyA\" &lt;&lt; endl; &#125; void AlgorithmInterface() &#123; cout &lt;&lt; \"Algorithm A called\" &lt;&lt; endl; &#125;&#125;;class ConcreteStrategyB : public Strategy&#123;public: ~ConcreteStrategyB() &#123; cout &lt;&lt; \"~ConcreteStrategyB\" &lt;&lt; endl; &#125; void AlgorithmInterface() &#123; cout &lt;&lt; \"Algorithm B called\" &lt;&lt; endl; &#125;&#125;;class Context&#123;public: Context(shared_ptr&lt;Strategy&gt; strategy) &#123; strategy_ = strategy; &#125; ~Context() &#123; cout &lt;&lt; \"~Context\" &lt;&lt; endl; &#125; void ContextInterface() &#123; strategy_-&gt;AlgorithmInterface(); &#125;private: shared_ptr&lt;Strategy&gt; strategy_;&#125;;int main()&#123; auto algo = make_shared&lt;ConcreteStrategyA&gt;(); auto ctx = make_unique&lt;Context&gt;(algo); ctx-&gt;ContextInterface(); return 0;&#125; 示例（与简单工厂结合）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class CashSuper&#123;public: virtual ~CashSuper() &#123; cout &lt;&lt; \"~CashSuper\" &lt;&lt; endl; &#125; virtual double getCash(double money) = 0;&#125;;class CashNormal : public CashSuper&#123;public: ~CashNormal() &#123; cout &lt;&lt; \"~CashNormal\" &lt;&lt; endl; &#125; double getCash(double money)&#123; return money; &#125;&#125;;class CashSale : public CashSuper&#123;public: CashSale(double rate) : rate_(rate) &#123;&#125; ~CashSale() &#123; cout &lt;&lt; \"~CashSale\" &lt;&lt; endl; &#125; double getCash(double money)&#123; return money * rate_;&#125;private: double rate_;&#125;;class CashFullCut : public CashSuper&#123;public: CashFullCut(int full, int ret) : full_(full), ret_(ret) &#123;&#125; ~CashFullCut() &#123; cout &lt;&lt; \"~CashFullCut\" &lt;&lt; endl; &#125; double getCash(double money) &#123; for(int i = 0; i &lt; int(money/full_); i++) money -= ret_; return money; &#125;private: int full_; int ret_;&#125;;class CashContext&#123;public: CashContext(int type) &#123; switch (type) &#123; case 0: cashSuper_ = make_unique&lt;CashNormal&gt;(); break; case 1: cashSuper_ = make_unique&lt;CashSale&gt;(0.9); break; case 2: cashSuper_ = make_unique&lt;CashFullCut&gt;(200, 10); break; default: cashSuper_ = nullptr; break; &#125; &#125; ~CashContext() &#123; cout &lt;&lt; \"~CashContext\" &lt;&lt; endl; &#125; double getResult(double money) &#123; if(cashSuper_) return cashSuper_-&gt;getCash(money); return 0.0; &#125;private: unique_ptr&lt;CashSuper&gt; cashSuper_;&#125;;int main()&#123; int num; double unitPrice; int type; double sum = 0; cout &lt;&lt; \"please input num :\" &lt;&lt; endl; cin &gt;&gt; num; cout &lt;&lt; \"please input unitPrice:\" &lt;&lt; endl; cin &gt;&gt; unitPrice; cout &lt;&lt; \"please input price type:\" &lt;&lt; endl; cin &gt;&gt; type; CashContext ctx(type); cout &lt;&lt; \"sum : \" &lt;&lt; ctx.getResult(num*unitPrice) &lt;&lt; endl; return 0;&#125; 装饰模式原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Component&#123;public: virtual void Operation() = 0;&#125;;class ConcreteComponent : public Component&#123;public: void Operation() &#123; cout &lt;&lt; \"operation of concrete object\" &lt;&lt; endl; &#125;&#125;;class Decorator : public Component&#123;public: Decorator() &#123; component_ = nullptr; &#125; void setComponent(Component *component) &#123; component_ = component; &#125; void Operation() &#123; if(component_) component_-&gt;Operation(); &#125;protected: Component *component_;&#125;;class ConcreteDecoratorA : public Decorator&#123;public: void Operation() &#123; Decorator::Operation(); addedState_ = \"New State\"; cout &lt;&lt; \"decorator a\" &lt;&lt; endl; &#125;private: string addedState_;&#125;;class ConcreteDecoratorB : public Decorator&#123;public: void Operation() &#123; Decorator::Operation(); addedOperation(); cout &lt;&lt; \"decorator b\" &lt;&lt;endl; &#125; void addedOperation() &#123; cout &lt;&lt; \"added operation\" &lt;&lt; endl; &#125;&#125;;void test6()&#123; ConcreteComponent c; ConcreteDecoratorA decoratorA; ConcreteDecoratorB decoratorB; decoratorA.setComponent(&amp;c); decoratorB.setComponent(&amp;decoratorA); decoratorB.Operation();&#125; 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Person&#123;public: Person()&#123;&#125; Person(string name) &#123; name_ = name; &#125; virtual void show() &#123; cout &lt;&lt; name_ &lt;&lt; endl; &#125;private: string name_;&#125;;class Finary : public Person&#123;public: Finary() &#123; person_ = nullptr; &#125; void Decorate(Person *person) &#123; person_ = person; &#125; void show() &#123; if(person_) person_-&gt;show(); &#125;private: Person *person_;&#125;;class TShirt : public Finary&#123;public: void show() &#123; cout &lt;&lt; \"wear TShirts \"; Finary::show(); &#125;&#125;;class Suite : public Finary&#123;public: void show() &#123; cout &lt;&lt; \"wear suite \"; Finary::show(); &#125;&#125;;void test6()&#123; Person kongdb(\"kongdb\"); TShirt tshirt; Suite suite; tshirt.Decorate(&amp;kongdb); suite.Decorate(&amp;tshirt); suite.show();&#125; 2018-03-05更新：感觉对装饰模式理解的一直不很深入参考 装饰器模式 通俗易懂的谈谈装饰器模式 chromium 源码：/chromium/remoting/protocol/monitored_video_stub.h 代理模式原型12345678910111213141516171819202122232425262728293031323334353637class Subject&#123;public: virtual void request() = 0;&#125;;class ReadSubject : public Subject&#123;public: void request() &#123; cout &lt;&lt; \"real request\" &lt;&lt; endl; &#125;&#125;;class Proxy : public Subject&#123;public: Proxy() &#123; realSubj_ = nullptr; &#125; void request() &#123; if(!realSubj_) realSubj_ = new ReadSubject; realSubj_-&gt;request(); &#125;private: ReadSubject *realSubj_;&#125;;void test7()&#123; Proxy proxy; proxy.request();&#125; 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class GiveGift&#123;public: virtual void giveDolls() = 0; virtual void giveFlowers() = 0; virtual void giveChocolate() = 0; &#125;;class SchoolGirl&#123;public: SchoolGirl(string name) &#123; name_ = name; &#125; string name()&#123; return name_; &#125;private: string name_;&#125;;class Persuit : public GiveGift&#123;public: Persuit(SchoolGirl *mm) &#123; mm_ = mm; &#125; void giveDolls() &#123; cout &lt;&lt; \"give dolls for \" &lt;&lt; mm_-&gt;name() &lt;&lt; endl; &#125; void giveFlowers() &#123; cout &lt;&lt; \"give flowers for \" &lt;&lt; mm_-&gt;name() &lt;&lt; endl; &#125; void giveChocolate() &#123; cout &lt;&lt; \"give chocolate for \" &lt;&lt; mm_-&gt;name() &lt;&lt; endl; &#125;private: SchoolGirl *mm_;&#125;;class Proxy : public GiveGift&#123;public: Proxy(SchoolGirl *mm) &#123; persuit_ = new Persuit(mm); &#125; ~Proxy() &#123; delete persuit_; &#125; void giveDolls() &#123; persuit_-&gt;giveDolls(); &#125; void giveFlowers() &#123; persuit_-&gt;giveFlowers(); &#125; void giveChocolate() &#123; persuit_-&gt;giveChocolate(); &#125;private: Persuit *persuit_;&#125;;void test7()&#123; SchoolGirl mm(\"jiaojiao\"); Proxy proxy(&amp;mm); proxy.giveDolls(); proxy.giveFlowers(); proxy.giveChocolate();&#125; 工厂模式示例：加减法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Operation&#123;public: virtual ~Operation() &#123; cout &lt;&lt; \"~Operation\" &lt;&lt; endl; &#125; void setNumA(double num) &#123; numA_ = num; &#125; void setNumB(double num) &#123; numB_ = num; &#125; virtual double getResult() = 0;protected: double numA_; double numB_;&#125;;class OperationAdd : public Operation&#123;public: ~OperationAdd() &#123; cout &lt;&lt; \"~OperationAdd\" &lt;&lt; endl; &#125; double getResult() &#123; return numA_ + numB_; &#125;&#125;;class OperationSub : public Operation&#123;public: ~OperationSub() &#123; cout &lt;&lt; \"~OperationSub\" &lt;&lt; endl; &#125; double getResult() &#123; return numA_ - numB_; &#125;&#125;;class IFactory&#123;public: virtual ~IFactory() &#123; cout &lt;&lt; \"~IFactory\" &lt;&lt; endl; &#125; virtual unique_ptr&lt;Operation&gt; getOperation() = 0;&#125;;class AddFactory : public IFactory&#123;public: ~AddFactory() &#123; cout &lt;&lt; \"~AddFactory\" &lt;&lt; endl; &#125; unique_ptr&lt;Operation&gt; getOperation() &#123; return make_unique&lt;OperationAdd&gt;(); &#125;&#125;;class SubFactory : public IFactory&#123;public: ~SubFactory() &#123; cout &lt;&lt; \"~SubFactory\" &lt;&lt; endl; &#125; unique_ptr&lt;Operation&gt; getOperation() &#123; return make_unique&lt;OperationSub&gt;(); &#125;&#125;;int main()&#123; auto factoy = make_unique&lt;AddFactory&gt;(); auto operation = factoy-&gt;getOperation(); operation-&gt;setNumA(10); operation-&gt;setNumB(30); cout &lt;&lt; operation-&gt;getResult() &lt;&lt; endl; return 0;&#125; 原型模式C++中的拷贝构造函数和operator=编译器会生成默认的拷贝构造函数和operator=函数，对于只包含数据成员的类就够了（浅拷贝）1234567891011121314151617181920212223class People&#123;public: People(int age) :age_(age) &#123;&#125; int age()&#123; return age_; &#125;private: int age_;&#125;;int main()&#123; People peopleA(20); //copy constuctor People peopleB(peopleA); cout &lt;&lt; \"people B age:\" &lt;&lt; peopleB.age() &lt;&lt; endl; //20 People peopleC(30); //operator= peopleC = peopleA; cout &lt;&lt; \"people C age:\" &lt;&lt; peopleC.age() &lt;&lt; endl; //20 return 0;&#125; 但是对于包含指针成员的类，仅有默认构造函数就不够了，还会导致崩溃 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class People&#123;public: People(int age, char *name) :age_(age) &#123; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125; ~People() &#123; delete name_; &#125; int age()&#123; return age_; &#125; char *name() &#123; return name_; &#125; void setName(char *name) &#123; if(name_) &#123; cout &lt;&lt; \"release previous name\" &lt;&lt; endl; delete name_; &#125; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125;private: char *name_; int age_;&#125;;int main()&#123; People peopleA(20, \"kongdb\"); People peopleB(peopleA); People peopleC(30, \"fdg\"); peopleC = peopleA; cout &lt;&lt; peopleB.name() &lt;&lt; endl; cout &lt;&lt; peopleC.name() &lt;&lt; endl; peopleA.setName(\"other\"); cout &lt;&lt; peopleA.name() &lt;&lt; endl; //other cout &lt;&lt; peopleB.name() &lt;&lt; endl; //crash, peopleB's name_ point memory has released cout &lt;&lt; peopleC.name() &lt;&lt; endl; //crash return 0;&#125; 此时必须重载默认拷贝构造函数和operator=（深拷贝）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class People&#123;public: People(int age, char *name) :age_(age) &#123; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125; People(const People &amp;other) &#123; cout &lt;&lt; \"copy constructor\" &lt;&lt; endl; age_ = other.age_; int len = strlen(other.name_) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, other.name_); &#125; People &amp;operator=(const People &amp;rhs) &#123; cout &lt;&lt; \"operator =\" &lt;&lt; endl; if(this == &amp;rhs) return *this; delete name_; age_ = rhs.age_; int len = strlen(rhs.name_) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, rhs.name_); return *this; &#125; ~People() &#123; delete name_; &#125; int age()&#123; return age_; &#125; char *name() &#123; return name_; &#125; void setName(char *name) &#123; if(name_) &#123; cout &lt;&lt; \"release previous name\" &lt;&lt; endl; delete name_; &#125; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125;private: char *name_; int age_;&#125;;int main()&#123; People peopleA(20, \"kongdb\"); People peopleB(peopleA); People peopleC(30, \"fdg\"); peopleC = peopleA; cout &lt;&lt; peopleB.name() &lt;&lt; endl; cout &lt;&lt; peopleC.name() &lt;&lt; endl; peopleA.setName(\"otherA\"); cout &lt;&lt; peopleA.name() &lt;&lt; endl; //other cout &lt;&lt; peopleB.name() &lt;&lt; endl; //kongdb cout &lt;&lt; peopleC.name() &lt;&lt; endl; //kongdb return 0;&#125; 为什么有了拷贝构造函数，还需要prototype参考：https://www.zhihu.com/question/52610176陈硕：Prototype 的意义在于，你拿到一个 Base* ，它指向某个 Derived 对象，你想克隆出 Derived 对象，但代码中不写出 Derived 的具体类型，因为有很多派生类，这种情况下你用构造函数是搞不定的，type-switch 是 bad smells 。另外，这里考虑 virtual 的性能损失是主次不分，构造对象需要分 配内存，这开销比一次虚函数调用大多了。Prorobuf Message 就采用了 prototype 模式，你可以参考一下。 例子1234567891011121314151617181920212223242526class Base&#123;public: virtual ~Base() &#123; printf(\"~Base\\n\");&#125;&#125;;class DerivedA : public Base&#123;public: ~DerivedA() &#123; printf(\"~DerivedA\\n\");&#125;&#125;;class DerivedB : public Base&#123;public: ~DerivedB() &#123; printf(\"~DerivedB\\n\");&#125;&#125;;int main()&#123; unique_ptr&lt;Base&gt; basePtr = make_unique&lt;DerivedA&gt;(); //很多其他的代码处理 //到了这里已经不知道basePtr的具体类型，通过typeid等方法很差 DerivedA da(*basePtr); //编译错误 return 0;&#125; 如何实现对于原型模式同样存在浅拷贝、深拷贝的问题。 1234567891011121314151617181920212223242526272829303132class Base&#123;public: virtual ~Base() &#123; printf(\"~Base\\n\");&#125; virtual void print() &#123; printf(\"this is Base\\n\");&#125;; virtual unique_ptr&lt;Base&gt; clone() &#123; return unique_ptr&lt;Base&gt;(new Base(*this)); &#125;&#125;;class Derived : public Base&#123;public: ~Derived() &#123; printf(\"~Derived\\n\");&#125; void print()&#123; printf(\"this is Derived\\n\");&#125; //上面链接的知乎大神把这里返回值设为unique&lt;Derived&gt;，不明白为什么 unique_ptr&lt;Base&gt; clone() &#123; //调用拷贝构造，若是深拷贝，还需重载拷贝函数 return unique_ptr&lt;Base&gt;(new Derived(*this)); &#125;&#125;;int main()&#123; unique_ptr&lt;Base&gt; basePtr = make_unique&lt;Derived&gt;(); //很多其他的代码处理 auto basePtr2 = basePtr-&gt;clone(); basePtr2-&gt;print();// print:this is derived return 0;&#125; 模板方法模式需要注意与建造者模式的不同，参考 建造者模式中指挥者类的作用 模板方法模式VS建造者模式 原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class AbstractClass&#123;public: virtual ~AbstractClass() &#123; printf(\"~AbstractClass\\n\");&#125; virtual void PrimitiveOperation1() = 0; virtual void PrimitiveOperation2() = 0; void TemplateMethod() &#123; PrimitiveOperation1(); PrimitiveOperation2(); &#125;&#125;;class ConcreteClassA : public AbstractClass&#123;public: ~ConcreteClassA() &#123; printf(\"~ConcreteClassA\\n\");&#125; void PrimitiveOperation1() &#123; printf(\"operation 1 of class A\\n\"); &#125; void PrimitiveOperation2() &#123; printf(\"operation 2 of class A\\n\"); &#125;&#125;;class ConcreteClassB : public AbstractClass&#123;public: ~ConcreteClassB() &#123; printf(\"~ConcreteClassB\\n\");&#125; void PrimitiveOperation1() &#123; printf(\"operation 1 of class B\\n\"); &#125; void PrimitiveOperation2() &#123; printf(\"operation 2 of class B\\n\"); &#125;&#125;;int main()&#123; auto classA = make_unique&lt;ConcreteClassA&gt;(); classA-&gt;TemplateMethod(); auto classB = make_unique&lt;ConcreteClassB&gt;(); classB-&gt;TemplateMethod(); return 0;&#125; 示例123456789101112131415161718192021222324252627282930313233343536class Paper&#123;public: virtual ~Paper() &#123; printf(\"~Paper\\n\");&#125; void question() &#123; printf(\"question is balabala, answer is %s\\n\", answer().c_str()); &#125; virtual string answer() = 0;&#125;;class StudentA : public Paper&#123;public: ~StudentA() &#123; printf(\"~StudentA\\n\");&#125; string answer() &#123; return \"A\"; &#125;&#125;;class StudentB : public Paper&#123;public: ~StudentB() &#123; printf(\"~StudentB\\n\");&#125; string answer() &#123; return \"B\"; &#125;&#125;;int main()&#123; StudentA stuA; stuA.question(); StudentB stuB; stuB.question(); return 0;&#125; 外观模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class SubSystemOne&#123;public: ~SubSystemOne()&#123;printf(\"~SubSystemOne\\n\");&#125; void methodOne() &#123; printf(\"method one\\n\"); &#125;&#125;;class SubSystemTwo&#123;public: ~SubSystemTwo()&#123;printf(\"~SubSystemTwo\\n\");&#125; void methodTwo() &#123; printf(\"method two\\n\"); &#125;&#125;;class SubSystemThree&#123;public: ~SubSystemThree()&#123;printf(\"~SubSystemThree\\n\");&#125; void methodThree() &#123; printf(\"method three\\n\"); &#125;&#125;;class SubSystemFour&#123;public: ~SubSystemFour()&#123; printf(\"~SubSystemFour\\n\");&#125; void methodFour() &#123; printf(\"method four\\n\"); &#125;&#125;;class Facade&#123;public: Facade() &#123; sysOne_ = make_unique&lt;SubSystemOne&gt;(); sysTwo_ = make_unique&lt;SubSystemTwo&gt;(); sysThree_ = make_unique&lt;SubSystemThree&gt;(); sysFour_ = make_unique&lt;SubSystemFour&gt;(); &#125; ~Facade()&#123;printf(\"~Facade\\n\");&#125; void methodA() &#123; sysOne_-&gt;methodOne(); sysFour_-&gt;methodFour(); &#125; void methodB() &#123; sysTwo_-&gt;methodTwo(); sysThree_-&gt;methodThree(); &#125;private: unique_ptr&lt;SubSystemOne&gt; sysOne_; unique_ptr&lt;SubSystemTwo&gt; sysTwo_; unique_ptr&lt;SubSystemThree&gt; sysThree_; unique_ptr&lt;SubSystemFour&gt; sysFour_;&#125;;int main()&#123; auto facade = make_unique&lt;Facade&gt;(); facade-&gt;methodA(); facade-&gt;methodB(); return 0;&#125; 建造者模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class Product&#123;public: ~Product()&#123; printf(\"~Product\\n\");&#125; void addParts(string part) &#123; parts_.push_back(part); &#125; void show() &#123; auto i = parts_.begin(); while(i != parts_.end()) &#123; printf(\"%s\\n\", i-&gt;c_str()); i++; &#125; &#125;private: list&lt;string&gt; parts_;&#125;;class Builder&#123;public: virtual ~Builder() &#123;printf(\"~Builder\\n\");&#125; virtual void stepA() = 0; virtual void stepB() = 0; virtual void getResult() = 0;protected: &#125;;class ConcreteBuilderA : public Builder&#123;public: ConcreteBuilderA() &#123; product_ = make_unique&lt;Product&gt;(); &#125; ~ConcreteBuilderA() &#123;printf(\"~ConcreteBuilderA\\n\");&#125; void stepA() &#123; product_-&gt;addParts(\"parts A\"); &#125; void stepB() &#123; product_-&gt;addParts(\"parts B\"); &#125; void getResult() &#123; product_-&gt;show(); &#125;private: unique_ptr&lt;Product&gt; product_;&#125;;class ConcreteBuilderB : public Builder&#123;public: ConcreteBuilderB() &#123; product_ = make_unique&lt;Product&gt;(); &#125; ~ConcreteBuilderB() &#123;printf(\"~ConcreteBuilderB\\n\");&#125; void stepA() &#123; product_-&gt;addParts(\"parts X\"); &#125; void stepB() &#123; product_-&gt;addParts(\"parts Y\"); &#125; void getResult() &#123; product_-&gt;show(); &#125;private: unique_ptr&lt;Product&gt; product_;&#125;;class Director&#123;public: ~Director()&#123; printf(\"~Director\\n\");&#125; void Construct(unique_ptr&lt;Builder&gt; &amp;builder) &#123; builder-&gt;stepA(); builder-&gt;stepB(); &#125;&#125;;int main()&#123; auto director = make_unique&lt;Director&gt;(); unique_ptr&lt;Builder&gt; builderA = make_unique&lt;ConcreteBuilderA&gt;(); director-&gt;Construct(builderA); builderA-&gt;getResult(); unique_ptr&lt;Builder&gt; builderB = make_unique&lt;ConcreteBuilderB&gt;(); director-&gt;Construct(builderB); builderB-&gt;getResult(); return 0;&#125; 观察者模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Observer&#123;public: virtual ~Observer() &#123; printf(\"~Observer\\n\");&#125; virtual void update() = 0;&#125;;class Subject&#123;public: virtual ~Subject()&#123; printf(\"~Subject\\n\");&#125; void attach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.push_back(observer); &#125; void detach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.remove(observer); &#125; void notify() &#123; for(auto &amp;observer : observers_) observer-&gt;update(); &#125;private: list&lt;shared_ptr&lt;Observer&gt;&gt; observers_;&#125;;class ConcreteSubject : public Subject&#123;public: void setState(string state) &#123; state_ = state; &#125; const char *state() &#123; return state_.c_str(); &#125;private: string state_;&#125;;class ConcreteObserver : public Observer&#123;public: ConcreteObserver(shared_ptr&lt;ConcreteSubject&gt; sub, string name) &#123; sub_ = sub; name_ = name; &#125; void update() &#123; printf(\"observer %s new state is:%s\\n\", name_.c_str(), sub_.lock()-&gt;state()); &#125;private: weak_ptr&lt;ConcreteSubject&gt; sub_; string name_;&#125;;int main()&#123; auto sub = make_shared&lt;ConcreteSubject&gt;(); sub-&gt;attach(make_shared&lt;ConcreteObserver&gt;(sub, \"X\")); sub-&gt;attach(make_shared&lt;ConcreteObserver&gt;(sub, \"Y\")); sub-&gt;attach(make_shared&lt;ConcreteObserver&gt;(sub, \"Z\")); sub-&gt;setState(\"abc\"); sub-&gt;notify(); return 0;&#125; 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101class Observer;class Subject&#123;public: virtual ~Subject()&#123; printf(\"~Subject\\n\");&#125; virtual void attach(shared_ptr&lt;Observer&gt;) = 0; virtual void detach(shared_ptr&lt;Observer&gt;) = 0; virtual void notify() = 0; virtual void setState(string) = 0; virtual const char *state() = 0;&#125;;class Observer&#123;public: Observer(string name, shared_ptr&lt;Subject&gt; sub) &#123; name_ = name; sub_ = sub; &#125; virtual ~Observer()&#123; printf(\"~Observer\\n\");&#125; virtual void update() = 0;protected: string name_; weak_ptr&lt;Subject&gt; sub_;&#125;;class Boss : public Subject&#123;public: ~Boss()&#123; printf(\"~Boss\\n\");&#125; void attach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.push_back(observer); &#125; void detach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.remove(observer); &#125; void notify() &#123; auto i = observers_.begin(); while(i != observers_.end()) &#123; (*i)-&gt;update(); ++i; &#125; &#125; void setState(string state)&#123; state_ = state;&#125; const char *state()&#123; return state_.c_str();&#125;private: string state_; list&lt;shared_ptr&lt;Observer&gt;&gt; observers_;&#125;;class StockObserver : public Observer&#123;public: StockObserver(string name, shared_ptr&lt;Subject&gt; sub) :Observer(name, sub) &#123;&#125; ~StockObserver()&#123; printf(\"~StockObserver\\n\");&#125; void update() &#123; printf(\"%s, %s close stock \\n\", sub_.lock()-&gt;state(), name_.c_str()); &#125;&#125;;class NBAObserver : public Observer&#123;public: NBAObserver(string name, shared_ptr&lt;Subject&gt; sub) :Observer(name, sub) &#123;&#125; ~NBAObserver()&#123; printf(\"~NBAObserver\\n\");&#125; void update() &#123; printf(\"%s, %s close NBA \\n\", sub_.lock()-&gt;state(), name_.c_str()); &#125;&#125;;int main()&#123; auto huhansan = make_shared&lt;Boss&gt;(); auto kdb = make_shared&lt;StockObserver&gt;(\"kdb\", huhansan); auto fxdpig = make_shared&lt;NBAObserver&gt;(\"fxdpig\", huhansan); huhansan-&gt;attach(kdb); huhansan-&gt;attach(fxdpig); huhansan-&gt;detach(fxdpig); huhansan-&gt;setState(\"I'm back\"); huhansan-&gt;notify(); return 0;&#125; 2018-03-06更新 一个更容易理解的示例每设置一个数之后，输出相应的8进制，16进制参考观察者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;list&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;class Observer;class Subject&#123;public: virtual void addObserver(Observer *observer) = 0; virtual void removeObserver(Observer *observer) = 0; void setState(int state) &#123; state_ = state; notify(); &#125; int state() &#123; return state_; &#125;private: virtual void notify() = 0; int state_;&#125;;class Observer&#123;public: explicit Observer(std::shared_ptr&lt;Subject&gt; sub) : sub_(sub) &#123; sub-&gt;addObserver(this); &#125; virtual void update() = 0;protected: std::shared_ptr&lt;Subject&gt; sub_;&#125;;class ConcreteSubject : public Subject&#123;public: void addObserver(Observer *observer) &#123; observers_.push_back(observer); &#125; void removeObserver(Observer *observer) &#123; if(std::find(observers_.begin(), observers_.end(), observer) != observers_.end()) observers_.remove(observer); &#125;private: void notify() &#123; for(Observer *observer : observers_) observer-&gt;update(); &#125; std::list&lt;Observer *&gt; observers_;&#125;;class OctObserver : public Observer&#123;public: explicit OctObserver(std::shared_ptr&lt;Subject&gt; sub) : Observer(sub) &#123;&#125; void update() &#123; printf(\"oct data is: %04o\\n\", sub_-&gt;state());&#125;&#125;;class HexObserver : public Observer&#123;public: explicit HexObserver(std::shared_ptr&lt;Subject&gt; sub) : Observer(sub) &#123;&#125; void update() &#123; printf(\"hex data is: %02X\\n\", sub_-&gt;state());&#125;&#125;;int main()&#123; auto sub = std::make_shared&lt;ConcreteSubject&gt;(); auto octObsr = std::make_unique&lt;OctObserver&gt;(sub); auto hexObsr = std::make_unique&lt;HexObserver&gt;(sub); printf(\"First state change: 12\\n\"); sub-&gt;setState(12); printf(\"Second state change: 25\\n\"); sub-&gt;setState(25); return 0;&#125; 观察者模式使用的还是很多的，比如/chromium/ash/system/tray/system_tray_notifier.cc 抽象工厂模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class AbstractProductA&#123;public: virtual ~AbstractProductA() &#123; printf(\"~AbstractProductA\\n\");&#125;&#125;;class AbstractProductB&#123;public: virtual ~AbstractProductB() &#123; printf(\"~AbstractProductB\\n\");&#125;&#125;;class AbstractFactory&#123;public: virtual ~AbstractFactory() &#123; printf(\"~AbstractFactory\\n\");&#125; virtual unique_ptr&lt;AbstractProductA&gt; createProductA() = 0; virtual unique_ptr&lt;AbstractProductB&gt; createProductB() = 0;&#125;;class ProductA1 : public AbstractProductA&#123;public: ProductA1()&#123;printf(\"ProductA1 constructed\\n\");&#125; ~ProductA1() &#123; printf(\"~ProductA1\\n\");&#125;&#125;;class ProductA2 : public AbstractProductA&#123;public: ProductA2()&#123;printf(\"ProductA2 constructed\\n\");&#125; ~ProductA2() &#123; printf(\"~ProductA2\\n\");&#125;&#125;;class ProductB1 : public AbstractProductB&#123;public: ProductB1()&#123;printf(\"ProductB1 constructed\\n\");&#125; ~ProductB1() &#123; printf(\"~ProductB1\\n\");&#125;&#125;;class ProductB2 : public AbstractProductB&#123;public: ProductB2()&#123;printf(\"ProductB2 constructed\\n\");&#125; ~ProductB2() &#123; printf(\"~ProductB2\\n\");&#125;&#125;;class ConcreteFactory1 : public AbstractFactory&#123;public: ~ConcreteFactory1() &#123; printf(\"~ConcreteFactory1\\n\");&#125; unique_ptr&lt;AbstractProductA&gt; createProductA() &#123; return make_unique&lt;ProductA1&gt;(); &#125; unique_ptr&lt;AbstractProductB&gt; createProductB() &#123; return make_unique&lt;ProductB1&gt;(); &#125;&#125;;class ConcreteFactory2 : public AbstractFactory&#123;public: ~ConcreteFactory2() &#123; printf(\"~ConcreteFactory2\\n\");&#125; unique_ptr&lt;AbstractProductA&gt; createProductA() &#123; return make_unique&lt;ProductA2&gt;(); &#125; unique_ptr&lt;AbstractProductB&gt; createProductB() &#123; return make_unique&lt;ProductB2&gt;(); &#125;&#125;;int main()&#123; auto factory1 = make_unique&lt;ConcreteFactory1&gt;(); factory1-&gt;createProductA(); factory1-&gt;createProductB(); auto factory2 = make_unique&lt;ConcreteFactory2&gt;(); factory2-&gt;createProductA(); factory2-&gt;createProductB(); return 0;&#125; 状态模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;memory&gt;class Context;class State&#123;public: virtual ~State()&#123;&#125; virtual void handle(Context *ctx) = 0; virtual const char *name() const = 0;&#125;;class Context&#123;public: Context(std::shared_ptr&lt;State&gt; state) : state_(state) &#123;&#125; ~Context()&#123;&#125; void request() &#123; state_-&gt;handle(this); &#125; void setState(std::shared_ptr&lt;State&gt; state) &#123; state_ = state; printf(\"state change to %s\\n\", state_-&gt;name()); &#125;private: std::shared_ptr&lt;State&gt; state_;&#125;;class ConcreteStateA : public State&#123;public: ~ConcreteStateA()&#123;&#125; const char *name() const &#123; return \"StateA\";&#125; void handle(Context *ctx);&#125;;class ConcreteStateB : public State&#123;public: ~ConcreteStateB()&#123;&#125; const char *name() const &#123; return \"StateB\";&#125; void handle(Context *ctx);&#125;;void ConcreteStateA::handle(Context *ctx)&#123; if(ctx) ctx-&gt;setState(std::make_shared&lt;ConcreteStateB&gt;());&#125;void ConcreteStateB::handle(Context *ctx)&#123; if(ctx) ctx-&gt;setState(std::make_shared&lt;ConcreteStateA&gt;());&#125;int main()&#123; Context ctx(std::make_shared&lt;ConcreteStateA&gt;()); ctx.request(); ctx.request(); ctx.request(); return 0;&#125; 适配器模式原型1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;memory&gt;class Target&#123;public: virtual ~Target()&#123;&#125; void request() &#123; printf(\"normal request\\n\");&#125;&#125;;class Adaptee&#123;public: void specifiedRequest() &#123; printf(\"specified request\\n\");&#125;&#125;;class Adapter : public Target&#123;public: Adapter() &#123; adaptee_ = std::make_unique&lt;Adaptee&gt;(); &#125; void request() &#123; adaptee_-&gt;specifiedRequest(); &#125;private: std::unique_ptr&lt;Adaptee&gt; adaptee_;&#125;;int main()&#123; auto target = std::make_unique&lt;Adapter&gt;(); target-&gt;request(); return 0;&#125; 备忘录模式原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;memory&gt;struct Memento&#123; int state_;&#125;;class Originator&#123;public: ~Originator()&#123;printf(\"~Originator\\n\");&#125; std::shared_ptr&lt;Memento&gt; createMemento() &#123; auto memento = std::make_shared&lt;Memento&gt;(); memento-&gt;state_ = state_; return memento; &#125; void resetMemento(const std::shared_ptr&lt;Memento&gt; &amp;memento) &#123; state_ = memento-&gt;state_; &#125; void setState(int state) &#123; state_ = state;&#125; int state() &#123; return state_; &#125;private: int state_;&#125;;class Caretaker&#123;public: void setMemento(std::shared_ptr&lt;Memento&gt; memento) &#123; memento_ = memento; &#125; std::shared_ptr&lt;Memento&gt; getMemento() &#123; return memento_; &#125;private: std::shared_ptr&lt;Memento&gt; memento_;&#125;;int main()&#123; Originator origin; Caretaker taker; taker.setMemento(origin.createMemento()); origin.setState(5); origin.resetMemento(taker.getMemento()); return 0;&#125; 书上Memento是写成类的，但我觉得因为备忘录纯粹为了存储数据，或许用结构体更合适。只有Caretaker类是否需要，根据实际情况而定。 实例以memento为关键字搜索chromium源码，找到如下示例 12345678BrotliBitReaderState memento;BrotliBitReaderSaveState(br, &amp;memento);//保存数据if (!SafeReadSymbol(type_tree, br, &amp;block_type)) return BROTLI_FALSE;if (!SafeReadBlockLength(s, &amp;s-&gt;block_length[tree_type], len_tree, br)) &#123; s-&gt;substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_NONE; BrotliBitReaderRestoreState(br, &amp;memento);//重置数据 return BROTLI_FALSE;&#125; 其中BrotliBitReaderState声明如下123456typedef struct &#123; reg_t val_; uint32_t bit_pos_; const uint8_t* next_in; size_t avail_in;&#125; BrotliBitReaderState; 组合模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;list&gt;class Component&#123;public: Component(std::string name) : name_(name) &#123;&#125; virtual ~Component() &#123;printf(\"~Component\\n\");&#125; virtual void add(std::shared_ptr&lt;Component&gt;) = 0; virtual void remove(std::shared_ptr&lt;Component&gt;) = 0; virtual void display(int depth) = 0;protected: std::string name_;&#125;;class Leaf : public Component&#123;public: Leaf(std::string name) : Component(name) &#123;&#125; ~Leaf() &#123; printf(\"~Leaf\\n\");&#125; void add(std::shared_ptr&lt;Component&gt;) &#123; printf(\"Leaf do not support add\\n\");&#125; void remove(std::shared_ptr&lt;Component&gt;) &#123; printf(\"Leaf do not support remove\\n\");&#125; void display(int depth) &#123; for(int i = 0; i &lt; depth; ++i) printf(\"-\"); printf(\"%s\\n\", name_.c_str()); &#125;&#125;;class Composite : public Component&#123;public: Composite(std::string name) : Component(name) &#123;&#125; ~Composite() &#123;printf(\"~Composite\\n\");&#125; void add(std::shared_ptr&lt;Component&gt; comp) &#123; components_.push_back(comp); &#125; void remove(std::shared_ptr&lt;Component&gt; comp) &#123; components_.remove(comp); &#125; void display(int depth) &#123; for(int i = 0; i &lt; depth; ++i) printf(\"-\"); printf(\"%s\\n\", name_.c_str()); for(auto i : components_) i-&gt;display(depth + 1); &#125;private: std::list&lt;std::shared_ptr&lt;Component&gt;&gt; components_;&#125;;int main()&#123; auto bj = std::make_shared&lt;Composite&gt;(\"beijing\"); bj-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); bj-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); auto sh = std::make_shared&lt;Composite&gt;(\"shanghai\"); bj-&gt;add(sh); sh-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); sh-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); auto nj = std::make_shared&lt;Composite&gt;(\"nanjing\"); nj-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); nj-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); auto hz = std::make_shared&lt;Composite&gt;(\"hangzhou\"); hz-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); hz-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); sh-&gt;add(nj); sh-&gt;add(hz); bj-&gt;display(0); return 0;&#125; 迭代器模式感觉没啥用，不如直接用stl里的 单例模式原型123456789101112131415161718192021222324#include &lt;stdio.h&gt;class Singleton&#123;public: static Singleton *instance() &#123; if(instance_ == nullptr) instance_ = new Singleton; return instance_; &#125; void display()&#123;printf(\"this is Singleton\\n\");&#125;private: static Singleton *instance_; Singleton() &#123; printf(\"Singleton constructor\\n\");&#125;&#125;;Singleton *Singleton::instance_ = nullptr;int main()&#123; Singleton::instance()-&gt;display(); return 0;&#125; 多线程时的单例模式如果两个线程同时调用instance()函数，极有可能导致Singleton被初始化两次。违背了单例模式的意图。可通过双重锁定解决这种问题 1234567891011121314#include &lt;mutex&gt;static Singleton *instance()&#123; if(instance_ == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if(instance_ == nullptr) &#123; instance_ = new Singleton; &#125; &#125; return instance_;&#125; 《C++并发编程实战》中说这种双重锁是声名狼藉的，也就是不好的。没有完全理解为什么这么说。 桥接模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Implementor&#123;public: virtual ~Implementor() &#123; printf(\"~Implementor\\n\");&#125; virtual void operation() = 0;&#125;;class Abstraction&#123;public: virtual ~Abstraction() &#123; printf(\"~Abstraction\\n\");&#125; void setImpl(std::shared_ptr&lt;Implementor&gt; impl) &#123; impl_ = impl; &#125; virtual void operation() = 0;protected: std::shared_ptr&lt;Implementor&gt; impl_;&#125;;class RedifinedAbstraction : public Abstraction&#123;public: ~RedifinedAbstraction() &#123; printf(\"~RedifinedAbstraction\\n\");&#125; void operation() &#123; if(impl_) impl_-&gt;operation(); &#125;&#125;;class ConcreteImplementorA : public Implementor&#123;public: ~ConcreteImplementorA() &#123; printf(\"~ConcreteImplementorA\\n\");&#125; void operation() &#123; printf(\"operation A called\\n\");&#125;&#125;;class ConcreteImplementorB : public Implementor&#123;public: ~ConcreteImplementorB() &#123; printf(\"~ConcreteImplementorB\\n\");&#125; void operation() &#123; printf(\"operation B called\\n\");&#125;&#125;;int main()&#123; auto caller = std::make_unique&lt;RedifinedAbstraction&gt;(); auto implA = std::make_shared&lt;ConcreteImplementorA&gt;(); auto implB = std::make_shared&lt;ConcreteImplementorB&gt;(); caller-&gt;setImpl(implA); caller-&gt;operation(); caller-&gt;setImpl(implB); caller-&gt;operation(); return 0;&#125; 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;memory&gt;class App&#123;public: virtual ~App() &#123; printf(\"~App\\n\");&#125; virtual void run() = 0;&#125;;class Phone&#123;public: Phone() : app_(nullptr) &#123;&#125; virtual ~Phone() &#123; printf(\"~Phone\\n\");&#125; void setApp(std::shared_ptr&lt;App&gt; app) &#123; app_ = app; &#125; virtual void run() = 0;protected: std::shared_ptr&lt;App&gt; app_;&#125;;class WangZheRongYao : public App&#123;public: ~WangZheRongYao() &#123; printf(\"~WangZheRongYao\\n\");&#125; void run() &#123; printf(\"run wang zhe rong yao\\n\");&#125;&#125;;class ZhiFuBao : public App&#123;public: ~ZhiFuBao() &#123; printf(\"~ZhiFuBao\\n\");&#125; void run() &#123; printf(\"run zhi fu bao\\n\");&#125;&#125;;class HuaWei : public Phone&#123;public: ~HuaWei() &#123; printf(\"~HuaWei\\n\");&#125; void run() &#123; if(app_) &#123; printf(\"current phone is huawei, \"); app_-&gt;run(); &#125; &#125;&#125;;class XioMi : public Phone&#123;public: ~XioMi() &#123; printf(\"~XioMi\\n\");&#125; void run() &#123; if(app_) &#123; printf(\"curren phone is xioami, \"); app_-&gt;run(); &#125; &#125;&#125;;int main()&#123; auto huawei = std::make_unique&lt;HuaWei&gt;(); auto xiaomi = std::make_unique&lt;XioMi&gt;(); auto wzry = std::make_shared&lt;WangZheRongYao&gt;(); auto zfb = std::make_shared&lt;ZhiFuBao&gt;(); huawei-&gt;setApp(wzry); huawei-&gt;run(); huawei-&gt;setApp(zfb); huawei-&gt;run(); xiaomi-&gt;setApp(wzry); xiaomi-&gt;run(); xiaomi-&gt;setApp(zfb); xiaomi-&gt;run(); return 0;&#125; 命令模式原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Receiver&#123;public: virtual ~Receiver() &#123; printf(\"~Receiver\\n\");&#125; void action() &#123; printf(\"recver action\\n\");&#125;&#125;;class Command&#123;public: explicit Command(std::shared_ptr&lt;Receiver&gt; recver) : recver_(recver) &#123;&#125; virtual ~Command () &#123; printf(\"~Command\\n\");&#125; virtual void execute() = 0;protected: std::shared_ptr&lt;Receiver&gt; recver_;&#125;;class ConcreteCommand : public Command&#123;public: explicit ConcreteCommand(std::shared_ptr&lt;Receiver&gt; recver) : Command(recver) &#123;&#125; ~ConcreteCommand() &#123; printf(\"~ConcreteCommand\\n\");&#125; void execute() &#123; if(recver_) recver_-&gt;action(); &#125;&#125;;class Invoker&#123;public: void setCommand(std::shared_ptr&lt;Command&gt; cmd) &#123; cmd_ = cmd; &#125; void notify() &#123; if(cmd_) cmd_-&gt;execute(); &#125;private: std::shared_ptr&lt;Command&gt; cmd_;&#125;;int main()&#123; Invoker invoker; auto recver = std::make_shared&lt;Receiver&gt;(); auto cmd = std::make_shared&lt;ConcreteCommand&gt;(recver); invoker.setCommand(cmd); invoker.notify(); return 0;&#125; 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;memory&gt;#include &lt;list&gt;class Barbecuer&#123;public: ~Barbecuer() &#123; printf(\"~Barbecuer\\n\");&#125; void bakeMutton() &#123; printf(\"bake mutton\\n\");&#125; void bakeChicken() &#123; printf(\"bake chicken\\n\");&#125;&#125;;class Command&#123;public: explicit Command(std::shared_ptr&lt;Barbecuer&gt; recver) : recver_(recver) &#123;&#125; virtual ~Command() &#123; printf(\"~Command\\n\");&#125; virtual void execute() = 0;protected: std::shared_ptr&lt;Barbecuer&gt; recver_;&#125;;class MuttonCommand : public Command&#123;public: explicit MuttonCommand(std::shared_ptr&lt;Barbecuer&gt; recver) : Command(recver) &#123;&#125; ~MuttonCommand() &#123; printf(\"~MuttonCommand\\n\");&#125; void execute() &#123; if(recver_) recver_-&gt;bakeMutton(); &#125;&#125;;class ChickedCommand : public Command&#123;public: explicit ChickedCommand(std::shared_ptr&lt;Barbecuer&gt; recver) : Command(recver) &#123;&#125; ~ChickedCommand() &#123; printf(\"~ChickedCommand\\n\");&#125; void execute() &#123; if(recver_) recver_-&gt;bakeChicken(); &#125;&#125;;class Waiter&#123;public: void addOrder(std::shared_ptr&lt;Command&gt; cmd) &#123; cmds_.push_back(cmd); &#125; void cancelOrder(std::shared_ptr&lt;Command&gt; cmd) &#123; cmds_.remove(cmd); &#125; void notify() &#123; for(auto &amp; cmd : cmds_) cmd-&gt;execute(); &#125;private: std::list&lt;std::shared_ptr&lt;Command&gt;&gt; cmds_;&#125;;int main()&#123; Waiter mm; auto gg = std::make_shared&lt;Barbecuer&gt;(); auto muttonCmd = std::make_shared&lt;MuttonCommand&gt;(gg); auto chickenCmd = std::make_shared&lt;ChickedCommand&gt;(gg); mm.addOrder(muttonCmd); mm.addOrder(chickenCmd); mm.cancelOrder(muttonCmd); mm.notify();&#125; 职责连模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;memory&gt;class Handler&#123;public: virtual ~Handler() &#123; printf(\"~Handler\\n\");&#125; virtual void handleRequest(int level) = 0; void setSuccessor(std::shared_ptr&lt;Handler&gt; successor) &#123; successor_ = successor; &#125;protected: std::shared_ptr&lt;Handler&gt; successor_;&#125;;class ConcreteHandlerA : public Handler&#123;public: ~ConcreteHandlerA() &#123; printf(\"~ConcreteHandlerA\\n\");&#125; void handleRequest(int level) &#123; if(level &lt; 10) printf(\"request handle by A\\n\"); else if(successor_) successor_-&gt;handleRequest(level); &#125;&#125;;class ConcreteHandlerB : public Handler&#123;public: ~ConcreteHandlerB() &#123; printf(\"~ConcreteHandlerB\\n\");&#125; void handleRequest(int level) &#123; printf(\"request handle by B\\n\"); &#125;&#125;;int main()&#123; auto handlerA = std::make_shared&lt;ConcreteHandlerA&gt;(); auto handlerB = std::make_shared&lt;ConcreteHandlerB&gt;(); handlerA-&gt;setSuccessor(handlerB); handlerA-&gt;handleRequest(5); handlerA-&gt;handleRequest(20);&#125; 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081struct Request&#123; std::string type; int num;&#125;;class Manager&#123;public: Manager() : super_(nullptr) &#123;&#125; virtual ~Manager() &#123; printf(\"~Manager\\n\");&#125; void setSuperior(std::shared_ptr&lt;Manager&gt; super) &#123; super_ = super; &#125; virtual void handleRequest(const Request &amp;req) = 0;protected: std::shared_ptr&lt;Manager&gt; super_;&#125;;class Jinli : public Manager&#123;public: ~Jinli() &#123; printf(\"~Jinli\\n\");&#125; void handleRequest(const Request &amp;req) &#123; if(req.type == \"qingjia\" &amp;&amp; req.num &lt;= 10) printf(\"qingjia %d day passed by Jinli\\n\", req.num); else if(super_) super_-&gt;handleRequest(req); &#125;&#125;;class ZongJinli : public Manager&#123;public: ~ZongJinli() &#123; printf(\"~Zongjinli\\n\");&#125; void handleRequest(const Request &amp;req) &#123; if(req.type == \"qingjia\" &amp;&amp; req.num &lt;= 100) printf(\"qingjia %d day passed by ZongJinli\\n\", req.num); else if(super_) super_-&gt;handleRequest(req); &#125;&#125;;class Boss : public Manager&#123;public: ~Boss() &#123; printf(\"~Boss\\n\");&#125; void handleRequest(const Request &amp;req) &#123; if(req.type == \"qingjia\") printf(\"qingjia %d day passed by Boss\\n\", req.num); else if(req.type == \"zhanggongzi\" &amp;&amp; req.num &lt;= 1000) printf(\"zhanggongzi %d yuan passed by Boss\\n\", req.num); else if(req.type == \"zhanggongzi\" &amp;&amp; req.num &gt; 1000) printf(\"shao nian zai deng deng ba\\n\"); &#125;&#125;;int main()&#123; auto jinli = std::make_shared&lt;Jinli&gt;(); auto zongjinli = std::make_shared&lt;ZongJinli&gt;(); auto boss = std::make_shared&lt;Boss&gt;(); jinli-&gt;setSuperior(zongjinli); zongjinli-&gt;setSuperior(boss); Request req; req.type = \"qingjia\"; req.num = 3; jinli-&gt;handleRequest(req); req.type = \"qingjia\"; req.num = 20; jinli-&gt;handleRequest(req); req.type = \"qingjia\"; req.num = 365; jinli-&gt;handleRequest(req); req.type = \"zhanggongzi\"; req.num = 500; jinli-&gt;handleRequest(req); req.type = \"zhanggongzi\"; req.num = 10000; jinli-&gt;handleRequest(req);&#125; 中介者模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;memory&gt;class Colleague;class Mediator&#123;public: virtual ~Mediator() &#123; printf(\"~Mediator\\n\");&#125; virtual void send(const Colleague *, const std::string &amp;) const = 0;&#125;;class Colleague&#123;public: explicit Colleague(std::shared_ptr&lt;Mediator&gt; mediator) : mediator_(mediator) &#123;&#125; virtual ~Colleague() &#123; printf(\"~Colleague\\n\");&#125; virtual void sendMsg(const std::string &amp;msg) const = 0; virtual void notify(const std::string &amp;msg) const = 0;protected: std::shared_ptr&lt;Mediator&gt; mediator_;&#125;;class ConcreteColleagueA : public Colleague&#123;public: explicit ConcreteColleagueA(std::shared_ptr&lt;Mediator&gt; mediator) : Colleague(mediator) &#123;&#125; ~ConcreteColleagueA() &#123; printf(\"~ConcreteColleagueA\\n\");&#125; void sendMsg(const std::string &amp;msg) const &#123; printf(\"colleague A send msg:%s\\n\", msg.c_str()); mediator_-&gt;send(this, msg); &#125; void notify(const std::string &amp;msg) const &#123; printf(\"colleague A get msg:%s\\n\", msg.c_str()); &#125;&#125;;class ConcreteColleagueB : public Colleague&#123;public: explicit ConcreteColleagueB(std::shared_ptr&lt;Mediator&gt; mediator) : Colleague(mediator) &#123;&#125; ~ConcreteColleagueB() &#123; printf(\"~ConcreteColleagueB\\n\");&#125; void sendMsg(const std::string &amp;msg) const &#123; printf(\"colleague B send msg:%s\\n\", msg.c_str()); mediator_-&gt;send(this, msg); &#125; void notify(const std::string &amp;msg) const &#123; printf(\"colleague B get msg:%s\\n\", msg.c_str()); &#125;&#125;;class ConcreteMediator : public Mediator&#123;public: ~ConcreteMediator() &#123; printf(\"~ConcreteMediator\\n\");&#125; void setColleagueA(ConcreteColleagueA *ca) &#123; colleagueA_ = ca; &#125; void setColleagueB(ConcreteColleagueB *cb) &#123; colleagueB_ = cb; &#125; void send(const Colleague *colleague, const std::string &amp;msg) const &#123; if(colleague == colleagueA_) colleagueB_-&gt;notify(msg); else if(colleague == colleagueB_) colleagueA_-&gt;notify(msg); &#125;private: ConcreteColleagueA *colleagueA_; ConcreteColleagueB *colleagueB_;&#125;;int main()&#123; auto mediator = std::make_shared&lt;ConcreteMediator&gt;(); auto colleagueA = std::make_unique&lt;ConcreteColleagueA&gt;(mediator); auto colleagueB = std::make_unique&lt;ConcreteColleagueB&gt;(mediator); mediator-&gt;setColleagueA(colleagueA.get()); mediator-&gt;setColleagueB(colleagueB.get()); colleagueA-&gt;sendMsg(\"How are you!\"); colleagueB-&gt;sendMsg(\"Fine, thank you, and you!\"); return 0;&#125; 享元模式原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;string&gt;class Flyweight&#123;public: virtual ~Flyweight() &#123; printf(\"~Flyweight\\n\");&#125; virtual void operation(int) = 0;&#125;;class ConcreteFlyweight : public Flyweight&#123;public: ~ConcreteFlyweight() &#123; printf(\"ConcreteFlyweight\\n\");&#125; void operation(int extrinsicstate) &#123; printf(\"concrete operation : %d\\n\", extrinsicstate); &#125;&#125;;class UnsharedConcreteFlyweight : public Flyweight&#123;public: ~UnsharedConcreteFlyweight() &#123; printf(\"~UnsharedConcreteFlyweight\\n\");&#125; void operation(int extrinsicstate) &#123; printf(\"unshared operation : %d\\n\", extrinsicstate); &#125;&#125;;class FlyweightFactorty&#123;public: FlyweightFactorty() &#123; flyweights_[\"X\"] = std::make_shared&lt;ConcreteFlyweight&gt;(); flyweights_[\"Y\"] = std::make_shared&lt;ConcreteFlyweight&gt;(); flyweights_[\"Z\"] = std::make_shared&lt;ConcreteFlyweight&gt;(); &#125; std::shared_ptr&lt;Flyweight&gt; &amp;getFlyweight(const std::string &amp;key) &#123; return flyweights_[key]; &#125;private: std::map&lt;std::string, std::shared_ptr&lt;Flyweight&gt;&gt; flyweights_;&#125;;int main()&#123; FlyweightFactorty factory; int extrinsicstate = 22; auto f1 = factory.getFlyweight(\"X\"); f1-&gt;operation(--extrinsicstate); auto f2 = factory.getFlyweight(\"Y\"); f2-&gt;operation(--extrinsicstate); auto f3 = factory.getFlyweight(\"Z\"); f3-&gt;operation(--extrinsicstate); auto unshared = std::make_unique&lt;UnsharedConcreteFlyweight&gt;(); unshared-&gt;operation(--extrinsicstate);&#125; 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct User&#123; User(const std::string &amp;id) : id_(id) &#123;&#125; std::string id_;&#125;;class Website&#123;public: virtual ~Website() &#123; printf(\"~Website\\n\");&#125; virtual void visit(const User &amp;) = 0;&#125;;class ConcreteWebsite : public Website&#123;public: explicit ConcreteWebsite(const std::string &amp;name) : name_(name) &#123;&#125; ~ConcreteWebsite() &#123; printf(\"~ConcreteWebsite\\n\");&#125; void visit(const User &amp;usr) &#123; printf(\"user %s visit website %s\\n\", usr.id_.c_str(), name_.c_str()); &#125;private: std::string name_;&#125;;class WebsiteFactory&#123;public: std::shared_ptr&lt;Website&gt; &amp;getWesite(const std::string &amp;key) &#123; if(websites_.find(key) == websites_.end()) websites_[key] = std::make_shared&lt;ConcreteWebsite&gt;(key); return websites_[key]; &#125;private: std::map&lt;std::string, std::shared_ptr&lt;Website&gt;&gt; websites_;&#125;;int main()&#123; WebsiteFactory factory; auto web1 = factory.getWesite(\"blog\"); web1-&gt;visit(User(\"kongdb\")); auto web2 = factory.getWesite(\"blog\"); web2-&gt;visit(User(\"yzy\")); auto web3 = factory.getWesite(\"game\"); web3-&gt;visit(User(\"fff\")); auto web4 = factory.getWesite(\"game\"); web4-&gt;visit(User(\"ggg\"));&#125; 解释器模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;memory&gt;class Context&#123;public: void setInput(const std::string &amp;in) &#123; input_ = in; &#125; const std::string &amp;input() const &#123; return input_; &#125; void setOutput(const std::string &amp;out) &#123; output_ = out; &#125; const std::string &amp;output() const &#123; return output_; &#125;private: std::string input_; std::string output_;&#125;;class AbstractExpression&#123;public: virtual ~AbstractExpression() &#123; printf(\"~AbstractExpression\\n\");&#125; virtual void interpret(Context &amp;ctx) = 0;&#125;;class TerminalExpression : public AbstractExpression&#123;public: ~TerminalExpression() &#123; printf(\"~TerminalExpression\\n\");&#125; void interpret(Context &amp;ctx) &#123; printf(\"terminal expression\\n\");&#125;&#125;;class NonTerminalExpression : public AbstractExpression&#123;public: ~NonTerminalExpression() &#123; printf(\"~NonTerminalExpression\\n\");&#125; void interpret(Context &amp;ctx) &#123; printf(\"non terminal expression\\n\");&#125;&#125;;int main()&#123; Context ctx; auto terminal = std::make_unique&lt;TerminalExpression&gt;(); terminal-&gt;interpret(ctx); auto nonterminal = std::make_unique&lt;NonTerminalExpression&gt;(); nonterminal-&gt;interpret(ctx); return 0;&#125; 实例-音乐解释器描述 O表示音阶，‘O 1’表示低音阶，‘O 2’表示中音阶，‘O 3’高音阶 P表示休止符 ‘C D E F G A B’ 表示‘Do-Re-Mi-Fa-So-La-Ti’ 音符长度1表示一拍，2表示二拍，0.5表示半拍，0.25表示1/4拍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133class PlayContext&#123;public: void setPlatText(const std::string &amp;text) &#123; playText_ = text; &#125; std::string playText() const &#123; return playText_; &#125;private: std::string playText_;&#125;;class Expression&#123;public: virtual ~Expression() &#123; printf(\"~Expression\\n\");&#125; void interpret(PlayContext &amp;ctx) &#123; std::string text = ctx.playText(); if(text.empty()) return; //首字母为键 char key = text[0]; //第一个到第二个空格之间的为value size_t pos = text.find(' ', 2); double value = std::stod(text.substr(2, pos - 2)); ctx.setPlatText(text.substr(pos + 1)); execute(key, value); &#125; virtual void execute(char key, double value) = 0;&#125;;//音阶class Scale : public Expression&#123;public: ~Scale() &#123; printf(\"~Scale\\n\");&#125; void execute(char key, double value) &#123; if(key != 'O') &#123; printf(\"error scale :%c\\n\", key); return; &#125; int intVal = int(value); switch(intVal) &#123; case 1: printf(\"lowPitch \"); break; case 2: printf(\"midPitch \"); break; case 3: printf(\"highPitch \"); break; default: break; &#125; &#125;&#125;;//音符class Note : public Expression&#123;public: ~Note() &#123; printf(\"~Note\\n\");&#125; void execute(char key, double value) &#123; const char *note; switch(key) &#123; case 'C': note = \"Do\"; break; case 'D': note = \"Re\"; break; case 'E': note = \"Mi\"; break; case 'F': note = \"Fa\"; break; case 'G': note = \"So\"; break; case 'A': note = \"La\"; break; case 'B': note = \"Ti\"; break; default: note = \"\"; break; &#125; printf(\"%s \", note); &#125;&#125;;int main()&#123; PlayContext ctx; ctx.setPlatText(\"O 2 E 0.5 G 0.5 A 3 E 0.5 G 0.5 D 3 E 0.5 G 0.5 A 0.5 O 3 C 1 O 2 A 0.5 G 1 C 0.5 E 0.5 D 3 \"); auto scaleExp = std::make_shared&lt;Scale&gt;(); auto noteExp = std::make_shared&lt;Note&gt;(); while(!ctx.playText().empty()) &#123; char key = ctx.playText()[0]; std::shared_ptr&lt;Expression&gt; exp = nullptr; switch(key) &#123; case 'O': exp = scaleExp; break; case 'C': case 'D': case 'E': case 'F': case 'G': case 'A': case 'B': exp = noteExp; break; default: break; &#125; if(exp) exp-&gt;interpret(ctx); &#125; printf(\"\\n\"); return 0;&#125; 访问者模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;list&gt;#include &lt;memory&gt;class ElementA;class ElementB;class Visitor&#123;public: virtual ~Visitor() &#123; printf(\"~Visitor\\n\");&#125; virtual void visitA(ElementA *) = 0; virtual void visitB(ElementB *) = 0;&#125;;class Element&#123;public: virtual ~Element() &#123; printf(\"~Element\\n\");&#125; virtual void accept(std::shared_ptr&lt;Visitor&gt;) = 0;&#125;;class ElementA : public Element&#123;public: ~ElementA() &#123; printf(\"~ElementA\\n\");&#125; void accept(std::shared_ptr&lt;Visitor&gt; visitor) &#123; visitor-&gt;visitA(this); &#125;&#125;;class ElementB : public Element&#123;public: ~ElementB() &#123; printf(\"~ElementB\\n\");&#125; void accept(std::shared_ptr&lt;Visitor&gt; visitor) &#123; visitor-&gt;visitB(this); &#125;&#125;;class ConcreteVisitor1 : public Visitor&#123;public: ~ConcreteVisitor1() &#123; printf(\"~ConcreteVisitor1\\n\");&#125; void visitA(ElementA *) &#123; printf(\"ElementA visited by visitor1\\n\");&#125; void visitB(ElementB *) &#123; printf(\"ElementB visited by visitor1\\n\");&#125;&#125;;class ConcreteVisitor2 : public Visitor&#123;public: ~ConcreteVisitor2() &#123; printf(\"~ConcreteVisitor2\\n\");&#125; void visitA(ElementA *) &#123; printf(\"ElementA visited by visitor2\\n\");&#125; void visitB(ElementB *) &#123; printf(\"ElementB visited by visitor2\\n\");&#125;&#125;;class ObjectStructre&#123;public: void attach(std::shared_ptr&lt;Element&gt; ele) &#123; elements_.push_back(ele); &#125; void detach(std::shared_ptr&lt;Element&gt; ele) &#123; elements_.remove(ele); &#125; void accept(std::shared_ptr&lt;Visitor&gt; visitor) &#123; for(const auto &amp;ele : elements_) ele-&gt;accept(visitor); &#125;private: std::list&lt;std::shared_ptr&lt;Element&gt;&gt; elements_;&#125;;int main()&#123; ObjectStructre obj; obj.attach(std::make_shared&lt;ElementA&gt;()); obj.attach(std::make_shared&lt;ElementB&gt;()); auto v1 = std::make_shared&lt;ConcreteVisitor1&gt;(); auto v2 = std::make_shared&lt;ConcreteVisitor2&gt;(); obj.accept(v1); obj.accept(v2);&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"统计超大文件中字符串出现次数","date":"2017-11-25T11:50:17.000Z","path":"2017/11/25/统计超大文件中字符串出现次数/","text":"背景：有一个超大的文件，需要统计里面某个字符串出现的次数 注：下文中的log.txt为500万行左右 Python实现逐行读取方式（单线程）1234567891011count = 0def getCountInFile(fname, s): global count with open(fname, 'rb') as f: for line in f: count += line.count(s)if __name__ == '__main__': getCountInFile('log.txt', b'kongdb') print('total count is:%d' % count) 使用Ipython timeit命令得出时间大概在2.8s 123456%timeit %run single_thread_1.pytotal count is:884736total count is:884736total count is:884736total count is:8847361 loop, best of 3: 2.78 s per loop 逐块读取方式（单线程）1234567891011121314151617181920import oscount = 0#逐块读取，每块的大小CHUNK_SIZE = 500000def getCountInFile(fname, s): global count #先获取文件总大小 total_size = os.path.getsize(fname) with open(fname, 'rb') as f: #分块 piece_count = int(total_size/CHUNK_SIZE) + 1 for i in range(piece_count): content = f.read(CHUNK_SIZE) count += content.count(s)if __name__ == '__main__': getCountInFile('log.txt', b'kongdb') print('total count is:%d' % count) 使用Ipython timeit命令得出时间大概在80ms 1234567%timeit %run single_thread_2.pytotal count is:884736total count is:884736...total count is:884736total count is:88473610 loops, best of 3: 79.3 ms per loop 不过我想了一下，这样分块可能会存在这样一个问题。 比如第n块的最后一个字母是’k’，而第n+1块的前几个字母是’ongdb’，即分的块正好把待查询的子块切割了。这样就会导致子块遗漏了。 想了以下的解决办法，可能不是太好。 123456789...current_pos = 0for i in range(piece_count): content = f.read(CHUNK_SIZE) count += content.count(s) #每次读完一个子块之后，位置向后退\"子串长度减1\"个字符 current_pos += CHUNK_SIZE - len(s) + 1 f.seek(current_pos)... 逐行读取方式（多线程）尝试使一个线程从某一个固定行开始读取，但是因为Python没有从某一行开始读取的方法。只能使用next(f)这种方法来跳过前n行。但这样并不能使时间减少。放弃 也有可能是我使用的方法不对。 逐块读取方式（多线程）Python有seek方法来跳过前n个字符。所以思路就是： 每个线程都有一个start属性 先跳过前start个字符 读取一个固定大小的块，并计算count 合并各个线程的结果 123456789101112131415161718192021222324252627282930313233import osimport threadingg_lock = threading.Lock()count = 0#逐块读取，每块的大小CHUNK_SIZE = 500000def getCountInFile(fname, start, s): with open(fname, 'rb') as f: f.seek(start) content = f.read(CHUNK_SIZE + len(s) -1) if not content: return with g_lock: global count count += content.count(s)#线程列表threads = []if __name__ == '__main__': fname = 'log.txt' #先获取文件总大小 total_size = os.path.getsize(fname) for i in range(int(total_size/CHUNK_SIZE) + 1): t = threading.Thread(target=getCountInFile, args=(fname, i*CHUNK_SIZE, b'kongdb')) threads.append(t) for t in threads: t.start() for t in threads: t.join() print('total count is:%d' % count) 想法很天真，然鹅 1234567%timeit %run multithread_thread_1.pytotal count is:884736total count is:884736...total count is:884736total count is:88473610 loops, best of 3: 105 ms per loop 时间并没有实际缩短，还增加了大约20ms，汗。 是因为Python的GIL限制了呢，还是我的使用方法不正确呢。 C++实现C++ std里的读写文件用的不是很多，但理所当然的觉得C++肯定要比Python快吧 然而结果好像并不是这样的。 先实现统计子串次数的函数 123456789101112131415161718#include \"stdafx.h\"#include &lt;string&gt;#include &lt;stdio.h&gt;//统计子串出现次数int getStrCount(const char *src, const char *sub)&#123; int len = strlen(sub); if (src == nullptr || sub == nullptr || strlen(src) == 0 || len == 0) return 0; int num = 0; while (src = strstr(src, sub)) &#123; num++; src += len; &#125; return num;&#125; 逐行读取方式（单线程）12345678910111213141516171819202122#include &lt;fstream&gt;#include&lt;windows.h&gt;static int count = 0;void getCountInFile(const char *fname, const char *sub)&#123; std::ifstream f(fname); while (!f.eof()) &#123; char line[51] = \"\\0\"; f.getline(line, 50); count += getStrCount(line, sub); &#125;&#125;int main()&#123; int start = GetTickCount(); getCountInFile(\"log.txt\", \"kongdb\"); int end = GetTickCount(); printf(\"time elapse:%d\\n\", end - start); printf(\"total count is:%d\\n\", count); return 0;&#125; 其中使用GetTickCount函数来计算性能 结果如下 time elapse:8531total count:884736 大约是8.5s，竟然比Python的逐行读取慢这么多，不科学啊。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python数据分析与展示笔记","date":"2017-11-17T11:50:17.000Z","path":"2017/11/17/Python数据分析与展示笔记/","text":"IPython常用命令 常用命令 说明 ? 查看变量名函数名 %run 执行某个python文件 %magic 显示所有魔术命令 %hist IPython命令的输入历史 %pdb 异常发生后自动进入调试器 %reset 删除当前命名空间中的全部变量和名称 %who 显示当前命名空间中已经定义的变量 %time 给出代码的执行时间 %timeit 多次执行代码，计算综合平均执行时间 NumPy库一般导入方法 1import numpy as np ndarray类型**数组对象可以去掉元素间运算所需的循环，使一维向量更像单个数据 123a = np.array([1, 3, 5])b = np.array([2, 4, 6])c = a**2 + b**3 **设置专门的数组对象，经过优化，可以提升运算速度 **数组对象采用相同的数据类型，有助于节省运算和存储空间 ndarray是一个多维数组对象，由两部分组成 实际的数据 描述这些数据的元数据（数据维度、数据类型等） ndarray对象的属性 属性 说明 ndim 秩，即轴的数量或维度的数量 shape 对象的尺度，对于矩阵，n行m列 size 对象元素的个数，相当于shape的n*m dtype 对象的元素类型 itemsize 对象中每个元素的大小，以字节为单位 ndarray的元素类型 数据类型 说明 bool True或False intc 与C语言中的int类型一致，一般是int32或int64 intp 用于索引的整数 int8 字节字节长度的整数[-128, 127] int16,int32,int64 对应长度类型的整数 uint8,uint16,uint32,uint32,uint64 对应长度的无符号整数 float16 1位符号位，5位指数，10位尾数 float32 1位符号位，8位指数，23位尾数 float64 1位符号位，11位指数，52位尾数 complex64 实部虚部都是32位浮点数 complex128 实部虚部都是64位浮点数 ndarray数组的创建方法 从Python的列表，元祖等类型创建 12a = np.array([1, 2, 3])b = np.array((4, 5.2), dtype=np.float32) 使用NumPy的函数创建ndarray数组，如arrange,ones,zeros 函数 说明 np.arrange(n) 类似range函数，返回ndarray类型，从0到n-1 np.ones(shape) 根据shape生成全1的数组，如np.ones((3, 5)) np.zeros(shape) 类似，全0数组 np.full(shape, val) 类似，数据全为val np.eyes(shanpe) 类似，对角线为1，其他为0 np.ones_like(a) 根据数组a生成全1的数组 np.zeros_like(a) 类似，全0 np.full_like(a, val) 类似，全val np.linspace() 根据起止数据等间距地填充数据 np.concatenate() 将两个或多个数组合并 例子 123456In: a = np.linspace(1, 10, 4)Out: array([1., 4., 7., 10.])In: b = np.linspace(1, 10, 4, endpoint=False)Out: array([1., 3.25, 5.5, 7.75])In: c = np.concatenate((a, b))Out: array([1., 4., 7., 10., 1., 3.25, 5.5, 7.75]) ndarray数组的维度变换 方法 说明 reshape(shape) 不改变数组元素，返回一个shape形状的数组，原数组不变 resize(shape) 与reshape一致，但修改原数组 swapaxes(ax1, ax2) 将数组n维度中的2个维度互换 flatten() 对数组进行将为，返回1维数组，原数组不变 ndarray数组的类型变换 1b = a.astype(new_type) astype会创建新数组，原数组不变 ndarray数组向列表转换 1ls = a.tolist() 从字节流（raw bytes）中创建 从文件中读取特定格式 数组的索引和切片一维数组的索引和切片与Python的列表一致 123456In: a = np..array([9, 8, 7, 6, 5])In: a[2]Out: 7In: a[1:4:2]Out: array([8, 6]) 多维数组的索引 1234In: a = np.arange(24).reshape((2, 3, 4))In: a[1, 2, 3] #逗号分隔Out: 23In: a[:, 1:3, :] #每个维度类似1维数组[起:止:间隔] ndarray数组的运算 数组与标量之间的运算作用于每一个元素 NumPy一元函数，元素级的运算 函数 说明 np.abs(x) np.fabs(x) 计算各元素的绝对值 np.sqrt(x) 计算各元素的平方根 np.square(x) 计算各元素的评分 np.log(x) np.log10(x) np.log2(x) 计算各元素的自然对数，10底对数，2底对数 np.ceil(x) np.floor(x) 计算各元素的celling和floor值 np.rint(x) 计算各元素四舍五入值 np.modf(x) 返回小数和整数部分两个数组 np.cos/sin/cosh/sinh/tan/tanh 三角函数值 np.exp(x) 各元素的指数值 np.sign(x) 各元素的符号值 Numpy的二元函数 函数 说明 + - / * 两个数组各元素运算 np.maximum(x, y) np.fmax() 两个数组逐个元素比较，返回较大元素组成的数组 np.minimum(x, y) np.fmin() 两个数组逐个元素比较，返回较小元素组成的数组 np.mod(x, y) 元素级的模运算 np.copysign(x, y) 将y数组各元素的符号值赋值给x &gt; &lt; &gt;= &lt;= == != 算术比较，返回bool型数组 CSV文件读写1,2维数据读写np.savetxt(frame, array, fmt=’%.18e’, delimiter=None) 12a = np.arange(100).reshape(5, 20)np.savetxt('a.csv', a, fmt='%d', delimiter=',') np.loadtxt(frame, dtype=np.float, delimiter=None, unpack=False) 1b = np.loadtxt('a.csv', dtype=np.int, delimiter=',') 多维数据的读写a.tofile(frame, sep=’’, format=’%s’) 123a = np.arange(100).reshape(5, 10, 2)a.tofile('a.bat', sep=',', format='%d')#不指定sep则保存为二进制 a.fromfile(frame, dtype=float, count=-1, sep=’’) 1b = np.fromfile('a.bat', dtype=np.int, sep=',') 便捷文件存取np.save(fname, array) np.savez(fname, array) fname以npy/npz结尾 np.load(fname) 123a = np.arange(100).reshape(5, 10, 2)np.save('a.npy', a)b = np.load('a.npy') Numpy的随机数函数np.random的随机数函数 函数 说明 rand(d0, d1,…dn) 根据d0-dn的shape创建随机数数组，[0, 1)均匀分布 randn(d0, d1,…dn) 根据d0-dn的shape创建随机数数组，标准正态分布 randint(low, high, shape) 根据shape创建随机数组，范围[low, high) seeds(s) 随机数种子 shuffle(a) 根据数组啊的第一轴进行随机排列，改变数组a permutation(a) 同上，但生成新数组，不改变原数组 choice(a[,size,replace,p]) 从一维数组a中以概率p抽取元素，形成size形状新数组；replace表示是否可以重用元素，默认False uniform(loc, scale, size) 产生具有均匀分布的数组 normal(low, high, size) 产生具有正态分布的数组， loc均值，scale标准差 poisson(lam, size) 产生具有泊松分布的数组，lam随机事件发生概率 NumPy的统计函数 函数 说明 sum(a, axis=None) 根据给定轴计算数组啊相关元素和 mean(a, axis=None) 期望 average(a, axis, weights=None) 加权平均值 std(a, axis=None) 标准差 var(a, axis=None) 方差 min(a) max(a) 求最小/大值 argmin(a) argmax(a) 最小/大值降一维后下标 unravel_index(index, shape) 根据shape将一维下标转换成多维下标 ptp(a) 最大值最小值的差 median(a) 中位数 Numpy的梯度函数 函数 说明 gradient(a) 计算数组a中元素的梯度，a为多维时，返回每个维度的梯度 梯度：连续值之间的变化率，即斜率 xy坐标轴连续3个x坐标对应的y值为：a，b，c，其中b的梯度为(c-a)/2 图像的数组表示123456789101112from PIL import Imageimport numpy as np#获得图像数组im = np.array(Image.open('1.jpg'))#运算并修改数组b = [255, 255, 255] -im#获取新图片im = Image.fromarray(b.astype(np.uint8))#保存图片im.save('new.jpg') 数据展示matplotlibmatplotlib库较复杂，类似于matlab。可以使用matplotlib.pyploy 123456import matplotlib.pyplot as pltplt.plot([3, 1, 4, 5, 2])plt.ylabel('grade')#保存图片plt.savefig('test', dpi=600)plt.show() 1234567#同时指定x,y值plt.plot([0, 2, 4, 6, 8],[3, 1, 4, 5, 2])#xmin,xmax,ymin,ymaxplt.axis([-1, 10, 0, 6])plt.ylabel('grade')#plt.savefig('test', dpi=600)plt.show() pyplot的绘图区域plt.subplot(nrows, ncols, plot_num) 123456789a = np.arange(0, 5, 0.02)#两行一列绘图区域的上半部分plt.subplot(2, 1, 1)plt.plot(a, np.exp(-a) * np.cos(2*np.pi*a))#两行一列绘图区域的下半部分plt.subplot(2, 1, 2)plt.plot(a, np.cos(np.pi*a))plt.show() plot函数plt.plot(x, y, format_string, **kwargs) x,y:列表或数组 format_string:控制曲线的格式字符串,由颜色，风格，标记字符组成 颜色字符 说明 ‘b’ 蓝色 ‘g’ 绿色 ‘r’ 红色 ‘c’ 青绿色 ‘#008000’ RGB的某种颜色 ‘m’ 洋红色 ‘y’ 黄色 ‘k’ 黑色 ‘w’ 白色 ‘0.8’ 灰度值 风格字符 说明 ‘-‘ 实线 ‘–’ 破折线 ‘-.’ 点划画线 ‘:’ 虚线 ‘’ ‘ ‘ 无线条 标记字符 说明 ‘.’ 点标记 ‘,’ 像素标记（极小点） ‘o’ 实心圈标记 ‘v’ 倒三角标记 ‘^’ 上三角标记 ‘&gt;’ 右三角标记 ‘&lt;’ 左三角标记 ‘1’ 下花三角标记 ‘2’ 上花三角标记 ‘3’ 左花三角标记 ‘4’ 右花三角标记 ‘s’ 实心方形标记 ‘p’ 实心五角标记 ‘*’ 星形标记 ‘h’ 竖六边形标记 ‘H’ 横六边形标记 ‘+’ 十字标记 ‘x’ x标记 ‘D’ 菱形标记 ‘d’ 瘦菱形标记 ‘ ‘ 垂直线标记 **kwargs:第二组或更多的(x, y, format_string) color:控制颜色，color=’green’ linestyle: 控制颜色，linestyle=’dashed’ marker:标记风格，marker=’o’ markerfacecolor:标记颜色，markerfacecolor=’blue’ markersize:标记尺寸,markersize=20 pyplot的中文显示 方法一：使用rcParams修改默认字体 123import matplotlibmatplotlib/rcParams['font.family'] = 'SimHei'y.tlabel('纵轴') rcParams的属性 属性 说明 ‘font.family’ 字体，’SimHei’黑体，’Kaiti’楷体，’LiSu’隶书，’Fangsong’仿宋，’YouYuan’幼圆，’STSong’华文宋体等 ‘font.style’ 字体风格，如normal,italic ‘font.szie’ 字体大小，数字或large,x-small等 方法二：使用属性fontproperties 1plt.ylabel('横轴', fontproperties='SimHei', fontsize=20) pyplot的文本显示 函数 说明 plt.xlabel() x轴标签 plt.ylabel() y轴标签 plt.title() 图形整体增加标签 plt.text() 任意位置增加文本 plt.annotate() 图形中增加带箭头的注解 详细切分绘图区域 subplot2grid 1plt.subplot2grid((3, 3), (1, 0), colspan=2) gridspec 123from matplotlib import gridspecgs = gridspec.GridSpec(3, 3)ax1 = plt.subplot(gs[0, :]) pyplot基础图表函数 函数 说明 plt.plot(x,y,fmt,…) 坐标图 plt.boxplot(data,notah,position) 箱形图 plt.bar(left,height,width,bottom) 条形图 plt.barh(width, bottom, left,height) 横向条形图 plt.polar(theta,r) 极坐标图 plt.pie(data, explode) 饼图 plt.psd(x,NFFT=256,pad_to,Fs) 功率谱密度图 plt.specgram(x,NFFT=256,pad_to,F) 谱图 plt.cohere(x,y,NFFT=256,Fs) x-y相关性函数 plt.scatter(x,y) 散点图 plt.step(x,y,where) 步阶图 plt.hist(x,bins,normed) 直方图 plt.contour(x,y,z,n) 等值图 plt.vlines() 垂直图 plt.stem(x,y,linefmt,markerfmt) 柴火图 plt.plot_date() 数据日期 饼图1234567891011#饼图labels = ['Frogs', 'Hogs', 'Dogs', 'Logs']sizes = [15, 30, 45, 10]#突出第二块explode = (0, 0.1, 0, 0)plt.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=False, startangle=90)#使得画出正圆形plt.axis('equal')plt.show() 直方图1234567#直方图np.random.seed(0)mu, sigma = 100, 20a = np.random.normal(mu, sigma, size=100)#第二个参数bin代表直方的个数（划分的区间，y为每个区间中元素的个数（normed=1）或概率(normed=1)）plt.hist(a, 40, normed=1, histtype='stepfilled', facecolor='b')plt.show() 极坐标散点图12345#散点图fig, ax = plt.subplots()#scatterax.plot(10*np.random.randn(100), 10*np.random.randn(100), 'o')plt.show() pandas库Series类型由一组数据及与之相关的索引组成 1pd.Series([9, 8, 7, 6], index=['a', 'b', 'c', 'd']) Series创建 从标量创建 1pd.Series(25, index=['a', 'b']) 从字典类型创建 1pd.Series(&#123;'a':8, 'b':7&#125;) 从ndarray创建 1pd.Seriess(np.arange(5)) 从列表创建 1pd.Series([9, 8], index=['a', 'b']) Series的基本操作索引切片等类似numpy Series的name属性对象和索引都有name属性 123b = pd.Series([9, 8], index=['a', 'b'])b.name='Series对象'b.index.name='索引列' DataFrame类型表格型数据类型 创建 二维ndarray对象 1pd.DataFrame(np.arange(10).reshape(2, 5)) 一维ndarray对象字典(或直接字典)创建123d = &#123;'one': pd.Series([1, 3, 5, 7], index=['a', 'b', 'c', 'd']), 'two': pd.Series([2, 4, 6, 8], index=['a', 'b', 'c', 'd'])&#125;p = pd.DataFrame(d) 索引行：d[]，列:d.ix[] 获取0轴索引：d.index 获取1轴索引: d.columns 索引的常用方法 append(idx) 连接另一个index对象，产生新的索引 diff(idx) 差集，并返回 intersection(idx) 交集 union(idx) 并集 delete(loc) 删除loc位置的元素 insert(loc, c) 在loc位置增加索引 数据类型操作 重新索引reindex 12345d = pd.DataFrame(&#123;'c1':[1, 3, 5], 'c2':[2, 4, 6]&#125;, index=['i1', 'i2', 'i3'])#改变行顺序d.reindex(index=['i3', 'i2', 'i1'])#改变列顺序d.reindex(columns=['c2', 'c1']) 参数– index,columns :新的行列自定义索引– fill_value : 填充缺失位置的值– method : 填充方法，ffill向前填充，bfill向后填充– limit: 最大填充量– copy : 默认True，生成新对象，为False时不复制 删除指定索引drop1234#删除0轴d.drop(['i1'])删除1轴d.drop(['c1'], axis=1) Pandas的排序根据索引进行排序sort_index(axix=0, ascending=True) 在指定轴上根据数据进行排序sort_values(by, axix=0, ascending=True) by： axis轴上的某个索引，或索引列表 NaN统一放到排序末尾 Pandas的统计分析 函数 说明 sum 计算数据综合，按0轴，下同 count 非Nan的数量 mean median 算术平均，算术中位数 var std 方差，标准差 min max 最小，最大 argmin argmax Series用，返回最值所在位置的索引（自动索引） idmin idmax 同上，返回自定义索引 describe 对0轴进行统计汇总","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python中使用IRR与XIRR","date":"2017-09-27T12:19:52.000Z","path":"2017/09/27/Python中使用IRR与XIRR/","text":"使用IRR函数可直接调用Numpy中的库函数，直接使用即可 1print(np.irr([30000, -5100, -5100, -5100, -5100, -5100, -5100])) 使用XIRR函数很遗憾，不知道为什么Numpy中没有提供该函数。 参考网上的大神：https://stackoverflow.com/questions/8919718/financial-python-library-that-has-xirr-and-xnpv-function 12345678910111213141516171819202122232425def xirr(transactions): years = [(ta[0] - transactions[0][0]).days / 365.0 for ta in transactions] residual = 1 step = 0.05 guess = 0.05 epsilon = 0.0001 limit = 10000 while abs(residual) &gt; epsilon and limit &gt; 0: limit -= 1 residual = 0.0 for i, ta in enumerate(transactions): residual += ta[1] / pow(guess, years[i]) if abs(residual) &gt; epsilon: if residual &gt; 0: guess += step else: guess -= step step /= 2.0 return guess-1from datetime import datetas = [ (date(2010, 12, 29), -10000), (date(2012, 1, 25), 20), (date(2012, 3, 8), 10100)]print(xirr(tas)) #0.0100612640381","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python常用知识点","date":"2017-09-07T02:03:03.000Z","path":"2017/09/07/Python常用知识点/","text":"删除重复字符1234567891011import re# s:输入字符串# n:重复几个的时候删除， n&gt;=2def removeSameCh(s, n): # (.)表示任意一个字符，并且组成一个分组1 # \\1表示匹配出的分组 # &#123;%d,&#125;表示重复，例如n为3的时候，则重复2次及以上 pat = r'(.)\\1&#123;%d,&#125;' % (int(n)-1) while re.search(pat, s) is not None: s = re.sub(pat, r'\\1', s) return s 读写文件123with open(fName, 'r') as f: for line in f.readlines(): print(line) 如果报错UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x80 in position 84: illegal multibyte sequence 则将open函数修改为： 1open(fName, 'r', encoding='UTF-8') 或者使用二进制读取1open(fName, 'rb')","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"利用Python进行数据分析","date":"2017-08-22T23:32:21.000Z","path":"2017/08/23/利用Python进行数据分析/","text":"","tags":[]},{"title":"MySQL基础知识","date":"2017-08-15T13:17:50.000Z","path":"2017/08/15/深入浅出MySQL/","text":"常用命令可以通过[？CONTENTS]命令查询所有命令 DDL数据定义语言 命令作用 命令格式 创建数据库 CREATE DATABASE newdb; 显示数据库 SHOW DATABASES; 选择数据库 USE newdb; 显示表 SHOW TABLES; 删除数据库 DROP DATABASE newdb; 创建表 CREATE TABLE emp(ename VARCHAR(20), hiredata DATE, deptno INT(2)); 查看表信息 DESC emp; 查看更全面的表定义信息 SHOW CREATE TABLE emp\\G; 删除表 DROP TABLE emp; 修改表字段类型 ALTER TABLE emp MODIFY ename VARCHAR(30); 增加表字段 ALTER TABLE emp ADD age INT(5) [AFTER ename]; 删除表字段 ALTER TABLE emp DROP COLUMN age; 修改字段名字 ALTER TABLE emp CHANGE age newage INT(10); 修改字段排列顺序(ADD/CHANGE/MODIFY ) ALTER TABLE emp MODIFY newage INT(2) AFTER ename; 修改表名 ALTER TABLE emp RENAME emp2; DML数据库操作语言 命令作用 命令格式 插入记录 INSERT INTO emp (ename, hiredate, deptno) VALUES(‘kongdb’, ‘1991-05-16’, 1),(‘sss’, ‘1992-01-01’, 2); 更新记录 UPDATE emp SET ename=’new’ WHERE deptno=2; 更新多表 UPDATE emp a, dept b SET a.sal=a.sal*b.deptno WHERE a.deptno=b.deptno; 删除记录 DELETE FROM emp WHERE ename=’new’; 删除多表 DELETE a, b FROM emp a, dept b WHERE a.deptno=b.deptno AND a.deptno=1; 查询记录 SELECT * FROM emp; 查询不重复的记录 SELECT DISTINCT deptno FROM emp; 条件查询(=,&lt;,&gt;,&lt;=,&gt;=,!=,AND,OR) SELECT * FROM emp WHERE sal&gt;4000 AND deptno=4; 查询排序 SELECT * FROM emp ORDER BY sal [DESC]; 查询限制 SELECT * FROM emp LIMIT 1; 聚合操作(COUNT,SUM,MAX,MIN) SELECT [field1,field2,……fieldn] fun_nameFROM tablename[WHERE where_contition][GROUP BY field1,field2,……fieldn[WITH ROLLUP]][HAVING where_contition] 统计某个值出现次数 SELECT deptno, COUNT(1) FROM emp GROUP BY deptno; 对聚合结果再进行汇总WITH ROLLUP SELECT deptno, COUNT(1) FROM emp GROUP BY deptno WITH ROLLUP; 对统计结果再进行过滤HAVING SELECT deptno, COUNT(1) FROM emp GROUP BY deptno HAVING COUNT(1)&gt;1; 求和、最大值、最小值 SELECT SUM(sal), MAX(sal), MIN(sal) FROM emp; 内连接 SELECT ename, deptname FROM emp, dept WHERE emp.deptno=dept.deptno; 外连接（左连接）包含左边所有记录，即使右边没有 SELECT ename, deptname FROM emp LEFT JOIN dept ON emp.deptno=dept.deptno; 外连接（右连接）包含右边所有记录，即使左边没有 SELECT ename, deptname FROM emp RIGHT JOIN dept ON emp.deptno=dept.deptno; 子查询（查询所用到的条件是另一个select语句的结果）IN,NOT IN,=,!=,EXISTS,NOT EXISTS SELECT * FROM emp WHERE deptno IN (SELECT deptno FROM dept); 记录联合（UNION ALL） SELECT deptno FROM empUNION ALLSELECT deptno FROM dept; 记录联合（UNION）为[UNION ALL]再DISTINCT后的结果 SELECT deptno FROM empUNIONSELECT deptno FROM dept; DCL数据库管理语言 命令作用 命令格式 创建用户 CREATE USER ‘usr1’@’localhost’; 增加权限（GRANT） GRANT SELECT, INSERT ON newdb.* TO ‘usr1’@’localhost’; 解除权限（REVOKE） REVOKE INSERT ON newdb.* FROM ‘usr1’@’localhost’; MySQL支持的数据类型数值类型 整数类型 字节 最小值 最大值 TINYINT 1 有符号-128无符号 0 有符号 127无符号 255 SMALLINT 2 有符号-32768无符号 0 有符号 32767无符号 65535 MEDIUMINT 3 有符号-8388608无符号 0 有符号 8388607无符号 1677215 INT、INTEGER 4 有符号-2147483648无符号 0 有符号 2147483647无符号 4294967295 BIGINT 8 有符号-9223372036854775808无符号 0 有符号 9223372036854775807无符号 18446744073709551615 浮点数类型 字节 最小值 最大值 FLOAT 4 ±1.175494351E-38 ±3.402823466E+38 DOUBLE 8 ±2.2250738585072014E-308 ±1.7976931348623157E+308 定点数类型 字节 描述 DEC(M,D)，DECIMAL(M,D) M+2 最大取值范围与DOUBLE 相同，给定DECIMAL 的有效取值范围由M 和D决定 浮点数类型 字节 最小值 最大值 BIT(M) 1～8 BIT(1) BIT(64) 整数类型指定显示宽度1CREATE TABLE t1(id INT(5)); 则id的宽度指定为5（不指定时默认为INT(11)） 1ALTER TABLE t1 MODIFY id INT(5) ZEROFILL; 设置ZEROFILL则宽度不足时自动补0，指定ZEROFILL时会为该列自动添加UNSIGNED属性 AUTO_INCREMENT属性可利用此属性设置某列为自增 设置方法 123CREATE TABLE t2(id INT AUTO_INCREMENT NOT NULL PRIMARY KEY);CREATE TABLE t2(id INT AUTO_INCREMENT NOT NULL, PRIMARY KEY(id));CREATE TABLE t2(id INT AUTO_INCREMENT NOT NULL, UNIQUE(id)); 定点数（M,D）M表示所有数字位数（整数+小数），D表示小数位数字 DECIMAL不指定精度时，默认为(10,0) BIT(M)类型M为1到64，不写则默认为1 SELECT结果默认看不到BIT类型，可用BIN(二进制格式)，HEX(16进制格式)进行读取 1SELECT BIN(id), HEX(id) FROM t2; 日期时间类型常见类型 日期和时间类型 字节 最小值 最大值 DATE 4 1000-01-01 9999-12-31 DATETIME 8 1000-01-01 00:00:00 9999-12-31 23:59:59 TIMESTAMP 4 19700101080001 2038 年的某个时刻 TIME 3 -838:59:59 838:59:59 YEAR 1 1901 2155 TIME_STAMP 系统默认给该列创建CURRENT_TIMESTAMP默认值 和时区相关，当插入日期时，会先转换为本地时区后存放；而从数据库里面取出时，也同样需要将日期转换为本地时区后显示。 超过取值范围会被置为0000-00-00 00:00:00 YEARMySQL 以YYYY 格式检索和显示YEAR 值，范围是1901～2155。当使用两位字符串表示年份时，其范围为“00”到“99”。 “00”到“69”范围的值被转换为2000～2069 范围的YEAR 值 “70”到“99”范围的值被转换为1970～1999 范围的YEAR 值。 DATETIME合法的格式有 1234INSERT INTO t VALUES('1991-05-16 12:21:10');INSERT INTO t VALUES('91/05/16 12:21:10');INSERT INTO t VALUES('910516122110');INSERT INTO t VALUES(910516122110); 字符串类型 字符串类型 字节 描述及字符串存储需求 CHAR（M） M M 为0～255 之间的整数 VARCHAR（M） M 为0～65535 之间的整数，值的长度+1 个字节 TINYBLOB 允许长度0～255 字节，值的长度+1 个字节 BLOB 允许长度0～65535 字节，值的长度+2 个字节 MEDIUMBLOB 允许长度0～167772150 字节，值的长度+3 个字节 LONGBLOB 允许长度 0～4294967295 字节，值的长度+4 个字节 TINYTEXT 允许长度0～255 字节，值的长度+2 个字节 TEXT 允许长度0～65535 字节，值的长度+2 个字节 MEDIUMTEXT 允许长度0～167772150 字节，值的长度+3 个字节 LONGTEXT 允许长度 0～4294967295 字节，值的长度+4 个字节 VARBINARY（M） 允许长度0～M 个字节的变长字节字符串，值的长度+1 个字节 BINARY（M） M 允许长度0～M 个字节的定长字节字符串 CHAR和VARCHAR用来保存较短的字符串，CHAR的长度为声明的长度，VARCHAR为可变长 BINARY 和VARBINARY保存二进制字符串，对于BINARY定长类型，长度不够时填充’\\0’ ENUM枚举类型，值范围需要在创建表时通过枚举方式显式指定。最多允许有65535 个成员。 示例： 12CREATE TABLE t (e ENUM('M','F'));INSERT INTO t VALUES('M'),('F'),(NULL); 注：在MySQL5.7.19上插入不存在的ENUM中的值时，提示“Data truncated for column” SET可以保护0~64个成员，一次可以选取多个成员 示例 12CREATE TABLE t (s SET('A','B','C','D'));INSERT INTO t VALUES('A,B,A'),('D,A'),('C'); MySQL运算符算术运算符 运算符 作用 + 加法 - 减法 * 乘法 /，DIV 除法，返回商 %，MOD 除法，返回余数 比较运算符 运算符 作用 = 等于 &lt;&gt;或!= 不等于 &lt;=&gt; NULL 安全的等于(NULL-safe) &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 存在与指定范围 IN 存在于指定集合 IS NULL 为NULL IS NOT NULL 不为NULL LIKE 通配符匹配 REGEXP 或RLIKE 正则表达式匹配 &lt;=&gt;运算符[NULL &lt;=&gt; NULL]的结果为1 BETWEEN运算符[10 BETWEEN 10 AND 20]的结果为1，，等价于a&gt;=min and a&lt;=max LIKE和REGEXP[123456 LIKE ‘123%’]的结果为1 格式为[str REGEXP str_pat]，当str 字符串中含有str_pat相匹配的字符串时，则返回值为1 逻辑运算符 运算符 作用 NOT 或！ 逻辑非 AND 或&amp;&amp; 逻辑与 OR 或 \\ \\ 逻辑或 XOR 逻辑异或 位运算符 运算符 作用 &amp; 位与（位AND） \\ 位或 （位OR ） ^ 位异或（位 XOR） ~ 位取反 &gt;&gt; 位右移 &lt;&lt; 位左移 常用函数字符串函数 函数 功能 CANCAT(S1,S2,…Sn) 连接S1,S2,…Sn 为一个字符串 INSERT(str,x,y,instr) 将字符串str 从第x 位置开始，y 个字符长的子串替换为字符串instr LOWER(str) 将字符串str 中所有字符变为小写 UPPER(str) 将字符串str 中所有字符变为大写 LEFT(str ,x) 返回字符串str 最左边的x 个字符 RIGHT(str,x) 返回字符串str 最右边的x 个字符 LPAD(str,n ,pad) 用字符串pad 对str 最左边进行填充，直到长度为n 个字符长度 RPAD(str,n,pad) 用字符串pad 对str 最右边进行填充，直到长度为n 个字符长度 LTRIM(str) 去掉字符串str 左侧的空格 RTRIM(str) 去掉字符串str 行尾的空格 REPEAT(str,x) 返回str 重复x 次的结果 REPLACE(str,a,b) 用字符串b 替换字符串str 中所有出现的字符串a STRCMP(s1,s2) 比较字符串s1 和s2 TRIM(str) 去掉字符串行尾和行头的空格 SUBSTRING(str,x,y) 返回从字符串str x 位置起y 个字符长度的字串 数值函数 函数 功能 ABS(x) 返回x 的绝对值 CEIL(x) 返回大于x 的最大整数值 FLOOR(x) 返回小于x 的最大整数值 MOD(x，y) 返回x/y 的模 RAND() 返回0 到1 内的随机值 ROUND(x,y) 返回参数x 的四舍五入的有y 位小数的值 TRUNCATE(x,y) 返回数字x 截断为y 位小数的结果 日期和时间函数 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前的日期和时间 UNIX_TIMESTAMP(date) 返回日期date 的UNIX 时间戳 FROM_UNIXTIME 返回UNIX 时间戳的日期值 WEEK(date) 返回日期date 为一年中的第几周 YEAR(date) 返回日期date 的年份 HOUR(time) 返回time 的小时值 MINUTE(time) 返回time 的分钟值 MONTHNAME(date) 返回date 的月份名 DATE_FORMAT(date,fmt) 返回按字符串fmt 格式化日期date 值 DATE_ADD(date,INTERVAL expr type) 返回一个日期或时间值加上一个时间间隔的时间值 DATEDIFF(expr,expr2) 返回起始时间expr 和结束时间expr2 之间的天数 DATE_FORMAT(date,fmt)函数按字符串fmt 格式化日期date 值 示例 12SELECT DATE_FORMAT(NOW(), '%M,%D,%Y');-&gt; August,20th,2017 日期的格式 格式符 格式说明 %S,%s 两位数字形式的秒（00,01,…,59） %i 两位数字形式的分（00,01,…,59） %H 两位数字形式的小时，24 小时（00,01,…,23） %h,%I 两位数字形式的小时，12 小时（01,02,…,12） %k 数字形式的小时，24 小时（0,1,…,23） %l 数字形式的小时，12 小时（1,2,…,12） %T 24 小时的时间形式（hh:mm:ss） %r 12 小时的时间形式（hh:mm:ssAM 或hh:mm:ssPM） %p AM 或PM %W 一周中每一天的名称（Sunday,Monday,…,Saturday） %a 一周中每一天名称的缩写（Sun,Mon,…,Sat） %d 两位数字表示月中的天数（00,01,…,31） %e 数字形式表示月中的天数（1,2，…,31） %D 英文后缀表示月中的天数（1st,2nd,3rd,…） %w 以数字形式表示周中的天数（0=Sunday,1=Monday,…,6=Saturday） %j 以3 位数字表示年中的天数（001,002,…,366） %U 周（0,1,52），其中Sunday 为周中的第一天 %u 周（0,1,52），其中Monday 为周中的第一天 %M 月名（January,February,…,December） %b 缩写的月名（January,February,…,December） %m 两位数字表示的月份（01,02,…,12） %c 数字表示的月份（1,2,…,12） %Y 4 位数字表示的年份 %y 两位数字表示的年份 %% 直接值“%” DATE_ADD(date,INTERVAL expr type)函数返回与所给日期date 相差INTERVAL 时间段的日期。 示例 121分1秒后的时间SELECT DATE_ADD(NOW(), INTERVAL '1:1' MINUTE_SECOND); 表达式类型 描述 格式 HOUR 小时 hh MINUTE 分 mm SECOND 秒 ss YEAR 年 YY MONTH 月 MM DAY 日 DD YEAR_MONTH 年和月 YY-MM DAY_HOUR 日和小时 DD hh DAY_MINUTE 日和分钟 DD hh:mm DAY_ SECOND 日和秒 DD hh:mm:ss HOUR_MINUTE 小时和分 hh:mm HOUR_SECOND 小时和秒 hh:ss MINUTE_SECOND 分钟和秒 mm:ss 流程函数 函数 功能 IF(value,t f) 如果value 是真，返回t；否则返回f IFNULL(value1,value2) 如果value1 不为空返回value1，否则返回value2 CASE WHEN [value1]THEN[result1]…ELSE[default]END 如果value1 是真，返回result1，否则返回default CASE [expr] WHEN [value1]THEN[result1]…ELSE[default]END 如果expr 等于value1，返回result1，否则返回default 其他常用函数 函数 功能 DATABASE() 返回当前数据库名 VERSION() 返回当前数据库版本 USER() 返回当前登录用户名 INET_ATON(IP) 返回IP 地址的数字表示 INET_NTOA(num) 返回数字代表的IP 地址 PASSWORD(str) 返回字符串str 的加密版本 MD5() 返回字符串str 的MD5 值 INET_ATON(IP)函数返回IP 地址的网络字节序表示 示例 12SELECT INET_ATON('192.168.0.1');-&gt; 3232235521 INET_NTOA(num)函数返回网络字节序代表的IP 地址 示例 12SELECT INET_NTOA(3232235521);-&gt; 192.168.0.1 MD5(str)函数返回字符串str 的MD5 值，常用来对应用中的数据进行加密。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"IRR与XIRR","date":"2017-08-13T12:43:51.000Z","path":"2017/08/13/IRR与XIRR/","text":"IRR函数说明一系列现金流的内部收益率，现金流数额不必相等，但是必须是定期出现的（如每周或每月） 语法IRR(values, [guess]) 参数说明如下 Values 必需。 数组或单元格的引用，这些单元格包含用来计算内部收益率的数字。 Values 必须包含至少一个正值和一个负值，以计算返回的内部收益率。 IRR 使用值的顺序来说明现金流的顺序。 一定要按您需要的顺序输入支出值和收益值。 如果数组或引用包含文本、逻辑值或空白单元格，这些数值将被忽略。 Guess 可选。 对函数 IRR 计算结果的估计值。 Microsoft Excel 使用迭代法计算函数 IRR。 从 guess 开始，IRR 不断修正计算结果，直至其精度小于 0.00001%。 如果 IRR 运算 20 次，仍未找到结果，则返回 错误值 #NUM!。 多数情况下，不必为 IRR 计算提供 guess 值。 如果省略 guess，则假定它为 0.1 (10%)。 如果 IRR 返回 错误值 #NUM!，或结果不接近您预期的值，可用另一个 guess 值重试。 示例1、一开始投入一笔资金，每年取得一定收入，计算收益率 数据 说明 -70000 成本费用 12000 第一年净收入 15000 第二年净收入 18000 第三年净收入 21000 第四年净收入 26000 第五年净收入 8.66% 五年后的内部收益率( =IRR(A2:A7) ) 2、一开始借了一笔钱，每月还一部分，计算借款实际利率 比如和银行借了30000元，每月还5100，分6个月还 时间 现金流 - 30000 第一个月 -5100 第二个月 -5100 第三个月 -5100 第四个月 -5100 第五个月 -5100 第六个月 -5100 每月利率（=IRR(B2:B8)） 0.57% 年化利率 （=(1+IRR(B2:B8))^12-1） 7.04% 3、每月定投一笔钱，一段时间后计算平均收益 时间 定投资金 第一个月初 -10000 第二个月初 -10000 第三个月初 -10000 第四个月初 -10000 第五个月初 -10000 第六个月初 -10000 第六个月末余额 63000 每月利率（=IRR(B2:B8)） 1.4% 年化利率 （=(1+IRR(B2:B8))^12-1） 18.1% 哇塞，实际年化好吓人 一个实际应用例子（20190213更新）贷款10万，分36个月还，每个月还的本金（2777.78）和利息（310）固定，需要计算实际利率 还款计划 月数 还款本金 还款利息 1 2777.78 310 2 2777.78 310 … … … 35 2777.78 310 36 2777.78 310 计算到第N个月还清时的实际利率这个问题可以这么想： 假设在第一个月还清，还款清单为[100310] 假设在第二个月还清，还款清单为[3087.78, 97532.22]，其中97532.22=100000-2777.78 * 1 + 310 假设在第三个月还清，还款清单为[3087.78, 3087.78, 94754.4]，其中94754.4=100000-2777.78 * 2 + 310 依次类推，在第36个月还清，则还款清单为[3087.78,…,3087.78]，共是36个3087.78 据此逻辑并参考Python中使用IRR与XIRR计算出的实际利率为 还清月数 实际利率 1 3.78% 2 3.84% 3 3.89% 4 3.95% 5 4.01% 6 4.07% 7 4.13% 8 4.20% 9 4.26% 10 4.33% 11 4.40% 12 4.47% 13 4.55% 14 4.63% 15 4.71% 16 4.79% 17 4.87% 18 4.96% 19 5.05% 20 5.14% 21 5.24% 22 5.34% 23 5.45% 24 5.55% 25 5.67% 26 5.78% 27 5.90% 28 6.03% 29 6.16% 30 6.30% 31 6.44% 32 6.58% 33 6.73% 34 6.89% 35 7.06% 36 7.23% 相应代码1234567891011121314import numpy as npif __name__ == '__main__': principal = 2777.78 interest = 310 liability = 100000 for i in range(36): manifest = [liability] for j in range(i): manifest.append(-(principal + interest)) manifest.append(-(liability - i * principal + interest)) month_rate = np.irr(manifest) year_rate = (1 + month_rate) ** 12 - 1 print(i+1, ' | ', '%.2f%%'%(year_rate * 100)) 以上个月为基准，本月还清的实际利率比如到了第10个月底，本金还剩余：100000-10 * 2777.78=72222.2到第11个月一共需要还：310 + 72222.2 = 72532.2 月数 每个月的实际利率 1 3.78% 2 3.89% 3 4.01% 4 4.13% 5 4.27% 6 4.41% 7 4.56% 8 4.72% 9 4.89% 10 5.07% 11 5.27% 12 5.49% 13 5.72% 14 5.98% 15 6.26% 16 6.57% 17 6.91% 18 7.28% 19 7.70% 20 8.17% 21 8.70% 22 9.30% 23 10.00% 24 10.80% 25 11.75% 26 12.88% 27 14.25% 28 15.94% 29 18.09% 30 20.90% 31 24.75% 32 30.33% 33 39.13% 34 55.01% 35 91.86% 36 255.96% 相应代码12345678910if __name__ == '__main__': principal = 2777.78 interest = 310 liability = 100000 for i in range(36): remain = liability - i * principal manifest = [remain, - remain - interest] month_rate = np.irr(manifest) year_rate = (1 + month_rate) ** 12 - 1 print(i+1, ' | ', '%.2f%%'%(year_rate * 100)) 最后一个月的实际利率竟然这么高，想想到了最后一个月只剩了2777.78的本金，却要还310的利息，确实是高利贷了啊。嗯，到第18个月的时候，必须要还掉了。 XIRR函数说明用于计算不一定定期发生的现金流的内部收益率 语法XIRR(values, dates, [guess]) 参数说明如下 值 必需。 与 dates 中的支付时间相对应的一系列现金流。 首期支付是可选的，并与投资开始时的成本或支付有关。 如果第一个值是成本或支付，则它必须是负值。 所有后续支付都基于 365 天/年贴现。 值系列中必须至少包含一个正值和一个负值。 日期 必需。 与现金流支付相对应的支付日期表。 日期可按任何顺序排列。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题 。 Guess 可选。 对函数 XIRR 计算结果的估计值。 示例1、一开始投入一笔钱，不定期获得收益 现金流 日期 -10000 2008-1-1 2750 2008-3-1 4250 2008-10-30 3250 2009-2-15 2750 2009-4-1 年化收益率(=XIRR(A2:A6, B2:B6)) 37.34% 2、每月不定期定投 现金流 日期 -3000 2016-1-14 -3000 2016-1-10 -5000 2016-3-6 -10000 2016-8-10 -10000 2016-10-10 32850 2016-10-30 年化收益率(=XIRR(A2:A2, B2:B7)) 17.51% 参考链接微信公众号：越女事务所 IRR 官方说明： https://support.office.com/zh-CN/article/IRR-%E5%87%BD%E6%95%B0-64925EAA-9988-495B-B290-3AD0C163C1BC XIRR官方说明： https://support.office.com/zh-CN/article/XIRR-%E5%87%BD%E6%95%B0-DE1242EC-6477-445B-B11B-A303AD9ADC9D","tags":[{"name":"IRR","slug":"IRR","permalink":"http://yoursite.com/tags/IRR/"}]},{"title":"试题解答","date":"2017-08-09T12:10:02.000Z","path":"2017/08/09/试题解答/","text":"题目11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#-*- coding: utf-8 -*-import pandas as pdimport numpy as npimport os#逐块读取，每块的sizeCHUNK_SIZE = 1000#空年龄的keyNULL_KEY = -1def readDataFromFile(fName): if not os.path.exists(fName): print(\"请确认文件是否存在, 路径：%s\" % fName) return #逐块的迭代器，header=0表示忽略第一行的表头 chunker = pd.read_table(fName, sep='\\s+', header=0, chunksize=CHUNK_SIZE) #结果的列表 result = &#123;&#125; #行号 line = 0 for piece in chunker: #年龄的列表 ages = piece.age.values #年龄是否为空的列表，空则为False isEmptyAge = piece.age.isnull().values for i in range(len(ages)): line = line + 1 if isEmptyAge[i]: result[NULL_KEY] = (result[NULL_KEY] + 1 if NULL_KEY in result else 1) else: try: key = int(ages[i]) result[key] = (result[key] + 1 if key in result else 1) except: print('***错误！数据的第%d行，年龄不是整数数字***' % line) return resultdef saveResultToFile(fName, result): with open(fName, 'w') as f: f.write('年龄 人数\\n') #给年龄排个序 ages = list(result.keys()) ages.sort() for age in ages: if age == NULL_KEY: f.write('未知 %d\\n' % result[age]) else: f.write('%d %d\\n' % (age, result[age]))if __name__ == '__main__': inFile = 'E:/info.txt' outFile = 'E:/result.txt' result = readDataFromFile(inFile) if not result is None: saveResultToFile(outFile, result) 题目212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding: utf-8 -*-import unittestdef checkListFormat(lData): if not isinstance(lData, list) or len(lData) != 2: print('数据格式错误') return False for i in lData: if not isinstance(i, int): print('数据格式错误') return False if not lData[0] &lt; lData[1]: print('数据格式错误') return False return Truedef insertList(before, inData): if not checkListFormat(inData): return if not isinstance(before, list): return for i in before: if not checkListFormat(i): return n = len(before) startIndex = n endIndex = n for i in range(n): if inData[0] &gt; before[i][1]: continue startIndex = i break for i in range(n): if inData[1] &gt; before[i][0]: continue endIndex = i - 1 break #startIndex为n说明待插入值的最小值都比原列表发最后一个值大 newBegin = (inData[0] if startIndex == n else min(inData[0], before[startIndex][0])) newEnd = 0 if endIndex == -1: #待插入值的最大值都比原列表第一个值大 newEnd = inData[1] elif endIndex == n: #需要比较两个列表最后一个值 newEnd = max(inData[1], before[n-1][1]) else: newEnd = max(inData[1], before[endIndex][1]) for i in range(startIndex, min(endIndex+1, n)): before.pop(startIndex) before.insert(startIndex, [newBegin, newEnd]) return beforeclass TestInsert(unittest.TestCase): def test_insertList(self): self.assertEqual(insertList([[1, 3], [6, 9]], [2, 5]), [[1, 5], [6, 9]]) self.assertEqual(insertList([[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], [4, 9]), [[1, 2], [3, 10], [12, 16]]) self.assertEqual(insertList([[6, 9], [10, 11]], [1, 3]), [[1, 3], [6, 9], [10, 11]]) self.assertEqual(insertList([[6, 9], [10, 11]], [19, 32]), [[6, 9], [10, 11], [19, 32]]) self.assertEqual(insertList([[6, 9], [10, 13]], [3, 8]), [[3, 9], [10, 13]]) self.assertEqual(insertList([[6, 9], [10, 13]], [12, 17]), [[6, 9], [10, 17]]) self.assertEqual(insertList([[6, 9], [10, 13]], [11, 12]), [[6, 9], [10, 13]])if __name__ == '__main__': unittest.main()","tags":[]},{"title":"Python金融大数据分析学习笔记","date":"2017-07-26T13:49:28.000Z","path":"2017/07/26/Python金融大数据分析学习笔记/","text":"Python常用工具IPython Notebook说明: 本地Web短编写调试Python代码 安装方法: pip install juputer 运行: jupyter notebook Python quant-platform说明: Web浏览器的金融分析和协作平台，环境已经配置好 地址: http://analytics.quant-platform.com Anaconda说明: 拥有科学计算的Python发行版，提供了包管理和环境管理功能，可以方便地解决多版本Python共存的问题 数据类型和结构基本数据类型浮点数精确地存储12c = 0.5c.as_integer_ratio() decimal 模块1234567import decimalfrom decimal import Decimald = Decimal(1) / Decimal(11) #28位decimal.getcontext().prec = 50d = Decimal(1) / Decimal(11) #50位 函数式编程filter,map,reduce12345def even(x): return x % 2 == 0a = map(even, range(10)) #迭代器[x for x in a] #[True, False, True, False, True, False, True, False, True, False] 使用lamda函数 1map(lamda x: x ** 2, ) filter:筛选匹配函数布尔值的元素 12a = filter(even, range(10))[x for x in a] #[0, 2, 4, 6, 8] reduce:归纳列表 求列表和的例子12from functools import reducereduce(lambda x, y: x+ y, range(15)) Python 字符串逆序12s = \"123你好世界def\"s[::-1] str[begin:end:step] step 默认值为1 深层拷贝deepcopy的运用1234a = [0.5, 1]b = aa[0] = 3b #[3, 1] 12345from copy import deepcopya = [0.5, 1]b = deepcopy(a)a[0] = 3b #[0.5, 1] 参考：https://iaman.actor/blog/2016/04/17/copy-in-python","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python安装MySQL-Python库","date":"2017-07-22T11:48:05.000Z","path":"2017/07/22/Python安装MySQL-Python库/","text":"Python2.7安装MySQL-Python直接执行pip命令1pip2 install MySQL-Python 报错_mysql.c(42) : fatal error C1083: Cannot open include file: ‘config-win.h’: No such file or directory 安装mysql-connector-curl: https://dev.mysql.com/downloads/connector/c/6.0.html 下载相应的版本，比如64位的windows则下载： mysql-connector-c-6.0.2-winx64.msi 默认安装即可 再次执行pip命令还是同样的错误，去mysql-connector-c的安装目录下查找，config-win.h文件确实已经有了。 奇怪，把目录设到环境变量Path中也不行。既然是编译的时候报错了，是不是驾驶INCLUDE目录就行了呢？ 设置编译INCLUDE和LIB目录cmd输入 12SET INCLUDE=C:\\Program Files\\MySQL\\MySQL Connector C 6.0.2\\includeSET LIB=C:\\Program Files\\MySQL\\MySQL Connector C 6.0.2\\lib\\opt 再次执行pip，安装成功 Python3安装MySQL-Python安装上面同样的方法之后，还是报错 mysqlclient.lib中函数undefined，暂时不知道怎么解决。","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Python核心编程学习笔记","date":"2017-07-12T14:08:46.000Z","path":"2017/07/12/Python核心编程学习笔记/","text":"正则表达式常见正则表达式符号和字符 表示法 描述 示例 literal 匹配字符串字面值 re.match(‘foo’, ‘food’) re1 re2 匹配正则表达式re1或者re2 re.match(‘ab\\ cd’, ‘abd’) . 匹配任何字符（除了\\n之外） re.match(‘.e’, ‘de’) ^ 匹配字符串起始部分 re.match(‘^Dear’, ‘Dear my baby’) $ 匹配字符串的终止部分 re.search(‘baby$’, ‘Dear my baby’) * 匹配0次或多次前面出现的正则表达式 re.search(‘ba*b’, ‘Dear my baby’) + 匹配1次或多次前面出现的正则表达式 re.search(‘\\w+.com’, ‘http://ww.baidu.com‘) ? 匹配0次或1次前面出现的正则表达式 re.search(r’b\\w?.com’, ‘http://ww.ba.com‘) {n} 匹配n次前面出现的正则表达式 re.search(r’[0-9]{3}’, ‘87a45b775c’) {m, n} 匹配m到n次前面出现的正则表达式 re.search(r’[0-9]{2,3}’, ‘87a45b775c’) [x-y] 匹配x~y范围内的任意”单一字符” re.search(‘[a-z]’, ‘123ACFdGH’) [^…] 不匹配此字符集中出现的任意字符 re.search(‘[^A-Z]’, ‘ASDG1KL’) (…) 匹配封闭的正则表达式，并另存为子组 re.search(‘([A-Z]{3}).([0-9]{3})’, ‘ASDG123’).group() \\d 匹配任何十进制数，同[0-9]，与\\D相反 re.search(r’\\d’, ‘ASDG123’) \\w 匹配任何字母数字下划线，同[A-Za-z0-9_]，与\\W相反 re.search(r’\\w’, ‘:”@#$a_+’) \\s 匹配任何空格字符，与[\\n\\t\\v\\f]同，与\\S相反 re.search(r’\\s’, ‘:”abc def’) \\b 匹配任何边界字符，与\\B相反 re.search(r’\\bThe\\b’, ‘:”They is not The’) \\N 匹配已保存的子组，其中N为1,2… price:\\16 \\c 匹配特殊字符 .,\\,* 网络编程TCP示例代码tcp服务器 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-from socket import *from time import ctimeHOST = ''PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)tcpSerSock = socket(AF_INET, SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: print(\"waiting for connection...\") tcpCliSock, addr = tcpSerSock.accept() print('...connected from :', addr) while True: data = tcpCliSock.recv(BUFSIZE) if not data: break #tcpCliSock.send(bytes('hello', 'utf-8')) sendData = '[%s] %s' % (ctime(), data.decode('utf-8')) tcpCliSock.send(bytes(sendData, 'utf-8')) tcpCliSock.close()tcpSerSock.close() tcp客户端 12345678910111213141516171819202122# -*- coding: utf-8 -*-from socket import *HOST = '127.0.0.1'PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)tcpClt = socket(AF_INET, SOCK_STREAM)tcpClt.connect(ADDR)while True: data = input('&gt; ') if not data: break tcpClt.send(bytes(data, 'utf-8')) data = tcpClt.recv(BUFSIZE) if not data: break print(data.decode('utf-8'))tcpClt.close() udp服务器 123456789101112131415161718from socket import *from time import ctimeHOST = ''PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)udpSerSock = socket(AF_INET, SOCK_DGRAM)udpSerSock.bind(ADDR)while True: print('waiting for message ...') data, addr = udpSerSock.recvfrom(BUFSIZE) sendData = '[%s] %s' % (ctime(), data.decode('utf-8')) udpSerSock.sendto(bytes(sendData, 'utf-8'), addr) print('...received from and returned to :', addr)udpSerSock.close() udp客户端 123456789101112131415161718from socket import *HOST = '127.0.0.1'PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)udpCltSock = socket(AF_INET, SOCK_DGRAM)while True: data = input('&gt; ') if not data: break udpCltSock.sendto(bytes(data, 'utf-8'), ADDR) data, addr = udpCltSock.recvfrom(BUFSIZE) if not data: break print(data)udpCltSock.close() Web客户端和服务器urlparse模块注：以下皆以Python3为例 urlparse 1234from urllib.parse import urlparseurlparse(\"http://www.baidu.com\")OUT: ParseResult(scheme='http', netloc='www.baidu.com', path='', params='', query='', fragment='') urlunparse 123456from urllib.parse import urlparsefrom urllib.parse import urlunparseo = urlparse(\"http://www.baidu.com\")urlunparse(o)OUT: 'http://www.baidu.com' urljoin 将两个文件结合起来，但是不包括前一个文件的末端文件名 1234from urllib.parse import urljoinurljoin(\"http://www.baidu.com/doc/faq.html\", \"test/a/1.html\")OUT: 'http://www.baidu.com/doc/test/a/1.html'","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"日常记录备忘","date":"2017-07-01T07:38:26.000Z","path":"2017/07/01/日常记录备忘/","text":"系统同时配置了py2和py3环境，运行rf脚本无反应因为ride不支持py3，只能使用py2需要将Python27\\Scripts\\pybot.bat中[python]替换为[python2] 使用uiautomatorviewer.bat时提示unable connect to adb修改前： -Dcom.android.uiautomator.bindir=%prog_dir% 修改后： -Dcom.android.uiautomator.bindir=%ANDROID_HOME%\\tools android相关命令获取已安装的应用的包名adb shell pm list packages 获取包名对应的路径adb shell pm path com.huawei.ca 其中com.huawei.ca为相应的包名 查看已安装应用的Activity先打开应用，再输入以下命令 adb shell dumpsys window w |findstr \\/ | findstr name= 或者： adb shell dumpsys window windows | findstr mFocusedApp","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python爬虫学习笔记","date":"2017-06-28T12:05:49.000Z","path":"2017/06/28/Python爬虫学习笔记/","text":"Requests库的使用安装pip3 install requests 使用获取百度首页的内容1234import requestsr = requests.get(\"http://www.baidu.com\")r.encoding = \"utf-8\"print(r.text) 主要API request “集大成者”，可构造以下的各个请求。 get 获取页面内容的接口，对应于HTTP的GET 函数完整定义如下： 123456789101112def get(url, params=None, **kwargs): r\"\"\"Sends a GET request. :param url: URL for the new :class:`Request` object. :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`. :param \\*\\*kwargs: Optional arguments that ``request`` takes. :return: :class:`Response &lt;Response&gt;` object :rtype: requests.Response \"\"\" kwargs.setdefault('allow_redirects', True) return request('get', url, params=params, **kwargs) 注释部分已将各个参数及返回值含义解释清楚。 get函数返回的Response对象包含了爬虫返回的全部内容。主要包括 属性 说明 status_code 请求的状态码，200表示连接成功，404表示连接失败 text 响应内容的字符串形式 encoding 从header中取得的内容编码方式 apparent_encoding 从内容中分析出的响应内容的编码方式 content 响应内容的二进制形式 爬取网页的一般框架 1234567891011121314import requestsdef getHTMLText(url): try: r = requests.get(url) r.raise_for_status() #非正常状态，如404时，会产生异常 r.encoding = r.apparent_encoding return r.text except: return \"产生异常\"if __name__ == \"__main__\": url = \"http://www.baidu.com\" print(getHTMLText(url)) head 获取页面头信息的接口，对应于HTTP的HEAD 优势：网络流量小 123import requestsr = requests.head(\"http://www.baidu.com\")print(r.headers) post 向网页提交POST请求的接口，对应于HTTP的POST 1234import requestspayload = &#123;\"key1\" : \"value1\", \"key2\" : \"value2\"&#125;r = requests.post(\"http://httpbin.org/post\", data=payload)print(r.text) put 向网页提交PUT请求的接口，对应于HTTP的PUT 与post类似，会将原有的数据覆盖 1234import requestspayload = &#123;\"key1\" : \"value1\", \"key2\" : \"value2\"&#125;r = requests.put(\"http://httpbin.org/put\", data=payload)print(r.text) patch 向网页提交局部修改请求的接口，对应于HTTP的PATCH delete 向网页提交删除请求的接口，对应于HTTP的DELETE","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Win10下py2和py3共存","date":"2017-06-28T11:40:53.000Z","path":"2017/06/28/Win10下py2和py3共存/","text":"安装Python2和Python3从官网分别下载Python2.x和Python3.x版本的程序进行安装。安装方法略。 并将分别将Python加入到环境变量中。安装正确的话，环境变量中应当存在以下值。 path\\to\\Python27 path\\to\\Python27\\Scripts path\\to\\Python36 path\\to\\Python36\\Scripts 将Python27根目录下的python.exe,pythonw.exe分别重命名为python2.exe,python2w.exe 将Python36根目录下的python.exe,pythonw.exe分别重命名为python3.exe,python3w.exe cmd执行命令python2和python3查看是否成功 pip2和pip3设置cmd分别执行以下命令： python3 -m pip install –upgrade pip –force-reinstall python2 -m pip install –upgrade pip –force-reinstall 安装成功之后，可通过[pip2 install xxx]和[pip3 install xxx]来安装各自的包啦！","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"vi常用命令","date":"2017-06-27T13:43:16.000Z","path":"2017/06/27/vi常用命令/","text":"三种模式vi总共有三种模式，命名方法不一，暂且命名为 默认模式 命令模式 编辑模式 三种模式之间的切换及主要功能如下图所示： *使用vi命令时，最初始进入的即为默认模式 常用命令默认模式翻页[Ctrl+u] 向前翻半屏 [Ctrl+d] 向后翻半屏 [Ctrl+f] 向前翻一屏 [Ctrl+b] 向后翻一屏 移动光标[h] 向左移动光标（类似于左键） [j] 向下移动光标（类似于下键） [k] 向上移动光标（类似于上键） [l] 向右移动光标（类似于右键） [0] 移动光标到行首（类似于Home键） [$] 移动光标到行首（类似于End键） [G] 移动光标到末行行首 [nG] 移动光标到第n行行首，n为1,2,3… [gg] 移动光标到首行行首,类似于[1G] [1+Enter] 光标向下移动n行至行首 删除文本[x] 删除光标后的一个字符（X为向前删除一个字符） [dd] 删除光标在的一整行 [ndd] 删除光标所在行在内向后的n行。n为1,2,3… 复制粘贴[yy] 复制光标所在行 [nyy] 复制光标所在行在内向后的n行。n为1,2,3… [p] 粘贴复制的内容到所在行的下一行（P为粘贴到上一行） 撤销重复[u] 撤销上次操作（类似普通编辑器常用的Ctrl+z） [.] 重复上次的操作（不论上一次是什么操作） 命令模式查找[/word] 向下查找字符串 [?word] 向上查找字符串 [n] 查找下一个，若查找命令[/]则为向下查找，若为[?]则为向上查找（N正好相反） 行号[:set number] 左侧显示行号 [:set nonumber] 左侧不显示行号 保存退出[:w] 保存文件 [:w!] 若文件为只读，强制保存文件 [:q] 离开vi，若有修改未保存，会有警告 [:q!] 强制退出vi [:wq] 保存后退出vi [:wq!] 强制保存后退出vi [:w newfilename] 另存为 编辑模式[i] 从当前光标所在处插入[a] 从当前光标的下一个字符处插入[o] 从当前光标的下一行插入","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"vi","slug":"vi","permalink":"http://yoursite.com/tags/vi/"}]},{"title":"Hello World","date":"2017-06-24T13:45:47.239Z","path":"2017/06/24/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]