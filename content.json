[{"title":"关于C++11for循环的问题","date":"2018-02-22T03:23:51.000Z","path":"2018/02/22/关于C++11for循环的问题/","text":"C++11 for循环新增功能参考：基于范围的 for 循环 然而在使用过程中发现问题代码如下1234567#include &lt;stdio.h&gt;int main()&#123; for(int i : &#123;1, 3, 5&#125;) printf(\"%d\\n\", i); return 0;&#125; 编译报错1234'&lt;begin&gt;': identifier not founderror C3312: no callable 'begin' function found for type 'initializer list'error C3861: '&lt;end&gt;': identifier not founderror C3312: no callable 'end' function found for type 'initializer list' 在头部加上#include vector问题解决 问题原因根据出错信息，知道”for a : b”这种语法是依赖于’initializer list’的，查看vector源码得知，vector中包含initializer_list类的大致路径如下：vector -&gt; xmemory -&gt; xmemory0 -&gt; limits -&gt; xstddef -&gt; initializer_list不排除其他引用路径，不过这不是重点 所以，其实不一定要包含vector类，而包含stack,queue等类都是可以的，甚至直接包含initializer_list类就行","tags":[{"name":"C++11","slug":"C-11","permalink":"http://yoursite.com/tags/C-11/"}]},{"title":"经典算法系列（一）","date":"2018-02-22T00:23:51.000Z","path":"2018/02/22/经典算法系列（一）/","text":"汉诺塔问题 描述有三根柱子依次排列，第一根柱子上有n个从小到大盘子，需要将这n个盘子移动到第三个根柱子上，要求 每次只能移动一个盘子 大盘子不能放到小盘子之上 解法一：递归解法 假设需要将[1]一个盘子，从柱A借助柱B移动到柱C。则直接将[1]从A移动到C即可 假设需要将[1,2]两个盘子，从柱A借助柱B移动到柱C。则先将[1]从A-&gt;B，再将[2]从A-&gt;C，再将[1]从B-&gt;C 假设需要将[1,2,3]三个盘子，从柱A借助柱B移动到柱C。先想办法把[1,2]从A-&gt;B(借助C)，再将[3]从A-&gt;C，再将[1,2]从B-&gt;C(借助A) 上面推理的过程，即为递归的逆过程。实现代码如下123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;void move(int n, char from, char to)&#123; printf(\"[%d]: %c-&gt;%c\\n\", n, from, to); counter++;&#125;void hanoi_recursive(int depth, char from, char by, char to)&#123; if(depth == 1) &#123; move(1, from, to); &#125; else &#123; hanoi_recursive(depth - 1, from, to, by); move(depth, from, to); hanoi_recursive(depth - 1, by, from, to); &#125;&#125;int main()&#123; hanoi(3, 'A', 'B', 'C'); return 0;&#125; 输出如下1234567[1]: A-&gt;C[2]: A-&gt;B[1]: C-&gt;B &#123;1,2,3&#125;行的作用为将[1,2]从A-&gt;B(借助C)[3]: A-&gt;C 将[3]从A-&gt;C[1]: B-&gt;A[2]: B-&gt;C[1]: A-&gt;C &#123;5,6,7&#125;行的作用为将[1,2]从B-&gt;C(借助A) 解法二：非递归解法递归解法很清晰，也好实现，规律找到，代码容易写出。如果不是不能使用递归，就不要自寻烦恼了。对于很多问题，如果不能使用递归，就需要利用栈等特殊的数据结构（二叉树遍历也是） 先看实现代码12345678910111213141516171819202122232425262728293031323334//struct的5个值分别代表://depth:当前层数，为1则不需要再迭代//n:当前移动盘子编号//from:起始柱子，by：经过柱子，to：目的柱子struct hanoiData&#123; int depth; int n; char from; char by; char to;&#125;;void hanoi_stack(int depth, char from, char by, char to)&#123; stack&lt;hanoiData&gt; stk; stk.push(&#123;depth, depth, from, by, to&#125;); while(!stk.empty()) &#123; hanoiData d = stk.top(); stk.pop(); if(d.depth == 1) move(d.n, d.from, d.to); else &#123; stk.push(&#123;d.depth - 1, d.depth - 1, d.by, d.from, d.to&#125;); stk.push(&#123;1, d.depth, d.from, d.by, d.to&#125;); stk.push(&#123;d.depth - 1, d.depth - 1, d.from, d.to, d.by&#125;); &#125; &#125;&#125; 我的思路还是将整个过程且切分为3个部分 将前n - 1个盘子A-&gt;B 将盘子n从A-&gt;C 将n - 1个盘子从B-&gt;C因为栈后进先出的关系，索引将操作3,2,1依次入栈这样执行顺序就是1,2,3了 将操作1出栈执行时，发现深度为n-1，重复执行上面的步骤 和网上这位兄台想到一块去了，事先真没参考 递归非递归性能比较很遗憾，我的这种非递归解法和递归解法性能差了不止一个数量级12hanoi recursive, result:1048575 elapse time :7011 microsecondshanoi stack, result:1048575 elapse time :917490 microseconds 斐波那契数列 描述fn = fn-1 + fn-2 if n &gt; 1fn = n if n = 0, 1求fn 解法参考递归的性能 杨辉三角 描述按如下规律打印 12345678 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 11 7 21 35 35 21 7 1 解法主要是打印有点麻烦，规律还是好找的 123456789101112131415161718192021222324252627#define N 13int arr[N][N] = &#123;0&#125;;void yanghui()&#123; for(int i = 0; i &lt; N; ++i) &#123; arr[i][0] = arr[i][i] = 1; for(int j = 1; j &lt; i; ++j) &#123; arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j]; &#125; &#125; for(int i = 0; i &lt; N; ++i) &#123; for(int k = 0; k &lt; (N - i)*3; k++) printf(\" \"); for(int j = 0; j &lt; N; ++j) &#123; if(arr[i][j] == 0) break; printf(\"%6d\", arr[i][j]); &#125; printf(\"\\n\"); &#125;&#125; 三色旗问题 描述假设有一条绳子，上面有红、白、蓝三种颜色的旗子，起初绳子上的旗子颜色并没有顺序（旗子个数也未知），您希望将之分类，并排列为蓝、白、红的顺序，要如何移动次数才会最少，注意您只能在绳子上进行这个动作，而且一次只能调换两个旗子。 解法参考三色旗问题Dutch national flag problemDutch National Flag很迷惑人的错误解法 12345678910111213141516171819202122232425262728void swap(char color[], int indexA, int indexB)&#123; if(indexA == indexB) &#123; printf(\"index is equal\\n\"); return; &#125; char temp = color[indexA]; color[indexA] = color[indexB]; color[indexB] = temp;&#125;void threeColor_error(char color[], int size)&#123; int bflag = 0, wflag = 0, rflag = size - 1; while(wflag &lt;= rflag) &#123; if(color[wflag] == 'b') swap(color, bflag++, wflag++); else if(color[wflag] == 'r') swap(color, wflag++, rflag--); else wflag++; &#125;&#125;char color[] = &#123;'r','w','b','w','w','b', 'r','b','r','w'&#125;;int size = sizeof(color);threeColor_error(color, size); 错误过程重现如下12345678910r &lt;-bF &lt;-wF w &lt;-bF w &lt;-bF b bw w &lt;-wF w w &lt;-bF w &lt;-bFb b b &lt;-wF w ww w w w &lt;-wF ww w w w wb b b b b &lt;-wFr r r r rb b b b br r &lt;-rF r &lt;-rF r &lt;-rF r &lt;-rFw &lt;-rF r r r r 12345678910b b bb b bw &lt;-bF w &lt;-bF bw w w &lt;-bFw w ww w wr &lt;-wF r rb b &lt;-wf &lt;-rF w &lt;-rFr &lt;-rF r r &lt;-wFr r r 错误原因：将swap(color, wflag++, rflag–)修改成swap(color, wflag, rflag–)即可为什么呢？先看正确的过程如下12345678910r &lt;-bF &lt;-wF w &lt;-bF &lt;-wF w &lt;-bF b bw w w w &lt;-bF w &lt;-bFb b b &lt;-wF w ww w w w &lt;-wF ww w w w wb b b b b &lt;-wFr r r r rb b b b br r &lt;-rF r &lt;-rF r &lt;-rF r &lt;-rFw &lt;-rF r r r r 12345678910b b b bb b b bw &lt;-bF w &lt;-bF w &lt;-bF bw w w w &lt;-bFw w w ww w w wr &lt;-wF r &lt;-wf b &lt;-wF &lt;-rF w &lt;-rFb b &lt;-rF r r &lt;-wFr &lt;-rF r r rr r r r 所以我总结，如果将wFlag指向的红旗子和rFlag指向的旗子（未知颜色）交换时，wFlag自增了，而此时rFlag本来指向的就是红旗子时，wFlag就会错过一枚红旗子 优雅的分析 老鼠走迷宫（一）参考 描述我们在二维阵列中使用2表示迷宫墙壁，使用1来表示老鼠的行走路径，求出由入口至出口的路径。 递归解法完全参考之前8皇后问题的回溯解法完整代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#define N 9int maze[N][N] = &#123; &#123;2,2,2,2,2,2,2,2,2&#125;, &#123;2,0,0,0,0,0,0,0,2&#125;, &#123;2,0,2,2,0,2,2,0,2&#125;, &#123;2,0,2,0,0,2,0,0,2&#125;, &#123;2,0,2,0,2,0,2,0,2&#125;, &#123;2,0,0,0,0,0,2,0,2&#125;, &#123;2,2,0,2,2,0,2,2,2&#125;, &#123;2,0,0,0,0,0,0,0,2&#125;, &#123;2,2,2,2,2,2,2,2,2&#125; &#125;;void print()&#123; for (int i = 0 ; i &lt; N ; i++) &#123; for (int j = 0 ; j &lt; N ; j++) &#123; if(maze[i][j] == 2) printf(\"▉\"); else if(maze[i][j] == 1) printf(\"◇\"); else printf(\" \"); &#125; printf(\"\\n\"); &#125;&#125;bool check(int row, int col)&#123; if(maze[row][col] == 0) return true; return false;&#125;static int counter = 0;void backtrack(int row, int col)&#123; maze[row][col] = 1; if(row == N - 2 &amp;&amp; col == N - 2) &#123; printf(\"solution:%d\\n\", ++counter); print(); &#125; else &#123; int direction[4][2] = &#123;&#123;row, col - 1&#125;, &#123;row - 1, col&#125;, &#123;row, col + 1&#125;, &#123;row + 1, col&#125;&#125;; for(int i = 0; i &lt; 4; ++i) &#123; int newRow = direction[i][0], newCol = direction[i][1]; if(check(newRow, newCol)) &#123; backtrack(newRow, newCol); maze[newRow][newCol] = 0; &#125; &#125; &#125;&#125;int main()&#123; printf(\"original:\\n\"); print(); backtrack(1, 1); return 0;&#125; 输出如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950original:▉▉▉▉▉▉▉▉▉▉ ▉▉ ▉▉ ▉▉ ▉▉ ▉ ▉ ▉▉ ▉ ▉ ▉ ▉▉ ▉ ▉▉▉ ▉▉ ▉▉▉▉ ▉▉▉▉▉▉▉▉▉▉solution:1▉▉▉▉▉▉▉▉▉▉◇◇◇◇ ▉▉ ▉▉◇▉▉ ▉▉ ▉◇◇▉ ▉▉ ▉◇▉ ▉ ▉▉ ◇◇ ▉ ▉▉▉◇▉▉ ▉▉▉▉ ◇◇◇◇◇◇▉▉▉▉▉▉▉▉▉▉solution:2▉▉▉▉▉▉▉▉▉▉◇◇◇◇ ▉▉ ▉▉◇▉▉ ▉▉ ▉◇◇▉ ▉▉ ▉◇▉ ▉ ▉▉ ◇◇◇▉ ▉▉▉ ▉▉◇▉▉▉▉ ◇◇◇▉▉▉▉▉▉▉▉▉▉solution:3▉▉▉▉▉▉▉▉▉▉◇ ▉▉◇▉▉ ▉▉ ▉▉◇▉ ▉ ▉▉◇▉ ▉ ▉ ▉▉◇◇◇◇◇▉ ▉▉▉ ▉▉◇▉▉▉▉ ◇◇◇▉▉▉▉▉▉▉▉▉▉solution:4▉▉▉▉▉▉▉▉▉▉◇ ▉▉◇▉▉ ▉▉ ▉▉◇▉ ▉ ▉▉◇▉ ▉ ▉ ▉▉◇◇ ▉ ▉▉▉◇▉▉ ▉▉▉▉ ◇◇◇◇◇◇▉▉▉▉▉▉▉▉▉▉ 需要注意第62行清空当前状态是必须的 非递归解法参考8皇后的非递归解法，应该也是可以做的，暂时没想好","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"图解排序算法之冒泡排序","date":"2018-02-17T06:23:51.000Z","path":"2018/02/17/图解排序算法之冒泡排序/","text":"一直想做一个通过动态图片来演示排序算法的事情，做到新手也能看懂。 目前想法是利用Python的turtle库来做，希望能做完吧。 简单演示 过程有点啰嗦，专供小白。 图中的代码见下面的完整代码 完整实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152# -*- coding:utf-8 -*-from turtle import *from time import sleep#冒泡排序#参数l:待排序列表def bubblesort(l): size = len(l) for i in range(size - 1): swapped = False ipointer.updateText((size / 2 - i - 1) * DISTANCE, 'size-i-1=%d' % (size - i - 1)) for j in range(size - i - 1): jpoiner.updateText((j - size / 2) * DISTANCE, 'j=%d' % j) setcolor((j, j + 1), 'red') if l[j] &gt; l[j + 1]: swapped = True swap(l, j, j + 1) setcolor((j, j + 1), 'black') if not swapped: breakclass Circle(Turtle): def __init__(self, ypos, r): Turtle.__init__(self) self.r = r self.ypos = ypos self.ht() self.pensize(3) self._drawCircle() def _drawCircle(self): self.penup() self.sety(self.ypos) self.pendown() self.circle(self.r) self.penup() self.sety(self.ypos + self.r - 15) self.pendown() self.write(str(radius_to_data(self.r)), align=\"center\", font=('Microsoft YaHei', 15)) def updateColor(self, color): tracer(False) self.clear() self.pencolor(color) self._drawCircle() tracer(True) def move(self, yshift): tracer(False) self.clear() self.ypos += yshift self._drawCircle() tracer(True)class Pointer(Turtle): def __init__(self, alignRight): Turtle.__init__(self) self.ht() self.pensize(3) self.penup() self.alignRight = alignRight if alignRight == True: self.setx(80) self.left(180) else: self.setx(-80) self.pendown() def _drawArrow(self): self.forward(20) self.left(150) self.forward(5) self.penup() self.back(5) self.left(60) self.pendown() self.forward(5) self.left(150) # reset direction self.penup() self.back(20) self.pendown() def updateText(self, ypos, txt, fontsize=15): tracer(False) self.clear() self.penup() self.sety(ypos) self.pendown() self._drawArrow() align = \"left\" if self.alignRight == False: align = \"right\" self.penup() self.sety(ypos - fontsize) self.pendown() self.write(txt, align = align, font=('Microsoft YaHei', fontsize)) tracer(True)#显示相关的箭头，与排序无关ipointer = Pointer(True)jpoiner = Pointer(False)circles = [] DISTANCE = 90STEP = 6def move_by_step(i, j, distance): moverA = circles[i] moverB = circles[j] count = 0 while distance &gt; 0: count += 1 distance -= STEP moverA.move(STEP) moverB.move(-STEP) sleep(0.1) circles[i] = moverB circles[j] = moverA def swap(l, i, j): move_by_step(i, j, DISTANCE * (j - i)) t = l[i] l[i] = l[j] l[j] = tdef setcolor(tup, color): for i in tup: circles[i].updateColor(color)def data_to_radius(d): return 15 + d * 4def radius_to_data(r): return int((r - 15) / 4)if __name__ == \"__main__\": setup(450, 750) arr = [7, 3, 4, 1, 5, 2, 6] size = len(arr) tracer(False) for i in range(size): ycenter = i - size / 2 r = data_to_radius(arr[i]) print(r) c = Circle(ycenter * DISTANCE - r, r) circles.append(c) tracer(True) print('before sort', arr) bubblesort(arr) print('after sort', arr) mainloop() 显然，目前写的turtle代码还不能复用到其他排序算法，后面考虑如何集成","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"图论算法","date":"2018-02-17T02:23:51.000Z","path":"2018/02/17/图论算法/","text":"若干定义 图（graph）G=(V,E)右顶点（vertex）的集V和边（edge）的集E组成 每一条边就是一个点对(v, w)，其中v,w∈V，有时也把边称作弧（arc） 如果点对是有序的，那么图就叫做有向的图，也叫做有向图（digraph） 顶点v和w邻接（adjacent）当且仅当(v,w)∈E。在无向图中有边(v,w)，则w和v邻接，且v和w邻接 有时候边还具有第三种成分，称作权(weight)或值(cost) 图的一条路径(path)是一个顶点序列w1,w2,..,wN，其中(wi,wi+1)∈E。路径的长(length)是该路径的边数，为N-1 有向图的回路(cycle)是满足w1=wN且长度至少为1的一条路径。对于无向图，我们要求变是互异的 如果一个有向图没有回路，则称其为无环的(acyclic)，简称为DAG 如果无向图中每个顶点到每个其他顶点都存在一条路径，则称该无向图是连通的(connected)。具有这样性质的有向图称为强连通的（strongly connected）。 如果有向图不是强连通的，但基础图（underlying graph，弧上去掉方向所形成的图）是连通的，则称该有向图为弱连通的（weakly connected） 完全图（complete graph）是其每一对顶点间都存在一条边的图 图的表示 邻接矩阵，即二维数组数组的项默认为false，对于每条边，置A[u][v]=true;如果变有权，则可置A[u][v]等于该权，使用很大或很小的权表示不存在的边 这种表示法的优点是非常简单，但空间需求过大，如果图的边不是很多，则这种表示法的代价太大。 邻接表对于每个顶点，使用一个表存放所有邻接的顶点 邻接表是图的标准表示方法 拓扑排序拓扑排序（topological sort）是对有向无环图的顶点的一种排序，它使得如果存在一条从vi到vj的路径，那么在排序种vj出现在vi的后面。注意拓扑排序不必是唯一的：任何合理的排序都是可以的。 简单拓扑排序 先找出任意一个没有入边的顶点，显示出该顶点 将该顶点和他的边一起从图中删除 对图的其余部分应用同样的方法处理 把顶点v的入度（indegree）定义为边(u,v)的条数，假设每一个顶点的入度被存储且图被读入一个邻接表中。 伪代码123456789101112void Graph::topsort()&#123; for(int counter = 0; counter &lt; NUM_VETICES; counter++) &#123; Vertex v = findNewVertexOfIndegreeZero(); if(v == NOT_A_VERTEX) throw CycleFoundException(); v.topNum = counter; for each Vertex w adjacent to v: w.indegree--; &#125;&#125; 函数findNewVertexOfIndegreeZero扫描数组，寻找一个尚未被分配拓扑编号的入度为0的顶点，如果不存在这样的顶点，返回NOT_A_VERTEX，意味着图有回路。由于findNewVertexOfIndegreeZero函数是对顶点的数组的一个简单顺序扫描，索引每次调用花费O(|V|)时间，总运行时间为O(|V|2) 利用队列的拓扑排序 计算每个顶点的入度，将所有入度为0的顶点放入一个初始为空的队列 当队列不空时，删除一个顶点v，并将于v邻接的所有顶点入度减1 只要顶点的入度将为0，就把该顶点放入队列 拓扑排序就是顶点出队的顺序 伪代码1234567891011121314151617181920void Graph::topsort()&#123; Queue&lt;Vertex&gt; q; int counter = 0; q.makeEmpty(); for each Vertex v if(v.indegree == 0) q.enqueue(v); while(!q.isEmpty()) &#123; Vertex v = q.dequeue(); v.topNum = ++counter; //Assign next number for each Vertex w adjacent to v if(--w.indegree == 0) q.enqueue(w); &#125; if(counter != NUM_VERTICES) throw CycleFoundException();&#125; 书中给出示例如下 最短路径算法输入为加权图 单元最短路径问题：给定一个加权图G=(V,E)和一个特定顶点s作为 输入，找出s到G中每一个其他顶点的最短加权路径 无权最短路径 广度优先搜索类似于数的层序遍历 123456789101112131415161718192021void Graph::unweighted(Vertex s)&#123; for each Vertex v &#123; v.dist = INFINITY; v.known = false; &#125; s.dist = 0; for(int currDist = 0; currDist &lt; NUM_VERTICES; currDist++) for each Vertex v if(!v.known &amp;&amp; v.dist == currDist) &#123; v.known = true for each Vertex w adjacent to v if(w.dist == INFINITY) &#123; w.dist = currDist + 1; w.path = v; &#125; &#125;&#125; 利用队列优化 12345678910111213141516171819void Graph::unweighted(Vertex s)&#123; Queue&lt;Vertex&gt; q; for each Vertex v v.dist = INFINITY; s.dist = 0; q.enqueue(s) while(!q.isEmpty()) &#123; Vertex v = q.dequeue(); for each Vertex w adjacent to v if(w.dist == INFINITY) &#123; w.dist = v.dist + 1; w.path = v; q.enqueue(w); &#125; &#125;&#125; Dijkstra算法好难，待续~","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"随机化算法","date":"2018-02-07T12:23:51.000Z","path":"2018/02/07/随机化算法/","text":"线性同余数生成器数x1,x2…的生成满足 xi+1 = Aximod M 需要给出x0作为种子，比如x0 = 1, M = 11, A = 7时生成的数为17, 5, 2, 3, 10, 4, 6, 9, 8, 1, 7, 5... 经验总结，建议M取231 - 1 = 2147483647, A取48271 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;static const int M = 2147483647;static const int A = 48271;static const int Q = M / A;static const int R = M % A;class Random&#123;public: explicit Random(int initialValue = 1); int randomInt(); double random0_1(); int randomInt(int low, int high);private: int state_;&#125;;Random::Random(int initialValue)&#123; if(initialValue &lt; 0) initialValue += M; state_ = initialValue; if(state_ == 0) state_ = 1;&#125;int Random::randomInt()&#123; int tempState = A * (state_ % Q) - R*(state_ / Q); if(tempState &gt;= 0) state_ = tempState; else state_ = tempState + M; return state_;&#125;double Random::random0_1()&#123; return (double)randomInt() / M;&#125;int Random::randomInt(int low, int high)&#123; if(low &gt; high) return -1; return randomInt() % (high - low + 1) + low;&#125;int main()&#123; Random r; printf(\"%d\\n\", r.randomInt()); printf(\"%f\\n\", r.random0_1()); printf(\"%d\\n\", r.randomInt(3, 10)); return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++中交换两个元素值","date":"2018-02-04T04:23:51.000Z","path":"2018/02/04/C++中交换两个元素/","text":"首先，交换变量值的函数传值肯定不行，要么传引用，要么传指针，以传引用为例 一般方法使用临时变量123456void swap(int &amp;a, int &amp;b)&#123; int t = a; a = b; b = t;&#125; 不使用临时变量位运算123456void swap(int &amp;a, int &amp;b)&#123; a = a ^ b; b = a ^ b; a = a ^ b;&#125; 可以这么理解123newa = olda ^ oldbnewb = newa ^ oldb = olda ^ oldb ^ oldb = oldanewa = newa ^ newb = olda ^ oldb ^ olda = oldb 如此完成交换。 但是该位运算存在一个问题，对于数组的交换要注意。 有一次写快速排序的时候使用了位运算的swap，结果数组里出现了好多0。分析之后原因如下 比如数组为a = {3, 1, 2}，然后调用了swap(a[1], a[1])，那这样会导致什么呢 1a[1] = a[1] ^ a[1] = 0 即a[1]会被置为0。 当然，调用者本就应该来判断待交换的索引是否相同，如果相同就不交换了。但函数本身最好也要加上不等性判断12if(a == b) return; 算术运算123456void swap(int &amp;a, int &amp;b)&#123; a = a + b; b = a - b; a = a - b;&#125; 可以这么理解 123newa = olda + oldbnewb = newa - oldb = olda + oldb - oldb = oldanewa = newa - newb = olda + oldb - olda = oldb 同样存在上面的问题","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"回溯算法","date":"2018-02-02T12:08:46.000Z","path":"2018/02/02/回溯算法/","text":"以前听到这个名字挺害怕的，其实也就那么回事 是什么回溯（backtracking）,在多数情况下，相当于穷举搜索的巧妙实现。 一般是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径 下面来看几个使用回溯算法的经典问题 问题一：8皇后问题描述在8×8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后都不能处于同一行，同一列或同一斜线 各种解法 递归解法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#define QUEENS 8//通过前depth-1个元素，检查当前元素的放置是否合法bool check(int arr[], int depth)&#123; for(int i = 1; i &lt; depth; ++i) &#123; if(arr[i] == arr[depth] || //两个元素相等 (arr[i] - arr[depth]) == (i - depth) || //两个元素在正对角线 (arr[i] - arr[depth]) == (depth - i)) //两个元素在反对角线 return false; &#125; return true;&#125;static int k = 1;//arr表示放置皇后的结果数组，depth表示放置第几个（行）的皇后void backtracking(int arr[], int depth)&#123; if(depth &lt;= QUEENS) &#123; for(int i = 1; i &lt;= QUEENS; ++i) &#123; //第depth个元素分别放置[1..QUEENS]的元素来试探 arr[depth] = i; //若检查合法则放置下一个元素 if(check(arr, depth)) backtracking(arr, depth + 1); &#125; &#125; else //表示前8个元素全部放置成功，得到结果 &#123; printf(\"solution %2d: \", k++); for(int i = 1; i &lt;= QUEENS; ++i) printf(\"%d \", arr[i]); printf(\"\\n\"); &#125;&#125;int main()&#123; //以数组表示8皇后问题的解，数组中每个元素的索引代表行，值代表列 //比如a[2] = 3表示第二行第三列放置一个皇后 int array[QUEENS + 1] = &#123;0&#125;; backtracking(array, 1); return 0;&#125; 此方法虽然条理较清晰，但是并没有让人感觉到回溯的思想 非递归解法12345678910111213141516171819202122232425262728void queen_norecursive(int arr[])&#123; int depth = 1; while(depth &gt;= 1) &#123; //设置第depth个几点的值 arr[depth] += 1; //检查arr[depth]的合法性，如果不合法则自增 while(arr[depth] &lt;= QUEENS &amp;&amp; !check(arr, depth)) arr[depth] += 1; //找到有效解 if(arr[depth] &lt;= QUEENS &amp;&amp; depth == QUEENS) &#123; printf(\"solution %2d: \", k++); for(int i = 1; i &lt;= QUEENS; ++i) printf(\"%d \", arr[i]); printf(\"\\n\"); &#125; //继续下一层 else if(arr[depth] &lt;= QUEENS &amp;&amp; depth &lt; QUEENS) depth += 1; else //回溯 &#123; arr[depth] = 0; --depth; &#125; &#125;&#125; 光看代码还是，不太好理解，通过在关键位置增加log，N为4时相应输出如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137current depth:1 current arr: 1 0 0 0 //设置节点1的值为1，合法increase depth to: 2 //设置下一层current depth:2current arr: 1 1 0 0 //设置节点2的值为1，不合法，因为x[2]==x[1]current arr: 1 2 0 0 //设置节点2的值为2，不合法，因为x[2]-x[1] == 2-1current arr: 1 3 0 0 //设置节点2的值为3，合法increase depth to: 3 //设置下一层current depth:3current arr: 1 3 1 0 //设置节点3的值为1，不合法，因为x[3] == x[1]current arr: 1 3 2 0 //设置节点3的值为2，不合法，因为x[3]-x[2] == 1-2current arr: 1 3 3 0 //设置节点3的值为3，不合法，因为x[3] == x[2]current arr: 1 3 4 0 //设置节点3的值为4，不合法，因为x[3]-x[2] == 3-2current arr: 1 3 5 0 //设置节点3的值为5，不合法，因为x[3] &gt; 4了backtracking.. //回溯，设置节点3的值为0current depth:2 //回到设置上一层current arr: 1 4 0 0 //设置节点2的值为4（因为前次为3），合法increase depth to: 3 //设置下一层current depth:3current arr: 1 4 1 0 //设置节点3的值为1，不合法，因为x[3] == x[1]current arr: 1 4 2 0 //设置节点3的值为2，合法increase depth to: 4 //设置下一层current depth:4current arr: 1 4 2 1 //设置节点4的值为1，不合法，因为x[4] == x[1]current arr: 1 4 2 2 //设置节点4的值为2，不合法，因为x[3] == x[4]current arr: 1 4 2 3 //设置节点4的值为3，不合法，因为x[4]-x[3] == 4-3current arr: 1 4 2 4 //设置节点4的值为4，不合法，因为x[4] == x[2]current arr: 1 4 2 5 //设置节点4的值为5，不合法，因为x[4] &gt; 4了backtracking.. //回溯，设置节点4的值为0current depth:3 //回到设置上一层current arr: 1 4 3 0 //设置节点3的值为3，不合法，因为x[3]-x[2] == 2-3current arr: 1 4 4 0 //设置节点3的值为4，不合法，因为x[3] == x[2]current arr: 1 4 5 0 //设置节点3的值为5，不合法，因为x[3] &gt; 4了backtracking.. //回溯，设置节点3的值为0current depth:2 //回到设置上一层current arr: 1 5 0 0 //设置节点2的值为5，不合法，因为x[2] &gt; 4了backtracking.. //回溯，设置节点2的值为0current depth:1 //回到设置上一层current arr: 2 0 0 0 //设置节点1的值为2，合法increase depth to: 2 //设置下一层current depth:2current arr: 2 1 0 0 //设置节点2的值为1，不合法，因为x[2]-x[1] == 1-2current arr: 2 2 0 0 //设置节点2的值为2，不合法，因为x[2] == x[1]current arr: 2 3 0 0 //设置节点2的值为3，不合法，因为x[2]-x[1] == 2-1current arr: 2 4 0 0 //设置节点2的值为3，合法increase depth to: 3 //设置下一层current depth:3current arr: 2 4 1 0 //设置节点3的值为1，合法increase depth to: 4 //设置下一层current depth:4current arr: 2 4 1 1 //设置节点4的值为1，不合法，因为x[4] == x[3]current arr: 2 4 1 2 //设置节点4的值为2，不合法，因为x[4] == x[1]current arr: 2 4 1 3 //设置节点4的值为3，合法solution 1: 2 4 1 3 //此时depth == 4，满足条件，打印相应输出current depth:4current arr: 2 4 1 4 //下同，不再赘述current arr: 2 4 1 5backtracking..current depth:3current arr: 2 4 2 0current arr: 2 4 3 0current arr: 2 4 4 0current arr: 2 4 5 0backtracking..current depth:2current arr: 2 5 0 0backtracking..current depth:1current arr: 3 0 0 0increase depth to: 2current depth:2current arr: 3 1 0 0increase depth to: 3current depth:3current arr: 3 1 1 0current arr: 3 1 2 0current arr: 3 1 3 0current arr: 3 1 4 0increase depth to: 4current depth:4current arr: 3 1 4 1current arr: 3 1 4 2solution 2: 3 1 4 2current depth:4current arr: 3 1 4 3current arr: 3 1 4 4current arr: 3 1 4 5backtracking..current depth:3current arr: 3 1 5 0backtracking..current depth:2current arr: 3 2 0 0current arr: 3 3 0 0current arr: 3 4 0 0current arr: 3 5 0 0backtracking..current depth:1current arr: 4 0 0 0increase depth to: 2current depth:2current arr: 4 1 0 0increase depth to: 3current depth:3current arr: 4 1 1 0current arr: 4 1 2 0current arr: 4 1 3 0increase depth to: 4current depth:4current arr: 4 1 3 1current arr: 4 1 3 2current arr: 4 1 3 3current arr: 4 1 3 4current arr: 4 1 3 5backtracking..current depth:3current arr: 4 1 4 0current arr: 4 1 5 0backtracking..current depth:2current arr: 4 2 0 0increase depth to: 3current depth:3current arr: 4 2 1 0current arr: 4 2 2 0current arr: 4 2 3 0current arr: 4 2 4 0current arr: 4 2 5 0backtracking..current depth:2current arr: 4 3 0 0current arr: 4 4 0 0current arr: 4 5 0 0backtracking..current depth:1current arr: 5 0 0 0backtracking.. 问题二：公路收费点重建问题描述设给定N个点p1,p2,…,pN,他们位于x轴上。设xi是pi的x坐标，并且假设x1=0,并且这些点从左到右给出。则这N个点确定每一对点间的N(N-1)/2个形如|xi-xj|(i!=j)的距离d1,..,dN。公路收费点问题是从这些距离重建一个点集。 举个例子 比如x1=0,x2=3,x3=4,x4=6,则生成的d集合为{3, 4, 6, 1, 3, 2}，排序一下得到{1, 2, 3, 3, 4, 6} 现在要做的是从d的集合，反推出x的点集 书中有一个详细的反推的例子，已知D={1,2,2,2,3,3,3,4,5,5,5,6,7,8,10}，推理过程如下：由D的长度15可知，N为6 显然x1=0，x6=10，因为10是D中最大元素，从D中删除10 剩下的最大距离为8，则x2=2，或者x5=8。由对称性可知这两种选择等价，取后者，从D中删除2和8 剩下的最大距离为7，有两种可能 x4=7，则从D中删除1,3,7，剩余最大值为6,又有两种可能A. x3=6，这不可能，因为1已被删除，不在D中，而x4-x3=1B. x2=4，这不可能，因为会导致存在两个4,x2-x1=4,x5-x2=4 x2=3，由于上面的结果都不可能，所以只能取这种 此时D={1,2,2,3,3,4,5,5,6}，最大值为6，则又有两种可能 x3 = 4，这不可能，因为x3-x1=4,x5-x3=4，导致存在两个4 x4=6 剩下唯一解x3=5，代入验证得此时D为空集，答案有效 解答书中给出完整伪代码 公路收费点重建算法：驱动例程12345678910111213bool turnpike(vector&lt;int&gt; &amp;x, DistSet d, int n)&#123; x[1] = 0; d.deleteMax(x[n]); d.deleteMax(x[n - 1]); if(x[n] - x[n - 1] ∈ d) &#123; d.remove(x[n] - x[n - 1]); return place(x, d, n, 2, n - 2); &#125; else return false;&#125; 大致过程为 放置x[1], x[n], x[n - 1]，并在d中删除x[n]和x[n - 1] 判断x[n] - x[n - 1]是否在d中，如果在则从d中移除，并放置其他点 如果不在，则直接返回 公路收费点重建算法：回溯的步骤12345678910111213141516171819202122232425262728293031323334353637/** * Backtracking algorithm to place x[left]...x[right]. * x[1]..x[left-1] and x[right+1]...x[n] already tentatively placed. * If place return true, then x[left]...x[right] will have values. */bool place(vector&lt;int&gt; &amp;x, DistSet d, int n, int left, int right)&#123; int dmax; bool found = false; dmax = d.findMax(); //check if setting x[right] == dmax is feasible.. if(|x[j] - dmax| ∈ d for all 1&lt;=j&lt;left and right&lt;j&lt;=n) &#123; x[right] = dmax; //Try x[right] = dmax for(1&lt;=j&lt;left, right&lt;j&lt;=n) d.remove(| x[j] - dmax |); found = place(x, d, n, left, right - 1); if(!found) //Backtrack for(1&lt;=j&lt;left, right&lt;j&lt;=n) //Undo the deletion d.insert(| x[j] - dmax |); &#125; // If first attempt is failed, try to see if setting // x[left] = x[n] - dmax is feasible. if(!found &amp;&amp; (| x[n] -dmax - x[j] | ∈ d for all 1&lt;=j&lt;left and right&lt;j&lt;=n)) &#123; x[left] = x[n] - dmax; //Same logic as before for(1&lt;=j&lt;left, right&lt;j&lt;=n) d.remove(| x[n] - dmax - x[j] |); found = place(x, d, n, left+1, right); if(!found) //Backtrack for(1&lt;=j&lt;left, right&lt;j&lt;=n) //Undo the deletion d.insert(| x[n] - dmax - x[j] |); &#125; return found;&#125; 英文注释已经比较完整地说明了整个流程，有一点说明一下“x[right] = dmax”，表示设置右边的点为dmax，此时x[right]距x[1]距离为dmax“x[left] = x[n]-dmax”，设置左边点之后，x[left]距x[n]为dmax 根据书中伪代码实现一下，考虑使用std::multiset代替DistSet，因为multiset有两个特点 可以允许重复值，这是set不具备的 元素始终有序，便于找出最大值 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;stdio.h&gt;#include &lt;set&gt;#include &lt;vector&gt;typedef std::vector&lt;int&gt; Vec ;typedef std::multiset&lt;int&gt; MSet ;//删除d中最大值，并将其赋值给x中索引n对应的值void deleteMax(Vec &amp;x, MSet &amp;d, int n)&#123; auto maxItr = d.end(); --maxItr; x[n] = *maxItr; d.erase(maxItr);&#125;//删除d中键为val的元素，不直接使用erase的原因是：erase会将所有相同元素删除void removeVal(MSet &amp;d, int val, bool firstOnly = true)&#123; for(auto itr = d.begin(); itr != d.end();) &#123; if(val == *itr) &#123; itr = d.erase(itr); if(firstOnly) return; &#125; else ++itr; &#125;&#125;//检查若插入insertData，与其他所有已存在的点的距离，是否在d中bool check(const Vec &amp;x, MSet d, int n, int left, int right, int insertData)&#123; for(int i = 1; i &lt;= n; ++i) &#123; //跳过[left...right] if(i &gt;= left &amp;&amp; i &lt;= right) continue; int diff = abs(x[i] - insertData); if(d.find(diff) == d.end()) return false; else removeVal(d, diff); //这里把已经验证存在的项删除 //比如d中只有一个2，而差有两个2时，就是不合法的 &#125; return true;&#125;bool place(Vec &amp;x, MSet &amp;d, int n, int left, int right)&#123; if(d.empty()) return true; auto itr = d.end(); int dmax = *(--itr); bool found = false; //插入x[right] = dmax if(check(x, d, n, left, right, dmax)) &#123; x[right] = dmax; for(int i = 1; i &lt;= n; ++i) &#123; if(i &gt;= left &amp;&amp; i &lt;= right) continue; removeVal(d, abs(x[i] - dmax)); &#125; found = place(x, d, n, left, right - 1); if(!found) &#123; for(int i = 1; i &lt;= n; ++i) &#123; if(i &gt;= left &amp;&amp; i &lt;= right) continue; d.insert(abs(x[i] - dmax)); &#125; &#125; &#125; if(!found &amp;&amp; check(x, d, n, left, right, x[n] - dmax)) &#123; x[left] = x[n] - dmax; for(int i = 1; i &lt;= n; ++i) &#123; if(i &gt;= left &amp;&amp; i &lt;= right) continue; removeVal(d, abs(x[n] - dmax - x[i])); &#125; found = place(x, d, n, left + 1, right); if(!found) &#123; for(int i = 1; i &lt;= n; ++i) &#123; if(i &gt;= left &amp;&amp; i &lt;= right) continue; d.insert(abs(x[n] - dmax - x[i])); &#125; &#125; &#125; return found;&#125;bool turnpike(Vec &amp;x, MSet &amp;d, int n)&#123; x[1] = 0; deleteMax(x, d, n); deleteMax(x, d, n - 1); int diff = x[n] - x[n - 1]; if(d.find(diff) != d.end()) &#123; removeVal(d, diff); return place(x, d, n, 2, n - 2); &#125; return false;&#125;int main()&#123; Vec x(7); MSet d&#123;1, 2, 2, 2, 3, 3, 3, 4, 5, 5, 5, 6, 7, 8, 10&#125;; int n = 6; if(turnpike(x, d, n)) &#123; for(int i = 1; i &lt;= n; ++i) printf(\"%d \", x[i]); //0 3 4 6 8 10 &#125; else printf(\"can not find solution\\n\"); return 0;&#125; 感觉好啰嗦，应该可以化简","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"72法则","date":"2018-01-30T06:23:51.000Z","path":"2018/01/30/72法则/","text":"什么是72法则编程珠玑中无意看到了关于72法则的描述，兴趣突然来了 假设以年利率r%投资一笔钱y年，“72法则”指出，如果r×y=72，那么投资差不多会翻倍 验证下面我试了几种常见收益下的情况 r(收益率%) y(年数) 总收益率(%) 3 24 (1 + 0.03)24 ≈ 203.28 4 18 (1 + 0.04)18 ≈ 202.58 6 12 (1 + 0.06)12 ≈ 201.22 8 9 (1 + 0.08)9 ≈ 199.9 9 8 (1 + 0.09)8 ≈ 199.26 12 6 (1 + 0.12)6 ≈ 197.38 18 4 (1 + 0.18)4 ≈ 193.88 24 3 (1 + 0.24)3 ≈ 190.66 可以看出来，确实非常接近，特别是收益率在6%到12%之间的时候。 好神奇，做个图吧用matplotlib做一个关系图。其中x为年化收益率，在1到30变化 y为总收益率(1 + x/100)(72/x) 如下图所示 相应代码如下 123456789101112131415from matplotlib import pyplot as pltimport numpy as npRATIO = 72x = np.linspace(1, 30, 100)y = np.power(1 + x/100, RATIO / x) * 100plt.plot(x, y, color='red', linewidth=3)plt.xlabel('年化收益率(%)', fontproperties='SimHei', fontsize=10)plt.ylabel('总收益率(%)', fontproperties='SimHei', fontsize=10)plt.title('72/x年总收益率变化情况', fontproperties='SimHei', fontsize=10)plt.ylim(150, 250)plt.legend()plt.show() 复利的力量！！！","tags":[{"name":"金融","slug":"金融","permalink":"http://yoursite.com/tags/金融/"}]},{"title":"循环移位问题解析","date":"2018-01-27T06:23:51.000Z","path":"2018/01/27/循环移位问题解析/","text":"描述将一个n元1维向量左旋转（循环移位）i个 ，当n为6，i为3时，向量abcdefgh旋转为defghabc 各种解决方案2b做法-循环左移n次123456789101112void leftMove1(char *src, int i)&#123; int n = strlen(src); i %= n; for(int j = 0; j &lt; i; ++j) &#123; char t = src[0]; for(int k = 1; k &lt; n; ++k) src[k - 1] = src[k]; src[n - 1] = t; &#125;&#125; 自己实现的，书上没有。不多解释，显然缺点是效率低 普通做法-拷贝临时数组12345678910111213141516void leftMove2(char *src, int i)&#123; int n = strlen(src); i %= n; if(i &lt;= 0) return; char *temp = new char[i]; //先将前i个字符拷贝到临时数组 memcpy(temp, src, i); for(int j = 0; j &lt; n - i; ++j) src[j] = src[j + i]; char *p = src + n - i; //再将i个字符拷贝到原数组的后i位 memcpy(p, temp, i); delete []temp;&#125; 自己实现的，书上没有。也比较好理解，缺点是需要额外的空间。 文艺做法说明 拷贝x[0]到t 拷贝x[i]-&gt;x[0]，x[2i]-&gt;x[i]，…x[ki]-&gt;x[(k-1)i]…其中当ki超过数组长度时，与数组长度取模 本轮结束条件，当ki与数组长度取模后取到0时，改为取t值，然后结束 如果该过程没有移动全部元素，就从x[1]开始再次移动，直到所有的元素都已经移动 书中说这种做法像精巧的杂技动作。没有完全理解其精髓，但总体上感觉这么移动完之后每一个元素都左移了i个位置，这样整个移动就结束了 实现 我的实现方法 123456789101112131415161718192021222324252627282930void leftMove3(char *src, int i)&#123; int n = strlen(src); i %= n; if(i &lt;= 0) return; //移动次数 int times = 0; for(int j = 0; j &lt; i; ++j) &#123; char t = src[j]; int to = j, from = i + j; while(true) &#123; from %= n; to %= n; times++; if(from == j) &#123; src[to] = t; break; &#125; src[to] = src[from]; from += i; to += i; &#125; if(times &gt;= n) break; &#125;&#125; 标准答案将x[n]向左旋转rotdist个位置 12345678910111213for i = [0, gcd(rotdist, n)) /* move i-th values of block*/ t = x[i] j = i loop k = j + rotdist if k &gt;= n k -= n if k == i break x[j] = x[k] j = k x[j] = t rotdist和n的最大公约数是所需的置换次数（用近世代数术语来说，也就是旋转产生的置换群的陪集个数）太专业了 分析一下和标准答案的差距在哪1、循环次数应该取最大公约数，这个很难，不说肯定不知道2、标准答案里没有用模之类的，可能觉得效率差吧 用标准答案实现1234567891011121314151617181920212223242526272829303132int gcd(int a, int b)&#123; int t; while(b) &#123; t = a % b; a = b; b = t; &#125; return a;&#125;void leftMove3_standard(char *src, int rotdist)&#123; int n = strlen(src); for(int i = 0; i &lt; gcd(rotdist, n); ++i) &#123; char t = src[i]; int j = i; while(true) &#123; int k = j + rotdist; if(k &gt;= n) k -= n; if(k == i) break; src[j] = src[k]; j = k; &#125; src[j] = t; &#125;&#125; 牛b做法说明 旋转向量x其实就是交换向量AB-&gt;BA，其中A代表前i个元素 假设A比B短，则将B分为Bl和Br，其中Br和A一样长。 交换A和Br，即ABlBr-&gt;BrBlA，此时A的位置已经正确。 问题转化为交换B的两部分，递归解决。 若A比B长，则将A转化为AlAr，Al和B一样长同样的解决 实现 我的实现方法 1234567891011121314151617181920212223242526272829303132333435363738void swap(char &amp;a, char &amp;b)&#123; char t = a; a = b; b = t;&#125;void moveHelper(char *src, int begin, int mid, int end)&#123; int leftLen = mid - begin, rightLen = end - mid + 1; if(!leftLen || !rightLen) return; //正好对半分，则直接交换即可(完全可以合并到下面的任何一个分支里，放着只为清晰) if(leftLen == rightLen) &#123; for(int i = 0; i &lt; leftLen; ++i) swap(src[begin + i], src[begin + leftLen + i]); &#125; else if(leftLen &lt; rightLen)//右边长，右边分为BlBr &#123; for(int i = 0; i &lt; leftLen; ++i) swap(src[begin + i], src[end - leftLen + 1 + i]); moveHelper(src, begin, mid, end - leftLen); &#125; else if(leftLen &gt; rightLen)//左边长，左边分为AlAr &#123; for(int i = 0; i &lt; rightLen; ++i) swap(src[begin + i], src[mid + i]); moveHelper(src, begin + rightLen, mid, end); &#125;&#125;void leftMove4(char *src, int i)&#123; int n = strlen(src); moveHelper(src, 0, i, n - 1);&#125; 标准答案伪代码如下 123456789101112131415161718if rotdist == 0 || rotdist == n returni = p = rotdistj = n - pwhile i != j /* invariant x[0..p-i] in final position x[p-i..p-1]=a (to be swapped with b) x[p..p+j-1]=b (to be swapped with a) x[p+j..n-1] in final position */ if i &gt; j swap(p-i, p, j) i -= j else swap(p-i, p+j-i, i) j -= i swap(p-i, p, i) 有点难，还没有完全理解，实现一下123456789101112131415161718192021222324252627282930void swap(char *src, int a, int b, int m)&#123; if(a == b) return; for(int i = 0; i &lt; m; ++i) swap(src[a + i], src[b + i]);&#125;void leftMove4_standard(char *src, int rotdist)&#123; int n = strlen(src); if(rotdist == 0 || rotdist == n) return; int i = rotdist, p = rotdist; int j = n - p; while(i != j) &#123; if(i &gt; j) &#123; swap(src, p - i, p, j); i -= j; &#125; else &#123; swap(src, p - i, p + j - i, i); j -= i; &#125; &#125; swap(src, p - i, p, i);&#125; 终极吊炸天做法说明下面用Ar表示A的逆，对于数组AB 对A求逆得到ArB 再对B求逆得到ArBr 再整体求逆得到(ArBr)r 而向量(ArBr)r即为BA。 数组abcdefgh，i为3，n为8123reverse(0, i - 1) /*cbadefgh*/reverse(i, n - 1) /*cbahgfed*/reverse(0. n - 1) /*defghabc*/ 实现12345678910111213void reverse(char *src, int begin, int end)&#123; while(begin &lt; end) swap(src[begin++], src[end--]);&#125;void leftMove5(char *src, int i)&#123; int n = strlen(src); reverse(src, 0, i - 1); reverse(src, i, n - 1); reverse(src, 0, n - 1);&#125; 极其简单，不易出错。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"编程珠玑学习笔记","date":"2018-01-25T12:23:51.000Z","path":"2018/01/25/编程珠玑学习笔记/","text":"第一章开篇题目描述包含n个都小于n且相异的整数，要求排序后输出到另一个文件 解答123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;fstream&gt;#define BYTESPERWORD 32#define SHIFT 5#define MASK 0x1F#define N 10000000int array[1 + N / BYTESPERWORD];//精华为下面这三个函数void set(int i) &#123; array[i &gt;&gt; SHIFT] |= (1 &lt;&lt; (i &amp; MASK)); &#125;void clr(int i) &#123; array[i &gt;&gt; SHIFT] &amp;= ~(1 &lt;&lt; (i &amp; MASK)); &#125;//这里和原书中做了一点小改动，int-&gt;bool，应该没啥影响bool test(int i) &#123; return array[i &gt;&gt; SHIFT] &amp; (1 &lt;&lt; (i &amp; MASK)); &#125;//我的理解：//1、array长度为什么是[1+N/32]//每个int有32个位，每个位为1表示该位置对应的数存在。则每个int可以表示32个数是否存在。//额外加1是因为，比如表示33个数则需要2个int值//2、i &gt;&gt; SHIFT什么意思//相当于i/(2e5)即i/32，表示数字i对应的比特位，在数组中的第i/32个数中。//比如数31对应的比特位在第一个数的最后一个比特位上；数32对应的比特位在第二个数的第一个比特位上//3、(1 &lt;&lt; (i &amp; MASK))什么意思//其中(i &amp; MASK)即i%32，所以原表达式表示32个位中第(i%32)个位为1，其他位全为0//比如数31得到的值为10000000000000000000000000000000//数32得到的值为00000000000000000000000000000001void setDataFromFile(const char *fname)&#123; std::ifstream infile(fname); if(!infile) return; int data; while(!infile.eof()) &#123; infile &gt;&gt; data; set(data); &#125; infile.close();&#125;void saveDataToFile(const char *fname)&#123; std::ofstream outfile(fname); if(outfile.is_open()) &#123; for(int i = 0; i &lt; N; ++i) &#123; if(test(i)) outfile &lt;&lt; i &lt;&lt; std::endl; &#125; outfile.close(); &#125;&#125;int main()&#123; for(int i = 0; i &lt; N; ++i) clr(i); setDataFromFile(\"in.txt\"); saveDataToFile(\"out.txt\"); return 0;&#125; 生成0到n之间k个不同的随机顺序的随机整数难点在“不同”二字，伪代码如下12345for i = [0,n) x[i] = ifor i = [0,k) swap(i, randint(i, n-1)) print x[i] 注意到每次随机index的下界i都在递增，保证了不会出现重复的数。精妙 第二章问题1描述给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数（在文件中至少缺少一个这样的数为什么） 解题思路 首先为什么至少缺少这样一个数 因为2的32次方比40亿略大，即整数的每一位0、1互换，能表示40亿多个整数。 所以肯定至少缺少一个这样的数哦。 读入40亿个整数，起始位为0的写入文件A，为1的写入文件B A,B中有一个文件最多包含20亿个整数，选择这个文件继续 依次类推，总的运行时间正比于n 问题2参考循环移位问题解析 问题3描述给定一个英语词典，找出其中所有的变位词集合。例如“pots”，“stop”，“tops”互为变位词。因为每一个单词都可以通过改变其他单词中字母的顺序来得到 解题思路123456pans anps pans anps panspots opst pots anps snap pans snapopt -&gt;[sign] -&gt; opt opt -&gt; sort -&gt; opt opt -&gt; optsnap anps snap opst pots pots stop topsstop opst stop opst stoptops opst tops opst tops 输入文件经过sign标识文件后，每一行增加一个sign标识 其中sign程序如下12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;//原书：//int charcomp(char *x, char *y)//&#123; return *x - *y;&#125;//使用cl.exe直接编译时有error，这里简单修改了一下int charcomp(const void *x, const void *y)&#123; return *(const char *)x - *(const char *)y; &#125;#define WORDMAX 100int main()&#123; char word[WORDMAX], sig[WORDMAX]; while(scanf(\"%s\", word) != EOF) &#123; strcpy(sig, word); qsort(sig, strlen(sig), sizeof(char), charcomp); printf(\"%s %s\\n\", sig, word); &#125; return 0;&#125; 系统sort程序对sign标识进行排序，从而得到有序的输出 sort程序为系统程序 squash程序根据标识的异同将相应的单词输出 程序实现如下123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string&gt;#define WORDMAX 100int main()&#123; char word[WORDMAX], sig[WORDMAX], oldsig[WORDMAX]; strcpy(oldsig, \"\"); int linenum = 0; while(scanf(\"%s %s\", sig, word) != EOF) &#123; if(strcmp(oldsig, sig) != 0 &amp;&amp; linenum &gt; 0) printf(\"\\n\"); strcpy(oldsig, sig); linenum++; printf(\"%s \", word); &#125; printf(\"\\n\"); return 0;&#125; 命令行执行命令1sign &lt;dictonary | sort | squash&gt; gramlist 其中dictionary文件可以从这找words.txt 几点感想 原来scanf还能这么玩，从文件得到输出 原来系统还有sort这样的程序可以调用。如果没有的话感觉还是比较难将文件内容排序的。 原来一个程序的printf可以作为另一个程序的scanf。 才疏学浅啊。 第三章数据决定程序结构 k阶常系数方程计算描述an = c1an-1 + c2an-2 + … + ckan-k + ck+1其中c为常数，编写程序，输入为k，a1,…ak,c1,…ck+1和n，输出a1至am 实现书中没有实现，想了递归和非递归两种方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define K 15#define N 20int arrayA[N + 1];int arrayC[K + 2];int A_recursive(int n)&#123; if(n &lt;= K) return arrayA[n]; int sum = 0; for(int i = 1; i &lt;= K; ++i) sum += arrayC[i] * A_recursive(n - i); sum += arrayC[K + 1]; return sum;&#125;//这里其实可以优化，因为算a[16]时已经计算//而算a[18]时又把a[16]计算了一把int A_normal(int n)&#123; if(n &gt; K) &#123; for(int i = K + 1; i &lt;= n; ++i) &#123; int temp = 0; for(int j = 1; j &lt;= K; ++j) temp += arrayC[j] * arrayA[i - j]; arrayA[i] = temp + arrayC[K + 1]; &#125; &#125; return arrayA[n];&#125;int main()&#123; for(int i = 1; i &lt;= K; ++i) arrayA[i] = i + 1; for(int i = 1; i &lt;= K + 1; ++i) arrayC[i] = K + 1 - i; printf(\"%d\\n\", A_recursive(16)); printf(\"%d\\n\", A_normal(16)); printf(\"%d\\n\", A_recursive(18)); printf(\"%d\\n\", A_normal(18)); return 0;&#125; 第四章二分搜索的讨论实现实现了一把，考虑了泛型，可以同时比较整形，浮点，字符串等。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;template &lt;typename T&gt;int binarySearch(T array[], int size, T data, int(*cmp)(T, T))&#123; int begin = 0, end = size - 1; while(begin &lt;= end) &#123; int mid = (begin + end) / 2; int result = cmp(array[mid], data); if(result == 0) return mid; else if(result &lt; 0) begin = mid + 1; else end = mid - 1; &#125; return -1;&#125;int intCompare(int a, int b)&#123; return a - b;&#125;#define PRECISION 1e-9int doubleCompare(double a, double b)&#123; if(((a - b) &gt; -PRECISION) &amp;&amp; ((a - b) &lt; PRECISION)) return 0; else if(a &gt; b) return 1; else return -1;&#125;int strCompare(char *a, char *b)&#123; while(*a &amp;&amp; *b &amp;&amp; *a == *b) &#123; ++a; ++b; &#125; return *a - *b;&#125;int main()&#123; int intArray[] = &#123;1, 3, 5, 9, 10, 30&#125;; int result = binarySearch(intArray, sizeof(intArray)/sizeof(int), 4, intCompare); printf(\"int result :%d\\n\", result); char *strArray[] = &#123;\"I\", \"Love\", \"Money\"&#125;; result = binarySearch&lt;char *&gt;(strArray, sizeof(strArray)/sizeof(char*), \"Love1\", strCompare); printf(\"str result :%d\\n\", result); double doubleArray[] = &#123;3.14, 4.12, 6.00, 7.15&#125;; result = binarySearch(doubleArray, sizeof(doubleArray)/sizeof(float), 6.0, doubleCompare); printf(\"float result :%d\\n\", result); return 0;&#125; 与chromium源码比较在chromium源码中以binarysearch为关键字搜索到了几处 javascript/chromium/chrome/common/extensions/docs/examples/api/downloads/download_manager/popup.js 123456789101112131415function binarySearch(array, target, cmp) &#123; var low = 0, high = array.length - 1, i, comparison; while (low &lt;= high) &#123; i = (low + high) &gt;&gt; 1; comparison = cmp(target, array[i]); if (comparison &lt; 0) &#123; low = i + 1; &#125; else if (comparison &gt; 0) &#123; high = i - 1; &#125; else &#123; return i; &#125; &#125; return i; //这里为什么要返回i，没搞懂&#125;; JAVA/chromium/third_party/protobuf/javanano/src/main/java/com/google/protobuf/nano/FieldArray.java 12345678910111213141516private int binarySearch(int value) &#123; int lo = 0; int hi = mSize - 1; while (lo &lt;= hi) &#123; int mid = (lo + hi) &gt;&gt;&gt; 1; int midVal = mFieldNumbers[mid]; if (midVal &lt; value) &#123; lo = mid + 1; &#125; else if (midVal &gt; value) &#123; hi = mid - 1; &#125; else &#123; return mid; // value found &#125; &#125; return ~lo; // value not present&#125; C++/chromium/third_party/harfbuzz-ng/src/hb-open-type-private.hh 12345678910111213141516171819template &lt;typename SearchType&gt;inline int bsearch (const SearchType &amp;x) const&#123;/* Hand-coded bsearch here since this is in the hot inner loop. */const Type *array = this-&gt;array;int min = 0, max = (int) this-&gt;len - 1;while (min &lt;= max)&#123; int mid = (min + max) / 2; int c = array[mid].cmp (x); if (c &lt; 0) max = mid - 1; else if (c &gt; 0) min = mid + 1; else return mid;&#125;return -1;&#125; 可以看到js和C++也是使用了泛型编程。一点感想 前两者都是使用右移而没有使用除法，这个以后要注意。 第八章最大子序列求解问题描述比如序列{31, -41, 59, 26, -53, 58, 97, -93, -23, 84} 最大子序列和为x[2…6]，即187 解答在《数据结构与算法分析》2.4节也有相应描述，解答如下 12345678910111213int maxSubSum(const std::vector&lt;int&gt; &amp;a)&#123; int maxSum = 0, thisSum = 0; for(int j = 0; j &lt; a.size(); ++j) &#123; thisSum += a[j]; if(thisSum &gt; maxSum) maxSum = thisSum; else if(thisSum &lt; 0) thisSum = 0; &#125; return maxSum;&#125; 伪代码本书中给出的伪代码123456maxsofar = 0maxendinghere = 0for i = [0, n) /*invariant: maxending and maxsofar are accurate for x[0..i-1]*/ maxendinghere = max(maxendinghere + x[i], 0) maxsofar = max(maxsofar, maxendinghere) 可以看出，说的是一个意思 发散一下如果需要求出最大序列具体的起止索引呢。参考上面的做法，稍微修改了一下 1234567891011121314151617181920212223int maxSubSum(const std::vector&lt;int&gt; &amp;a)&#123; int maxSum = 0, thisSum = 0; int from = 0, to = 0; for(int j = 0; j &lt; a.size(); ++j) &#123; thisSum += a[j]; if(thisSum &gt; maxSum) &#123; maxSum = thisSum; //最大序列变化了，终止节点也相应变化 to = j; &#125; else if(thisSum &lt; 0) &#123; //这里from从下一个节点开始算 from = j + 1; thisSum = 0; &#125; &#125; printf(\"from :%d, to:%d\\n\", from, to); return maxSum;&#125; 习题5如何处理cumarr[-1]123float realarr[] = &#123;1.0, 3.0, 2.0&#125;;float *cumarr = realarr + 1;printf(\"%f\\n\", cumarr[-1]); //1.0 习题9说明原题中将负数组的最大子序列和定义为0，即空序列，现在将其定义为数组中的最大值。 比如数组为[-3, -2, -1, -9]，按照上面的做法，得出的maxSum为0.现在要求值为-1。 实现只需要将maxSum的初始值设为array[0]即可 为什么呢？ 我这么理解，对于一个全负数组，每次循环都会走到[thisSum=0]，所以每次thisSum就 代表了arr[i]的值，这样原函数就退化为了求数组最大值的函数咯 习题10说明原题修改为查找总和最接近实数t的向量 实现以t为0为例，即查找总和最接近0的向量 初始化累加数组cum，使得cum[i] = x[0] + … + x[i] 拷贝cum数组到临时数组cumtemp，并排序数组cumtemp 查找最接近的两项，这里书上没说怎么做，我想的做法是– 建立临时数组arr，– 从下标1开始，arr[i] = cumtemp[i] - cumtemp[i - 1]，注意到cum是已排序过的，所以arr每个值都不小于0– 查找arr中的最小值对应的index– 则cumtemp[index - 1]和cumtemp[index]是最接近的两项 根据最接近两项的值，再原cum数组中查找具体的leftIndex和rightIndex 则[leftIndex + 1, rightIndex]即为和最接近0的向量 感觉太啰嗦了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;void swap(int &amp;a, int &amp;b)&#123; int t = a; a = b; b = t;&#125;void qsort(int *array, int begin, int end)&#123; if(begin &gt;= end) return; int i = begin, j = end; swap(array[begin], array[(begin + end) / 2]); int curData = array[begin]; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; array[j] &gt;= curData) --j; while(i &lt; j &amp;&amp; array[i] &lt;= curData) ++i; if(i &lt; j) swap(array[i], array[j]); &#125; swap(array[i], array[begin]); qsort(array, begin, i - 1); qsort(array, i + 1, end);&#125;void findMinIndex(int *cumarr, int size, int t, int &amp;left, int &amp;right)&#123; int *subarr = new int[size]; for(int i = 1; i &lt; size; ++i) subarr[i] = abs(cumarr[i] - cumarr[i - 1] - t); int minIndex = 1, minVal = subarr[1]; for(int i = 2; i &lt; size; ++i) &#123; if(subarr[i] &lt; minVal) &#123; minIndex = i; minVal = subarr[i]; &#125; &#125; left = cumarr[minIndex - 1]; right = cumarr[minIndex]; delete []subarr;&#125;int findIndex(int *arr, int size, int data, bool reverse = false)&#123; if(reverse) &#123; for(int i = size - 1; i &gt;= 0; --i) if(data == arr[i]) return i; &#125; else &#123; for(int i = 0; i &lt; size; ++i) if(data == arr[i]) return i; &#125; return -1;&#125;void findMostNear(int *array, int size, int t)&#123; if(size &lt;= 1) return; int *cumarr = new int[size], *cumtemp = new int[size]; cumarr[0] = cumtemp[0] = array[0]; for(int i = 1; i &lt; size; ++i) cumarr[i] = cumtemp[i] = cumarr[i - 1] + array[i]; qsort(cumtemp, 0, size - 1); int leftVal, rightVal; findMinIndex(cumtemp, size, t, leftVal, rightVal); int leftIndex = findIndex(cumarr, size, leftVal, false), rightIndex = findIndex(cumarr, size, rightVal, true); delete []cumarr; delete []cumtemp; printf(\"left:%d\\n\", leftIndex); //5 printf(\"right:%d\\n\", rightIndex); //7&#125;int main()&#123; int array[] = &#123;31, -41, 59, 26, -53, 58, 97, -93, -23, 84&#125;; int size = sizeof(array) / sizeof(int); findMostNear(array, size, 4);&#125; 第九章顺序搜索在未排序的数组中搜索数值t的索引 书中给出了设置哨兵的算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;chrono&gt;#include &lt;string&gt;#define N 10000int find_normal(int arr[], int t)&#123; for(int i = 0; i &lt; N; ++i) &#123; if(arr[i] == t) return i; &#125; return -1;&#125;int find_with_guard(int arr[], int t)&#123; //设置哨兵 arr[N] = t; int i; for(i = 0;; ++i) if(arr[i] == t) break; if(i == N) return -1; return i;&#125;int main()&#123; //这里留一个位置给哨兵 int arr[N + 1]; for(int i = 0; i &lt; N; ++i) arr[i] = i; int index; auto start = std::chrono::system_clock::now(); index = find_normal(arr, N / 2); auto end = std::chrono::system_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"find normal, result:%d elapse time :%d microseconds\\n\", index, duration.count()); start = std::chrono::system_clock::now(); index = find_with_guard(arr, N / 2); end = std::chrono::system_clock::now(); duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"find with guard, result:%d elapse time :%d microseconds\\n\", index, duration.count()); return 0;&#125; 但是很奇怪，我本地，使用哨兵时算法并没有变快，尝试过t为10、N/2、N-1，下面是t为N/2的输出12find normal, result:5000 elapse time :19 microsecondsfind with guard, result:5000 elapse time :18 microseconds 不知道原因 变形二分搜索：查找数字t在数组中第一次出现的位置注意到标准的二分搜索，可能返回任意一个数字t的索引，不一定是第一个 解决方法 我最初始的想法 还是利用标准的二分搜索，但是搜索到索引之后，一直前递减，直到找到第一个和t 相等的索引。因为数组是排序的，所以理论上应该没问题。可能效率较差。 123456789101112131415161718int findfirst(int arr[], int x, int size)&#123; int l = 0, u = size - 1; while(l &lt;= u) &#123; int m = (l + u) &gt;&gt; 1; if(arr[m] == x) &#123; while(arr[--m] == x); return ++m; &#125; else if(arr[m] &gt; x) u = m - 1; else l = m + 1; &#125; return -1;&#125; 标准答案1伪代码123456789101112l = -1; u = nwhile l + 1 != u /*invariant: x[l] &lt; t &amp;&amp; x[u] &gt;= t &amp;&amp; l &lt; u*/ m = (l + u) / 2 if x[m] &lt; t l = m else u = m/* assert l + 1 = u &amp;&amp; x[l] &lt; t &amp;&amp; x[u] &gt;= t*/p = uif p &gt;= n || x[p] != t p = -1 理解一下标答 初始l和u为数组边界外的两个值 循环直到l比u小1– l和u的中间值比t小，则下界设为中间值– 否则（不小于t），则上界设为中间值 如此循环结束后，得到条件l + 1 = u，且x[l] &lt; t，且x[u] &gt;= t。则存在几种情况– 1、上限u超过返回不合法，即u = n, l = n - 1;此时未找到，返回-1– 2、上限u合法，则x[u] &gt;= t,若x[u]&gt;t则也未找到，返回-1；若x[u] = t,则有x[l]&lt; t，可得u是第一个等于t的位置 实现12345678910111213141516int findfirst_standard1(int arr[], int t, int size)&#123; int l = -1, u = size; while(l + 1 != u) &#123; int m = (l + u) &gt;&gt; 1; if(arr[m] &lt; t) l = m; else u = m; &#125; int p = u; if(p &gt;= size || arr[p] != t) p = -1; return p;&#125; 标准答案2伪代码12345678910111213141516i = 512l = -1if x[511] &lt; t l = 1000 - 512while i != 1 /* invariant: x[l] &lt; t &amp;&amp; x[l + i] &gt;= t &amp;&amp; i = 2^j*/ nexti = i / 2 if x[l + nexti] &lt; t l = l + nexti i = nexti else i = nexti/* assert i == 1 &amp;&amp; x[l] &lt; t &amp;&amp; x[l + i] &gt;= t*/p = l + 1if p &gt; 1000 || x[p] != t p = -1 需要利用到n = 1000的已知条件。不使用l..u来表示区间的上下限，而是使用 下限l，增量i来表示，其中l + i = u，并且i总是为2的幂 注意到一开始i为512（因为1024已经大于1000了），所以最开始的区间要么 为-1..511，要么为488..1000 该方案一般比较慢，只是作为引子 标准答案3对上面程序进行优化，删除遍历nexti 伪代码12345678910111213i = 512l = -1if x[511] &lt; t l = 1000 - 512while i != 1 /* invariant: x[l] &lt; t &amp;&amp; x[l + i] &gt;= t &amp;&amp; i = 2^j*/ i = i / 2 if x[l + i] &lt; t l += i/* assert i == 1 &amp;&amp; x[l] &lt; t &amp;&amp; x[l + i] &gt;= t*/p = l + 1if p &gt; 1000 || x[p] != t p = -1 实现123456789101112131415161718#define N 1000int findfirst_standard2(int arr[], int t)&#123; int i = 512; int l = -1; if(arr[i - 1] &lt; t) l = N - i; while(i != 1) &#123; i = i &gt;&gt; 1; if(arr[l + i] &lt; t) l += i; &#125; int p = l + 1; if(p &gt;= N || arr[p] != t) p = -1; return p;&#125; 注意倒数第三行我这里写成[ p &gt;= N ]而不是[ p &gt; N ]，理由如下： 比如原arr为0..999，而待查找值为1000，此时进过循环结束之后，l的值为488+256+..+2+1=999 所以p的值为1000，此时已经为非法越界所以，再去取arr[p]比较危险 不知道原书中的大于号是什么意思 标准答案4继续将while循环和除法优化掉，因为在N为1000的情况下，需要循环几次是已知的 伪代码12345678910111213l = -1if(x[511] &lt; t) l = 1000 - 512 /* assert x[l] &lt; t &amp;&amp; x[l + 512] &gt;= t*/if(x[l + 256] &lt; t) l += 235 /* assert x[l] &lt; t &amp;&amp; x[l + 256] &gt;= t*/if(x[l + 128] &lt; t) l += 128...if(x[l + 2] &lt; t) l += 2if(x[l + 1] &lt; t) l += 1 /* assert x[l] &lt; t &amp;&amp; x[l + 1] &gt;= t*/p = l + 1if p &gt; 1000 || x[p] != t p = -1 没有什么好说的，牺牲了简洁性而为了调优吧 宏和函数求最值性能比较123456789101112131415161718192021222324252627282930313233343536373839float max(float a, float b)&#123; return a &gt; b ? a : b;&#125;//返回数组0..n-1中的最大值，其中n最大为sizefloat arrmax(float arr[], int size, int n)&#123; if(n == 1) return -1; return max(arr[n - 1], arrmax(arr, size, n - 1));&#125;#define max_macro(a, b) ((a) &gt; (b) ? (a) : (b))float arrmax_macro(float arr[], int size, int n)&#123; if(n == 1) return -1; return max_macro(arr[n - 1], arrmax_macro(arr, size, n - 1));&#125;int main()&#123; const int size = 28; float arr[size]; for(int i = 0; i &lt; size; ++i) arr[i] = (size - i) * 1.0; auto start = std::chrono::system_clock::now(); printf(\"max:%f\\n\", arrmax(arr, size, 28)); auto end = std::chrono::system_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"func max elapse time :%d microseconds\\n\", duration.count()); start = std::chrono::system_clock::now(); printf(\"max:%f\\n\", arrmax_macro(arr, size, 28)); end = std::chrono::system_clock::now(); duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"macro max elapse time :%d microseconds\\n\", duration.count()); return 0;&#125; 输出1234max:27.000000func max elapse time :138 microsecondsmax:27.000000macro max elapse time :1341535 microseconds 真是说明宏在某些情况下性能不好的极致例子了。 书中说“一组按降序排列的值可以使算法的时间开销约为2n”。 这个没理解 习题7-求解数的二进制中1的个数参考求解整数二进制数中1的个数 习题8-查找数组元素的最大值分别使用普通方法，和哨兵方法比较了一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#define N 10000int findMax_normal(int arr[])&#123; printf(\"%d\\n\", N); int max = arr[0], maxIndex = 0; for(int i = 1; i &lt; N; ++i) &#123; if(arr[i] &gt; max) &#123; maxIndex = i; max = arr[i]; &#125; &#125; return max;&#125;int findMax_guard(int arr[])&#123; int index = 0; int max; while(index &lt; N) &#123; max = arr[index]; arr[N] = max; index++; while(arr[index] &lt; max) index++; &#125; return arr[N];&#125;int main()&#123; int arr[N + 1]; for(int i = 0; i &lt; N / 2; ++i) arr[i] = i; for(int i = N / 2; i &lt; N; ++i) arr[i] = N - i; int max; auto start = std::chrono::system_clock::now(); max = findMax_normal(arr); auto end = std::chrono::system_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"findMax normal, result:%d elapse time :%ld microseconds\\n\", max, duration.count()); start = std::chrono::system_clock::now(); max = findMax_guard(arr); end = std::chrono::system_clock::now(); duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"findMax guard, result:%d elapse time :%ld microseconds\\n\", max, duration.count()); return 0;&#125; 输出如下12findMax normal, result:5000 elapse time :171 microsecondsfindMax guard, result:5000 elapse time :40 microseconds 可以看出使用哨兵方法，优化的还是比较大的 习题12有时会从数学的角度，而不是代码的角度考虑优化，比如为了计算下面多项式 y = anxn + an-1xn-1 + ..+a1x1 + a0123456789101112131415161718192021222324252627282930313233343536373839404142434445#define N 25long y_bad(int a[], int x)&#123; long y = a[0]; int xi = 1; for(int i = 1; i &lt;= N; ++i) &#123; xi *= x; y += a[i]*xi; &#125; return y;&#125;long y_good(int a[], int x)&#123; long y = a[N]; for(int i = N - 1; i &gt;= 0; --i) &#123; y = y * x + a[i]; &#125; return y;&#125;int main()&#123; int a[N + 1]; for(int i = 0; i &lt;= N; ++i) a[i] = i; long y; auto start = std::chrono::system_clock::now(); y = y_bad(a, 2); auto end = std::chrono::system_clock::now(); auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"y_bad, result:%ld elapse time :%ld microseconds\\n\", y, duration.count()); start = std::chrono::system_clock::now(); y = y_good(a, 2); end = std::chrono::system_clock::now(); duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start); printf(\"y_good, result:%ld elapse time :%ld microseconds\\n\", y, duration.count()); return 0;&#125; 很遗憾，实际两者都很快，输出12y_bad, result:1610612738 elapse time :0 microsecondsy_good, result:1610612738 elapse time :0 microseconds 第10章10.2示例问题描述在地理数据库中存储2000个邻居，编号0..1999，输入x,y（范围都是0..199） 需要确定用户选中了2000个点中的哪个。 书中介绍三种实现 直接二维数组 列数组加链表的稀疏矩阵 列数组加并行数组的稀疏矩阵 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#define N 200//以下func(x, y)表示取第x列，y行数据//方法一：直接存储成二维数组，优点是简单，缺点是对于稀疏矩阵，存在巨大空间浪费void storeAsNormalArray(int x, int y)&#123; assert(x &lt; N &amp;&amp; y &lt; N); int array[N][N] = &#123;-1&#125;; //input array[0][2] = 17; array[0][5] = 538; array[3][4] = 965; array[5][3] = 1171; array[7][1] = 162; //output printf(\"%d\\n\", array[x][y]);&#125;//方法二：利用链表//使用数组表示所有的列，并使用链表来表示给定列中的活跃元素//表面上记录数据的节点少了，但实际上由于节点指针，malloc/new的消耗，可能导致空间增大struct Node&#123; int data_; unsigned char row_; Node *next_; Node(unsigned char row, int d = 0) : row_(row), data_(d), next_(nullptr) &#123;&#125;&#125;;void addData(Node *&amp;colhead, unsigned char row, int data)&#123; if(colhead == nullptr) colhead = new Node(0, 0); Node *p = colhead; while(p-&gt;next_) p = p-&gt;next_; p-&gt;next_ = new Node(row, data);&#125;void storeWithList(int x, int y)&#123; assert(x &lt; N &amp;&amp; y &lt; N); Node *colhead[N] = &#123;nullptr&#125;; //input addData(colhead[0], 2, 17); addData(colhead[0], 5, 538); addData(colhead[3], 4, 965); addData(colhead[5], 3, 1171); addData(colhead[7], 1, 62); //output for(Node *p = colhead[x]; p != nullptr; p = p-&gt;next_) &#123; if(p-&gt;row_ == y) &#123; printf(\"%d\\n\", p-&gt;data_); break; &#125; &#125; //release for(int i = 0; i &lt; N; ++i) &#123; Node *head = colhead[i]; if(head == nullptr) continue; Node *p = head, *q; while(p) &#123; q = p-&gt;next_; delete p; p = q; &#125; &#125;&#125;//方法三：不使用指针和结构//使用201元的数组来表示列，并用2000元的并行数组表示这些点#define NUMSIZE 2000void addData(int firstincol[], unsigned char row[], int pointnum[], int x, int y, int data)&#123; int curcol = firstincol[x + 1]; row[curcol] = y; pointnum[curcol] = data; for(int i = x + 1; i &lt;= N; ++i) firstincol[i] += 1;&#125;void storeWithColArray(int x, int y)&#123; int firstincol[N + 1] = &#123;0&#125;; int pointnum[NUMSIZE]; unsigned char row[NUMSIZE]; //input addData(firstincol, row, pointnum, 0, 2, 17); addData(firstincol, row, pointnum, 0, 5, 17); addData(firstincol, row, pointnum, 3, 4, 965); addData(firstincol, row, pointnum, 5, 3, 1171); addData(firstincol, row, pointnum, 7, 1, 162); //output //第i列的点由数组row和pointnum中位于firstincol[i]和firstincol[i+1]-1 //之间的元素表示 for(int k = firstincol[x]; k &lt; firstincol[x + 1]; ++k) &#123; if(row[k] == y) &#123; printf(\"%d\\n\", pointnum[k]); break; &#125; &#125;&#125;int main()&#123; storeAsNormalArray(5, 3); storeWithList(5, 3); storeWithColArray(5, 3); return 0;&#125; 两个对称矩阵的压缩描述Brian Kernighan编写了一个旅行商程序，给出如下共享存储空间方法。 有150×150的矩阵（分别为a,b），都是用来表示点与点之间的距离，从而知道他们有如下特点 对角线为0值，即a[i, i] = 0 矩阵是对称的，即a[i, j] = a[j, i] 使用如下方阵c来共享 123450 b[0, 1] b[0, 2]a[0, 1] 0 b[1, 2]a[2, 0] a[2, 1] 0 举例如下123 0 1 3 0 4 5 0 4 5a: 1 0 2 b: 4 0 6 c: 1 0 6 3 2 0 5 6 0 3 2 0 则可得 a[i, j] = c[max(i, j), min(i, j)]b[i, j] = c[min(i, j), max(i, j)] 比如 a[1, 2] = c[2, 1] , b[1, 2] = c[1, 2] 第11章-排序对比之前的文章:常见排序算法C++实现 插入排序呵，将打牌时排列手中的牌类比成插入排序，有意思 伪代码 12345for i = [1, n) t = x[i] for (j = i; j &gt; 0 &amp;&amp; x[j - 1] &gt; t; j--) x[j] = x[j - 1] x[j] = t 实现 1234567891011void insertSort(int arr[], int size)&#123; for(int i = 1; i &lt; size; ++i) &#123; int curdata = arr[i]; int j; for(j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; curdata; --j) arr[j] = arr[j - 1]; arr[j] = curdata; &#125;&#125; 快速排序 简单的 伪代码12345678910111213void qsort1(l, u) if(l &gt;= u) return m = l for i = [l + 1, u] /* invariant: x[l+1..m] &lt; x[l] &amp;&amp; x[m+1..i-1] &gt;= x[l]*/ if(x[i] &lt; x[l]) swap(++m, i) swap(l, m) /* x[l..m-1] &lt; x[m] &lt;= x[m+1..u]*/ qsort(l, m - 1) qsort(m + 1, u) 实现123456789101112void qsort1(int arr[], int l, int u)&#123; if(l &gt;= u) return; int m = l; for(int i = l + 1; i &lt;= u; ++i) if(arr[i] &lt; arr[l]) swap(arr[++m], arr[i]); swap(arr[m], arr[l]); qsort1(arr, l, m - 1); qsort1(arr, m + 1, u);&#125; 其实和之前文章中的快排方法1是对应的。 对于随机输入，这种快速排序算法很快，但他也存在一个致命的问题，当输入是数组是全部相等的，则需要O(n2)时间。 原因很简单，上面的for循环里，if条件一次都不满足。 使用哨兵优化上面的快排书中有两个提示：1、使用x[l]作为哨兵；2、移除循环后的swap 看到这个说法时，我的想法12345678910111213141516void qsort2(int arr[], int l, int u)&#123; if(l &gt;= u) return; //不同点1、记录哨兵值 int hold = arr[l]; int m = l; for(int i = l + 1; i &lt;= u; ++i) //不同点2、待比较值不再是arr[l]，该值可能变化了 if(arr[i] &lt; hold) //不同点3、m使用后置自增 swap(arr[m++], arr[i]); //不同点4、这里不再进行swap。循环退出后到了这里，m指向不比hold小的值 qsort2(arr, l, m - 1); qsort2(arr, m + 1, u);&#125; 使用{1, 2, .. ,7}、{7, 6..1}、{3, 1, 2, 4, 7, 5, 6}测试都OK，正确性待验证 书中标准答案如下： 划分方案改为从右往左伪代码1234m = u + 1for(i = u; i &gt;= l; i--) if x[i] &gt;= t swap(--m, i) 循环终止时，即i为l时，x[i] &gt;= t成立，所以x[m]会被置为t，这样就不再需要额外的swap啦 使用x[l]作为哨兵伪代码 可以省去内循环中的一次测试 123456m = i = u + 1do while x[--i] &lt; t ; swap(--m, i)while i != l 实现123456789101112131415void qsort2(int arr[], int l, int u)&#123; if(l &gt;= u) return; int m = u + 1, i = u + 1; int t = arr[l]; do &#123; while(arr[--i] &lt; t); swap(arr[--m], arr[i]); &#125; while(i != l); qsort2(arr, l, m - 1); qsort2(arr, m + 1, u);&#125; 双向划分 伪代码12345678910111213void qsort3(l, u) if l &gt;= u return t = x[l]; i = l; j = u + 1 loop do i++ while i &lt;= u &amp;&amp; x[i] &lt; t do j-- while x[j] &gt; t if i &gt; j break swap(i, j) swap(l, j) qsort3(l, j - 1) qsort3(j + 1, u) 真是精妙无比，几个注意点– j从u + 1开始，因为do..while，先做j–– x[i],x[j]与t比较时都是绝对的大于小于。如果用了&gt;=或&lt;=会怎么样？ 如果数组值全部相等 1、将x[i] &lt; t改成x[i] &lt;= t，第一个do..while之后i等于u+1，第二个do..while第一次 就不满足，所以j等于u，走break，走qsort3(l, u-1)，这样整个复杂的为O(n2) 2、将x[j] &lt; t改成x[j] &lt;= t，第二个do..while不能正确地退出，原因参考下一条说明– 为什么第二个do..while，不需要j &gt;= l这样的判断？因为x[l] == t，所以x[l] 充当了哨兵的作用，无论如何，程序最差也会在j == l的时候退出，不会导致死循环 这么来看的话，前一篇文章中的快排都没有很好地考虑元素全相等的情况 结合插入排序再优化1234567891011121314void qsort4(l, u) if u - l &lt; cutoff return swap(l, randint(l, u)) i = l, j = u + 1, t = x[l] loop do i++ while i &lt;= u &amp;&amp; x[i] &lt; t do j-- while x[j] &gt; t if i &gt; j break temp = x[i]; x[i] = x[j]; x[j] = t swap(l, j) qsort4(l, j - 1) qsort4(j + 1, u) 然后程序结束之后再调用插入排序12qsort4(0, n - 1)isort() 参考书中习题，cutoff取50是个比较合理的值 第12章两个常用函数 bigrand()C库函数rand()通常返回15个随机位（最大值RAND_MAX 为32767），要求返回30个随机位 1234int bigrand()&#123; return rand() * RAND_MAX + rand();&#125; randint(l, u)返回l和u之间的随机值（包括l和u） 1234int randint(int l, int u)&#123; return l + bigrand() % (u - l + 1);&#125; 题目1：输出随机有序列表输入两个整数m和n，其中m &lt; n。输出是0~n-1范围内m个随机整数的有序列表，不允许重复 方案一 依次考虑整数0,1,2,…,n-1，并通过适当的随机测试对每个整数进行选择；通过按序进行 – 伪代码1234567select = mremaining = nfor i = [0, n) if (bigrand() % remaining) &lt; select print i select-- remaining-- 只要m&lt;=n，程序输出的整数就恰好为m个，因为1、不会选择更多的整数，因为select变为0时，if条件就永远为false了2、不会选择更好的数，因为当remaining == select时，if条件为true – 实现123456789101112void randseries1(int m, int n)&#123; assert(m &lt;= n); for(int i = 0; i &lt; n; ++i) &#123; if((bigrand() % (n - i)) &lt; m) &#123; printf(\"%d \", i); --m; &#125; &#125;&#125; – 存在问题很明显程序运行时间正比于n，当n很大，m很小时，存在较大浪费 方案二在初始为空的集合里插入随机整数，直到个数足够 – 伪代码12345678initialize set S to emptysize = 0while size &lt; m do t = bigrand() % n if t is not in S insert t into S size++print the elements of S in sorted order C++ stl里的set正好符合当前的需求。set有两个特点：1、不存在重复元素2、元素自动排序 – 实现12345678910111213#include &lt;set&gt;void randseries2(int m, int n)&#123; assert(m &lt;= n); std::set&lt;int&gt; s; while(s.size() != m) &#123; s.insert(bigrand() % n); &#125; for(auto i : s) printf(\"%d \", i);&#125; – 存在问题空间开销比较大。需要将全部m个数存储在一个set中，当m较大时，需要很多额外空间 方案三把包含0~n-1个整数的数组顺序打乱，把前m个元素排序输出 – 实现123456789101112131415161718#include &lt;algorithm&gt;void randseries3(int m, int n)&#123; assert(m &lt;= n); int i, j; int *x = new int[n]; for(i = 0; i &lt; n; ++i) x[i] = i; for(i = 0; i &lt; m; ++i) &#123; j = randint(i, n - 1); int t = x[i]; x[i] = x[j]; x[j] = t; &#125; std::sort(x, x + m); for(i = 0; i &lt; m; ++i) printf(\"%d \", x[i]); delete []x;&#125; 还是比较好理解的 建立长度为n的临时数组，并赋值为0~n-1 i从0到m-1循环，并从i到n-1之间随机出一个索引。将该索引与i对应的值交换 此时0~m-1之间的值是乱序的随机值，排序之后输出 但是性能通常不如方案一 习题 题目7递归方式输出顺序随机整数 伪代码12345678910void randselect(m, n) pre 0 &lt;= m &lt;= n post m distinct integers from 0..n-1 are printed in decreasing order if m &gt; 0 if (bigrand() % n) &lt; m print n - 1 randselect(m - 1, n - 1) else randselect(m, n - 1) 按照伪代码实现123456789101112void randselect1(int m, int n)&#123; if(m &lt;= 0 || m &gt; n) return; if(bigrand() % n &lt; m) &#123; printf(\"%d \", n - 1); randselect1(m - 1, n - 1); &#125; else randselect1(m, n - 1);&#125; 书中问题 该方法是降序排列，如何使得按升序输出我的想法123456789101112void randselect2(int m, int begin, int n)&#123; if(m &lt;= 0 || begin &gt;= n) return; if((bigrand() % (n - begin)) &lt; m) &#123; printf(\"%d \", begin); randselect2(m - 1, begin + 1, n); &#125; else randselect2(m, begin + 1, n);&#125; 简单测试了一下应该是对的，但是真的太丑陋了啊 标准答案：只要将printf和randselect对调位置就行了，这其实是最简单的递归原理举个最简单无聊的例子12345678910111213141516//逆序输出n..1void printn(int n)&#123; if(n &lt;= 0) return; printf(\"%d \", n); printn(n - 1);&#125;//顺序输出1..nvoid printn1(int n)&#123; if(n &lt;= 0) return; printn1(n - 1); printf(\"%d \", n);&#125; 利用该程序结构生成0..n-1的所有m元子集书中没有给出答案，原来这还是一个经典的算法题 我的做法123456789101112131415161718192021222324252627//m表示剩余选择的个数//begin表示从第几个开始选//n表示数组总长度，是固定不动的void selectm(int m, int begin, int n, std::set&lt;int&gt; s)&#123; //m为1时，表示从剩下的数中选择一个 if(m == 1) &#123; for(int i = begin; i &lt; n; ++i) &#123; //set里保存了前m-1个数 for(int j : s) printf(\"%d \", j); printf(\"%d\\n\", i); &#125; return; &#125; else if(n - begin &gt;= m) &#123; for(int i = begin; i &lt;= n - m; ++i) &#123; s.insert(i); //测试选择i的情况 selectm(m - 1, i + 1, n, s); s.erase(i); //测试完成之后需要删除i，从而后面选择i+1... &#125; &#125;&#125; 经测试，selectm(4, 0, 7, s)的结果如下12345678910111213141516171819202122232425262728293031323334350 1 2 30 1 2 40 1 2 50 1 2 60 1 3 40 1 3 50 1 3 60 1 4 50 1 4 60 1 5 60 2 3 40 2 3 50 2 3 60 2 4 50 2 4 60 2 5 60 3 4 50 3 4 60 3 5 60 4 5 61 2 3 41 2 3 51 2 3 61 2 4 51 2 4 61 2 5 61 3 4 51 3 4 61 3 5 61 4 5 62 3 4 52 3 4 62 3 5 62 4 5 63 4 5 6 数目为35（Cnm=n!/(m! * (n - m)!)）个，应该是对的，只是还不够优雅。 为了便于理解，通过在首行加上相应log，相应输出如下1234567891011121314151617181920212223242526272829303132333435m:4, begin:0, n:7, cur set : //已选择数为空，从0~6选择4个数m:3, begin:1, n:7, cur set :0 //已选择数字0，从1~6选择3个数m:2, begin:2, n:7, cur set :0 1 //已选择数字0,1，从2~6选择2个数m:1, begin:3, n:7, cur set :0 1 2 //已选择数字0,1,2，从3~6选择1个数m:1, begin:4, n:7, cur set :0 1 3 //已选择数字0,1,3，从4~6选择1个数m:1, begin:5, n:7, cur set :0 1 4 //已选择数字0,1,4，从5~6选择1个数m:1, begin:6, n:7, cur set :0 1 5 //已选择数字0,1,5，从6~6选择1个数m:2, begin:3, n:7, cur set :0 2 //已选择数字0,2，从3~6选择2个数m:1, begin:4, n:7, cur set :0 2 3 //下同，不在赘述m:1, begin:5, n:7, cur set :0 2 4m:1, begin:6, n:7, cur set :0 2 5m:2, begin:4, n:7, cur set :0 3m:1, begin:5, n:7, cur set :0 3 4m:1, begin:6, n:7, cur set :0 3 5m:2, begin:5, n:7, cur set :0 4m:1, begin:6, n:7, cur set :0 4 5m:3, begin:2, n:7, cur set :1m:2, begin:3, n:7, cur set :1 2m:1, begin:4, n:7, cur set :1 2 3m:1, begin:5, n:7, cur set :1 2 4m:1, begin:6, n:7, cur set :1 2 5m:2, begin:4, n:7, cur set :1 3m:1, begin:5, n:7, cur set :1 3 4m:1, begin:6, n:7, cur set :1 3 5m:2, begin:5, n:7, cur set :1 4m:1, begin:6, n:7, cur set :1 4 5m:3, begin:3, n:7, cur set :2m:2, begin:4, n:7, cur set :2 3m:1, begin:5, n:7, cur set :2 3 4m:1, begin:6, n:7, cur set :2 3 5m:2, begin:5, n:7, cur set :2 4m:1, begin:6, n:7, cur set :2 4 5m:3, begin:4, n:7, cur set :3m:2, begin:5, n:7, cur set :3 4m:1, begin:6, n:7, cur set :3 4 5 网上别人的做法，参考：链接123456789101112131415161718192021222324252627int selectm(int m, int n)&#123; int *state = new int[m]; for(int i = 0; i &lt; m; ++i) state[i] = i; int count = 1; for(int i = 0; i &lt; m; ++i) printf(\"%d \", state[i]); printf(\"\\n\"); int npos = m - 1; while(state[0] &lt; n - m) &#123; if(state[m - 1] == n - 1) --npos; else npos = m - 1; state[npos]++; for(int i = npos + 1; i &lt; m; ++i) state[i] = state[i - 1] + 1; for(int i = 0; i &lt; m; ++i) printf(\"%d \", state[i]); printf(\"\\n\"); ++count; &#125; delete []state; return count;&#125; 也不是很优雅 题目9上面方案二基于集合的算法，当m接近于n时，生成的很多随机数都要丢掉，因为他们已经存在于集合中。Bob Floyd给出，在最坏情况下，也只需要生成m个随机数的算法 123456789101112131415void randseries4(int m, int n)&#123; std::set&lt;int&gt; s; for(int i = n - m; i &lt; n; ++i) &#123; int t = bigrand() % (i + 1); if(s.find(t) == s.end()) s.insert(t); // t is not in s else s.insert(i); // t in s &#125; for(int i : s) printf(\"%d \", i); printf(\"\\n\");&#125; 题目10如何从n个对象（可以依次看到这n个对象，但事先不知道n的值）中随机选择一个具体来说，如何在事先不知道文本文件行数的情况下读取该文件，从中速记选择并输出一行 思路总选择（以100%概率）第1行以概率1/2选择第2行（如果有的话）以概率1/3选择第3行（如果有的话）..如此结束后，每一行的选中概率都是相等的（1/n，n是文件的总行数） 伪代码 12345i = 0while more input lines with probability 1.0 / ++i choice = this input lineprint choice 实现 12345678910111213141516#include &lt;fstream&gt;#include &lt;string&gt;void printFileLine(const char *fname)&#123; std::ifstream in(fname); int i = 0; char line[50]; char choice[50]; while(!in.eof()) &#123; in &gt;&gt; line; if((bigrand() % (++i)) &lt; 1) strcpy(choice, line); &#125; printf(\"choice:%s\\n\", choice);&#125; 第13章本章讲搜索，主要讨论上一章的问题：生成[0, maxval]内m个随机整数生成，保存到集合中，该集合IntSet的实现方法。包含有序集合的创建，插入，遍历等。 通用接口如下：12345678class IntSetImp&#123; public: IntSetImp(int maxelements, int maxval); void insert(int t); int size(); void report(int *v);&#125; 其中，构造参数分别表示集合元素的最大个数和集合元素的最大值（加1）；insert函数向集合中添加一个新的整数（如果已存在就忽略）；size返回当前元素个数；report将元素写入向量v中。 实现方式有以下几种 利用标准库set 数组 链表 二叉搜索树 位向量 箱下面，一一实现一下 使用标准模板库set12345678910111213141516class IntSetSTL&#123;public: IntSetSTL(int maxelements, int maxval) &#123;&#125; void insert(int t) &#123; s.insert(t); &#125; int size() const &#123; return s.size(); &#125; void report(int *v) const &#123; int i = 0; //书中使用迭代器遍历，这里用C++11新特性 for(int data : s) v[i++] = data; &#125;private: std::set&lt;int&gt; s;&#125;; 优点简单清晰，但是时间空间效率都不高 使用数组123456789101112131415161718192021222324252627282930313233343536373839404142434445class IntSetArr&#123;public: IntSetArr(int maxelements, int maxval) &#123; arr_ = new int[1 + maxelements]; n_ = 0; //哨兵元素，放置在已排序元素的最后（maxval比集合中任何元素都大） //下面的insert利用了该哨兵 arr_[0] = maxval; &#125; ~IntSetArr() &#123; delete []arr_; &#125; //书中insert实现 void insert(int t) &#123; int i; for(i = 0; arr_[i] &lt; t; ++i) ; if(arr_[i] == t) //元素已存在 return; for(int j = n_; j &gt;= i; --j) arr_[j + 1] = arr_[j]; arr_[i] = t; n_++; &#125; //我本想实现成下面这样类似于插入排序的更简单的方式 //但这种方式不好避免元素出现重复的情况，要加很多判断，很啰嗦 void insert1(int t) &#123; int i; for(i = n_; i &gt; 0 &amp;&amp; arr_[i - 1] &gt; t; --i) arr_[i] = arr_[i - 1]; arr_[i] = t; n_++; &#125; int size() const &#123; return n_; &#125; void report(int *v) const &#123; for(int i = 0; i &lt; n_; ++i) v[i] = arr_[i]; &#125;private: int n_; int *arr_;&#125;; 在已知set大小的情况下，使用数组还比较合理。但是插入元素时，需要移动的元素比较多。 注意上面的insert方法 使用链表在集合大小未知的情况下，链表是首选，而且插入元素开销较小（不需要移动）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class IntSetList&#123;public: IntSetList(int maxelements, int maxval) &#123; n_ = 0; //sentinel_始终指向最大元素节点 //head_始终指向头结点(也是有效的数据节点) sentinel_ = head_ = new Node(maxval); &#125; ~IntSetList() &#123; Node *p = head_, *q; while(p) &#123; q = p-&gt;next_; delete p; p = q; &#125; &#125; int size() const &#123; return n_; &#125; //书中递归版 void insert(int t) &#123; head_ = rinsert(head_, t); &#125; //自写迭代版 void insert1(int t) &#123; Node *p = head_, *q = head_; while(p != sentinel_ &amp;&amp; p-&gt;data_ &lt; t) &#123; //q始终指向p的前一个（如果有的话） q = p; p = p-&gt;next_; &#125; //循环结束之后，p指向的data应当&gt;=t //如果==t，则已存在，返回 if(p-&gt;data_ == t) return; n_++; //如果p指向的是头结点，即待插入的节点值是最小的 //则需要将新建节点赋值给head if(p == head_) head_ = new Node(t, p); else q-&gt;next_ = new Node(t, q-&gt;next_); &#125; void report(int *v) const &#123; int i = 0; //for(Node *p = head_-&gt;next_; p != nullptr; p = p-&gt;next_) for(Node *p = head_; p != sentinel_; p = p-&gt;next_) v[i++] = p-&gt;data_; &#125;private: int n_; struct Node &#123; int data_; Node *next_; Node(int data = 0, Node *next = nullptr) : data_(data), next_(next) &#123;&#125; &#125;; Node *head_, *sentinel_; Node *rinsert(Node *p, int t) &#123; if(p-&gt;data_ &lt; t) p-&gt;next_ = rinsert(p-&gt;next_, t); else if(p-&gt;data_ &gt; t) &#123; p = new Node(t, p); n_++; &#125; return p; &#125;&#125;; 也比较好理解，需要注意的是insert函数，分别实现了递归版和迭代版，显然递归版更加清晰一些。 使用二分搜索树参考二叉查找树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class IntSetBST&#123;public: IntSetBST(int maxelements, int maxval) &#123; root_ = nullptr; n_ = 0; &#125; int size() const &#123; return n_; &#125; //书中递归版本 void insert(int t) &#123; rinsert(t, root_); &#125; //自写迭代版本 void insert1(int t) &#123; if(root_ == nullptr) &#123; root_ = new Node(t); n_++; return; &#125; Node *p = root_, *q = root_; bool isleft = true; while(p) &#123; if(t == p-&gt;data_) return; //相等，不插入 //q始终指向p的父节点（如果有的话） q = p; if(t &lt; p-&gt;data_) &#123; p = p-&gt;left_; isleft = true; &#125; else &#123; p = p-&gt;right_; isleft = false; &#125; &#125; n_++; if(isleft) q-&gt;left_ = new Node(t); else q-&gt;right_ = new Node(t); &#125; void report(int *v) const &#123; traverse(v, root_); &#125;private: struct Node &#123; int data_; Node *left_, *right_; Node(int data=0, Node *left=nullptr, Node *right=nullptr) : data_(data), left_(left), right_(right) &#123;&#125; &#125;; Node *root_; int n_; //和书中略有不同，书中rinsert有返回值，从而Node *p不需要使用引用参数 //本质是一样的 void rinsert(int t, Node *&amp;p) &#123; if(!p) &#123; p = new Node(t); n_++; &#125; else if(t &lt; p-&gt;data_) rinsert(t, p-&gt;left_); else if(p-&gt;data_ &lt; t) rinsert(t, p-&gt;right_); &#125; //和书中略有不同，书中使用成员变量索引vn //每次访问索引vn自增，从而不需要传递数组指针参数 void traverse(int *&amp;v, Node *p) const &#123; if(!p) return; traverse(v, p-&gt;left_); *v++ = p-&gt;data_; traverse(v, p-&gt;right_); &#125;&#125;; 二分搜索树支持快速插入和搜索。 之前这几个数据结构都是比较好想的，下面的才是真正快速的，前方高能。 使用位向量位向量的妙用在第一章已经见识过了1234567891011121314151617181920212223242526272829303132333435363738class IntSetBitVec&#123;public: IntSetBitVec(int maxelements, int maxval) &#123; hi_ = maxval; n_ = 0; arr_ = new int[1 + hi_ / BITSPERWORD]&#123;0&#125;; //书中这里还加上了clr处理，但我觉得这是不必要的 //因为new int[n]&#123;0&#125;，已经将每一项置为0了 &#125; ~IntSetBitVec() &#123; delete []arr_; &#125; int size() const &#123; return n_; &#125; void insert(int t) &#123; if(test(t)) return; set(t); n_++; &#125; void report(int *v) &#123; int j = 0; for(int i = 0; i &lt; hi_; ++i) &#123; if(test(i)) v[j++] = i; &#125; &#125;private: enum &#123;BITSPERWORD = 32, SHIFT = 5, MASK = 0x1F&#125;; void set(int i) &#123; arr_[i &gt;&gt; SHIFT] |= (1 &lt;&lt; (i &amp; MASK)); &#125; void clr(int i) &#123; arr_[i &gt;&gt; SHIFT] &amp;= ~(1 &lt;&lt; (i &amp; MASK)); &#125; int test(int i) &#123; return arr_[i &gt;&gt; SHIFT] &amp; (1 &lt;&lt; (i &amp; MASK)); &#125; int n_; int hi_; int *arr_;&#125;; 完美的利用了位向量的特点，相对于纯数组来说，存储空间大大减小。但是对于最大值很大的情况，存储空间消耗依然非常严重，比如要在232个数中选择两个，所需要的数组长度竟然是1+227，这显然是巨大的浪费 使用箱序列箱，听名字感觉好高大上，其实就是就是结合了链表和位向量。怎么理解？比如要在0~99范围内选择4个整数，则需要4个箱： 箱0表示 0~24范围内的整数 箱1表示25~49范围内的整数 箱2表示50~74范围内的整数 箱3表示75~99范围内的整数如果选出的4个数正好分别落在4个区间内，则每个箱正好有1个整数。可是如果选出的数是{20, 31, 41, 59}呢，那么箱1就需要表示两个整数（用链表表示），箱3表示0个整数 但是由于整数是均匀分别的，索引每个链表的期望长度都为1。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class IntSetBins&#123;public: IntSetBins(int maxelements, int maxval) &#123; maxval_ = maxval; //表示有多少个箱子 bins_ = maxelements; //指针数组，每个成员指向每个箱子的头结点 bin = new Node*[maxelements]; sentinel_ = new Node(maxval); //每个箱子的头结点初始化为哨兵节点 for(int i = 0; i &lt; bins_; ++i) bin[i] = sentinel_; n_ = 0; &#125; int size() const &#123; return n_; &#125; void insert(int t) &#123; //接下来就需要映射了，类似于位向量那样，将t映射到某个箱子 int i = t /(1 + maxval_ / bins_); //书中说如下映射会带来麻烦，还没理解 //int i = t * bins / maxval_; bin[i] = rinsert(bin[i], t); &#125; void report(int *v) &#123; int j = 0; for(int i = 0; i &lt; bins_; ++i) &#123; for(Node *p = bin[i]; p != sentinel_; p = p-&gt;next_) v[j++] = p-&gt;data_; &#125; &#125;private: int n_, bins_; int maxval_; struct Node &#123; int data_; Node *next_; Node(int data = 0, Node *next = nullptr) : data_(data), next_(next) &#123;&#125; &#125;; Node **bin, *sentinel_; //类似于纯链表的情况 Node *rinsert(Node *p, int t) &#123; if(p-&gt;data_ &lt; t) p-&gt;next_ = rinsert(p-&gt;next_, t); else if(p-&gt;data_ &gt; t) &#123; p = new Node(t, p); n_++; &#125; return p; &#125;&#125;; 还是比较好理解的，其实总结而言就一句：将单纯的链表映射到各个箱的分散的单链表中。由于数据分散的特点，每个单链表长度期望为1 习题 题目4实现链表、箱、二分搜索树插入的迭代版本 链表的插入迭代版本我自己的实现参考上面的，书中给出两种实现实现1123456789101112131415161718192021void insert(int t)&#123; //head节点值等于带插入节点值，返回 if(head_-&gt;data_ == t) return; //head节点值比待插入节点大，则新增节点要设为head if(head_-&gt;data_ &gt; t) &#123; head_ = new Node(t, head_); n_++; return; &#125; Node *p; for(p = head_; p-&gt;next_-&gt;data_ &lt; t; p = p-&gt;next_) ; //循环结束之后p的下一个节点的值&gt;=t if(p-&gt;next_-&gt;data_ == t) return; p-&gt;next_ = new Node(t, p-&gt;next_); n_++;&#125; 使用指向指针的指针来去除重复12345678910void insert(int t)&#123; Node **p; for(p = &amp;head_; (*p)-&gt;data_ &lt; t; p = &amp;((*p)-&gt;next_)); ; if((*p)-&gt;data_ == t) return; n_++; *p = new Node(t, *p);&#125; 这段代码还是比较精妙的，为什么使用指针的指针就可以消除重复了？来看几种情况一开始链表为空，head指向最大元素200. 这时插入元素100，则for循环一次不走退出；p为指向head的指针 则最后一个赋值语句等价于head = new Node(t, head)，成功赋值头结点. 再插入元素90，等价于上面的情况. 再插入元素95，for循环退出时，p为指向节点100的指针。 最后一个赋值语句，将原本的节点100，修改成了节点95，并且节点95的下一个节点为节点100，则插入完成 题目7使用哨兵节点和整块申请内存，优化二叉搜索树 题目9用低开销的逻辑移位替代高开销的除法运算。 第14章本章主要讲堆，参考 优先队列（堆） 堆排序 结合两本书所述，再给出堆排序算法（index从0开始）12345678910111213141516171819202122232425262728293031323334353637void siftdown(int arr[], int size, int hole)&#123; int child; int t = arr[hole]; for(;hole &lt;= size / 2 - 1; hole = child) &#123; child = 2 * hole + 1; if(child &lt; size - 1 &amp;&amp; arr[child + 1] &gt; arr[child]) child++; if(arr[child] &gt; t) arr[hole] = arr[child]; else break; &#125; arr[hole] = t;&#125;void swap(int &amp;a, int &amp;b)&#123; if(a == b) return; a = a ^ b; b = a ^ b; a = a ^ b;&#125;void hsort(int arr[], int size)&#123; //build heap for(int i = size / 2 - 1; i &gt;= 0; --i) siftdown(arr, size, i); for(int i = size - 1; i &gt; 0; --i) &#123; swap(arr[0], arr[i]); siftdown(arr, i, 0); &#125;&#125; 第15章单词主要比较了C++标准库map/set和直接写C散列表的性能区别，参考散列表 短语 查找字符串中最长重复子字符串例如”Ask not what your country can do for you, but what you can do for your country”，中最长的重复字符串是”can do for you”，第二长的是”your country” 看到这道题，我最初的想法 从最长的子串（长度为size-1）到最短的子串（长度为1）循环，找到则退出，则退出时找到的子串就是最长的 以查找长度为len的子串为例，从首字母开始的子串开始，将每一个子串放到一个set中，如果set中已经包含该子串，则表示子串重复 123456789101112131415161718192021void findMaxDuplicate(const std::string &amp;src)&#123; int size = src.size(); std::set&lt;std::string&gt; substrs; for(int len = size - 1; len &gt;= 1; --len) &#123; substrs.clear(); for(int i = 0; i &lt;= size - len; ++i) &#123; std::string subs = src.substr(i, len); if(substrs.find(subs) != substrs.end()) &#123; std::cout &lt;&lt; \"max sub is: \" &lt;&lt; subs &lt;&lt; std::endl; return; &#125; else substrs.insert(subs); &#125; &#125; std::cout &lt;&lt; \"max sub is empty\" &lt;&lt; std::endl;&#125; 测试了一下结果应该是对的，但有两个缺点 太依赖标准库set、string 题目的意思应该是重复的单词，而按这种方式求出来的前后可能带有空格，想要trim还有点麻烦 书中算法一：最直接的算法就是强行遍历每一个子串伪代码12345678910111213maxlen = -1for i = [0, n) for j = (i, n) if (thislen = comlen(&amp;c[i], &amp;c[j])) &gt; maxlen maxlen = thislen maxi = i maxj = j//comlen原型int comlen(char *p, char *q) i = 0 while *p &amp;&amp; (*p++ == *q++) i++ return i 一个注意点：while循环是不需要同时判断p和q不指向’\\0’的（后一个相等性判断已经保证），多写浪费实现123456789101112131415161718192021222324252627void findMaxDuplicate2(const char *src)&#123; int size = strlen(src), maxlen = -1, maxi = 0, maxj = 0, thislen = 0; for(int i = 0; i &lt; size; ++i) &#123; for(int j = i + 1; j &lt; size; ++j) &#123; if((thislen = comlen(src + i, src + j)) &gt; maxlen) &#123; maxlen = thislen; maxi = i; maxj = j; printf(\"maxlen:%d, maxi:%d, maxj:%d\\n\", thislen, i, j); &#125; &#125; &#125; if(maxlen != -1) &#123; printf(\"max sub is: \"); for(int i = 0; i &lt; maxlen; ++i) printf(\"%c\", src[maxi+ i]); printf(\"\\n\"); &#125; else printf(\"max sub is empty\\n\");&#125; 很明显，效率也比较低 书中算法二：使用后缀数组 什么是后缀数组？假设有字符串char c[] = “banana”;和字符指针数组char * a[];令a[0] = &amp;c[0], a[1] = &amp;c[1], a[2] = &amp;c[2]…则a中每个字符串指向的字符串分别为a[0] : bananaa[1] : ananaa[2] : nanaa[3] : anaa[4] : naa[5] : a数组a中的指针包含了字符串中的每一个后缀，因此称为后缀数组。从为文件中读取字符串时，可以这样初始化a和c12345678910111213#define MAXN 5000000char c[MAXN], *a[MAXN];int init()&#123; int n = 0; char ch; while((ch = getchar()) != EOF) &#123; a[n] = &amp;c[n]; c[n++] = ch; &#125; c[n] = '\\0';&#125; 执行指令(参考第二章中的做法)test.exe &lt; in.txt &gt; out.txt 排序数组a如果某个字符串在数组c中出现两次，那么他将出现在两个不同的后缀中，因此对数组排序以寻找相同的后缀（参考2.4），以”banana”为例，排序后a为a[0] : aa[1] : anaa[2] : ananaa[3] : bananaa[4] : naa[5] : nana这样就可以扫描a，比较相邻元素来找出最长的重复字符串 ** 小插曲：使用qsort排序字符串数组和字符指针数组的不同参考qsort用法字符串数组1234567891011int arrstrcmp(const void *x, const void *y)&#123; //这里传入的每个x类型其实为字符串数组类型，所以强转为char*即可 return strcmp((char *)x, (char *)y);&#125;static const int n = 6;char s[n][7] = &#123;\"banana\", \"anana\", \"nana\", \"ana\", \"na\", \"a\"&#125;;//打印typeid(s[0])可知，s[0]的类型为char[7]，长度自然为7qsort(s, n, sizeof(s[0]), arrstrcmp);//a, ana, anana, banana, na, nana 这其中应该有不少字符串拷贝，消耗较大 字符串指针数组123456789int pstrcmp(const void *x, const void *y)&#123; //这里传过来的每一项应该是字符串指针 return strcmp(*(char **)x , *(char **)y);&#125;char *s[n] = &#123;\"banana\", \"anana\", \"nana\", \"ana\", \"na\", \"a\"&#125;;//打印typeid(s[0])可知，s[0]的类型为char*，长度为1qsort(s, n, sizeof(s[0]), pstrcmp); 这其中应该只是指针的变化，消耗较小 由上面的讨论可知，本例中的数组a显然是后一种类型 扫描数组a，查找相邻元素的重复字符串1234567891011//扫描数组a int maxlen = -1, maxi = 0, thislen = 0; for(int i = 0; i &lt; n - 1; ++i) &#123; if((thislen = comlen(a[i], a[i + 1])) &gt; maxlen) &#123; maxlen = thislen; maxi = i; &#125; &#125; printf(\"max sub is %.*s\\n\", maxlen, a[maxi]); 注意点：可以在printf语句使用” * “精度输出字符串maxlen个字符。闻所未闻啊！！ 查找不包含重复字符的最长子串这个是想到的之前遇到的一个面试题，和本章其实没什么关系，只是题目名字有点相似例如”abcbcdeda”，则最长子串为”bcde” 12345678910111213141516171819202122232425262728293031323334353637383940//check src[begin..end] has the same char with chbool contains(const char *src, int begin, int end, char ch)&#123; for(int i = begin; i &lt;= end; ++i) if(src[i] == ch) return true; return false;&#125;void findMaxSub(const char *src)&#123; int size = strlen(src); if(size == 0) &#123; printf(\"str is empty\\n\"); return; &#125; int maxlen = 1, thislen, maxi = 0; for(int i = 0; i &lt; size - 1; ++i) &#123; thislen = 1; int j = i; while(j &lt; size - 1 &amp;&amp; !contains(src, i, j, src[j + 1])) &#123; j++; if(j - i + 1 &gt; maxlen) &#123; maxlen = j - i + 1; maxi = i; &#125; &#125; &#125; printf(\"max substr:%.*s\\n\", maxlen, src + maxi); &#125;findMaxSub(\"abcbcdedacgb\"); //edacgbfindMaxSub(\"bcad\"); //bcadfindMaxSub(\"abcadc\"); //bcadfindMaxSub(\"aaaa\"); //afindMaxSub(\"\"); //str is empty 效率不甚高啊，再想想有没有优化的方法","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"几种语言实现socket例子","date":"2018-01-21T12:23:51.000Z","path":"2018/01/21/几种语言实现socket例子/","text":"参考： windows环境下用c++实现socket编 linux下C/C++网络编程基本：socket实现tcp和udp的例子 Windows Socket TCP/UDP写在前面参考《Python核心编程》中关于TCP、UDP介绍的例子。不管用什么语言，在什么系统下，万变不离其宗，都是类似于下面伪代码的逻辑。TCP服务器123456789ss = socket() # 创建服务器套接字ss.bind() # 套接字与地址绑定ss.listen() # 监听连接inf_loop: # 服务器无限循环 cs = ss.accept() # 接收客户端连接 comm_loop: # 通信循环 cs.recv/cs.send() # 对话（接收/发送） cs.close() # 关闭客户端套接字ss.close() # 关闭服务器套接字（可选） TCP客户端12345cs = socket() # 创建客户端套接字cs.connect() # 尝试连接服务器comm_loop: # 通信循环 cs.send()/cs.recv() # 对话（发送/接收）cs.close() # 关闭客户端套接字 UDP服务器12345ss = socket() # 创建服务器套接字ss.bind() # 绑定服务器套接字inf_loop: # 服务器无限循环 cs = ss.recvfrom()/ss.sendto() # 对话（接收/发送）ss.close() # 关闭服务器套接字 UDP客户端1234cs = socket() # 创建客户端套接字comm_loop: # 通信循环 cs.sendto()/cs.recvfrom() # 对话（发送/接收）cs.close() # 关闭客户端套接字 下面实现的例子功能都是 客户端发送一条消息之后 服务端在原消息基础上增加时间戳并返回给客户端 客户端发送#之后退出 TCPwindows C/C++服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#include &lt;time.h&gt;# pragma comment(lib, \"ws2_32.lib\")# define BUFFSIZE 255const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;int main()&#123; //step-1:加载套接字库（WSAStartup()）; WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"init socket fail\\n\"); exit(-1); &#125; //step-2:创建服务器套接字(socket()) SOCKET serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(serverSocket == INVALID_SOCKET) &#123; printf(\"socket error!\\n\"); exit(-1); &#125; sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(sockaddr)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = INADDR_ANY; //step-3:绑定套接字到一个IP地址和一个端口上(bind()) //这里绑定到任意的ip和固定的8888端口 if(bind(serverSocket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(\"bind error\\n\"); closesocket(serverSocket); exit(-1); &#125; //step-4:将套接字设置为监听模式等待连接请求(listen()) if(listen(serverSocket, 5) == SOCKET_ERROR) &#123; printf(\"listen error\\n\"); exit(-1); &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) //服务器无限循环 &#123; printf(\"waiting for connect...\\n\"); //step-5:等待连接请求，并返回对应于此连接的socket(accept()) sockaddr_in remoteAddr; int addrLen = sizeof(remoteAddr); SOCKET clientSocket = accept(serverSocket, (SOCKADDR*)&amp;remoteAddr, &amp;addrLen); if(clientSocket == INVALID_SOCKET) &#123; printf(\"accept error\\n\"); continue; &#125; printf(\"receive a connect :%s\\n\", inet_ntoa(remoteAddr.sin_addr)); while(true) //对话循环 &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); //step-6:等待接收客户端发送过来的数据（recv()） int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len &gt; 0) &#123; recvData[len] = '\\0'; //收到#则退出本次对话 if(strcmp(recvData,\"#\") == 0) &#123; printf(\"recv exit symbol, exit...\\n\"); break; &#125; printf(\"%s\\n\", recvData); &#125; else &#123; printf(\"recv data fail\\n\"); break; &#125; const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); //step-7:向客户端发送响应（send()） if(send(clientSocket, sendData, strlen(sendData), 0) == SOCKET_ERROR) &#123; printf(\"send data fail\\n\"); break; &#125; &#125; //step-8:关闭此次连接请求的socket closesocket(clientSocket); &#125; //step-9：关闭服务端socket closesocket(serverSocket); //step-10：关闭加载的socket库 WSACleanup(); return 0;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#pragma comment(lib, \"ws2_32.lib\")#define BUFFSIZE 255int main()&#123; WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; //step-1:加载套接字库 if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"socket start fail\\n\"); exit(-1); &#125; //step-2:创建套接字 SOCKET clientSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(clientSocket == INVALID_SOCKET) &#123; printf(\"invalid socket\\n\"); exit(-1); &#125; sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(sockaddr_in)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); //step-3:向服务端发送连接请求 if(connect(clientSocket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(\"connect error\\n\"); closesocket(clientSocket); exit(-1); &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) &#123; memset(sendData, 0, BUFFSIZE); memset(recvData, 0, BUFFSIZE); scanf(\"%s\", &amp;sendData); //step-4:向服务端发送数据 if(send(clientSocket, sendData, strlen(sendData), 0) == SOCKET_ERROR) &#123; printf(\"send data fail\\n\"); exit(-1); &#125; //输入#则退出 if(strcmp(sendData, \"#\") == 0) &#123; break; &#125; //step-5:收到服务器的响应 int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; //step-6:关闭本次连接socket closesocket(clientSocket); //step-7:关闭加载的套接字库 WSACleanup(); return 0;&#125; linux C/C++服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;#define BUFFSIZE 255int main()&#123; //step-1：创建服务器端套接字 int serverSocket = socket(AF_INET, SOCK_STREAM, 0); if(serverSocket &lt; 0) &#123; printf(\"invalid socket\\n\"); return -1; &#125; struct sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(serAddr)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.s_addr = INADDR_ANY; //step-2:绑定套接字到一个地址 if(bind(serverSocket, (struct sockaddr*)&amp;serAddr, sizeof(serAddr)) &lt; 0) &#123; printf(\"bind error\\n\"); return -1; &#125; //step-3:将套接字设置为监听模式等待连接请求 if(listen(serverSocket, 5) &lt; 0) &#123; printf(\"listen error\\n\"); return -1; &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) &#123; printf(\"waiting for connect...\\n\"); struct sockaddr_in remoteAddr; int addrLen = sizeof(struct sockaddr_in); //step-4:等待连接请求，并返回对应于此连接的socket int clientSocket = accept(serverSocket, (struct sockaddr*)&amp;remoteAddr, (socklen_t*)&amp;addrLen); if(clientSocket &lt; 0) &#123; perror(\"accept error\"); continue; &#125; printf(\"receive a connect :%s\\n\", inet_ntoa(remoteAddr.sin_addr)); while(true) &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); //step-5:等待接收客户端发送过来的数据 int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len&gt; 0) &#123; recvData[len] = '\\0'; //收到#则退出本次对话 if(strcmp(recvData,\"#\") == 0) &#123; printf(\"recv exit symbol, exit...\\n\"); break; &#125; printf(\"%s\\n\", recvData); &#125; else &#123; printf(\"recv data fail\\n\"); break; &#125; const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); //step-6:向客户端发送响应（send()） if(send(clientSocket, sendData, strlen(sendData), 0) &lt; 0) &#123; printf(\"send data fail\\n\"); break; &#125; &#125; //step-7:关闭此次连接请求的socket close(clientSocket); &#125; //step-8：关闭服务端socket close(serverSocket); return 0;&#125; 客户端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#define BUFFSIZE 255int main()&#123; //step-1:创建套接字 int clientSocket = socket(AF_INET, SOCK_STREAM, 0); if(clientSocket &lt; 0) &#123; printf(\"invalid socket\\n\"); return -1; &#125; sockaddr_in serAddr; memset(&amp;serAddr, 0, sizeof(serAddr)); serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); //step-2:向服务端发送连接请求 if(connect(clientSocket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) &lt; 0) &#123; printf(\"connect error\\n\"); close(clientSocket); return -1; &#125; char recvData[BUFFSIZE] = \"\\0\"; char sendData[BUFFSIZE] = \"\\0\"; while(true) &#123; memset(sendData, 0, BUFFSIZE); memset(recvData, 0, BUFFSIZE); scanf(\"%s\", &amp;sendData); //step-3:向服务端发送数据 if(send(clientSocket, sendData, strlen(sendData), 0) &lt; 0) &#123; printf(\"send data fail\\n\"); return -1; &#125; //输入#则退出 if(strcmp(sendData, \"#\") == 0) &#123; break; &#125; //step-4:收到服务器的响应 int len = recv(clientSocket, recvData, BUFFSIZE, 0); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; //step-5:关闭本次连接socket close(clientSocket); return 0;&#125; Python服务端12345678910111213141516171819202122232425262728#!/usr/bin/env python3from socket import *from time import ctimeHOST = ''PORT = 8888BUFFSIZE = 1024ADDR = (HOST, PORT)serSock = socket(AF_INET, SOCK_STREAM)serSock.bind(ADDR)serSock.listen(5)while True: print('waiting for connection...') cliSock, addr = serSock.accept() print('...connected from:', addr) while True: data = cliSock.recv(BUFFSIZE) print(data) if data == b'#': break cliSock.send(b'[%s] %s' % (bytes(ctime(), 'utf-8'), data)) cliSock.close()serSock.close() 客户端123456789101112131415161718192021#!/usr/bin/env python3from socket import *HOST = '127.0.0.1'PORT = 8888ADDR = (HOST, PORT)BUFFSIZE = 1024cliSock = socket(AF_INET, SOCK_STREAM)cliSock.connect(ADDR)while True: data = input('&gt;') cliSock.send(bytes(data, 'utf-8')) if data == '#': break data = cliSock.recv(BUFFSIZE); print(data)cliSock.close() udpwindows C/C++服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#include &lt;time.h&gt;#pragma comment(lib, \"ws2_32.lib\")#define BUFFSIZE 255const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;int main()&#123; WSADATA wsaData; WORD sockVersion = MAKEWORD(2, 2); if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"init socket fail\\n\"); exit(-1); &#125; SOCKET serSoket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); if(serSoket == INVALID_SOCKET) &#123; printf(\"socket error\\n\"); exit(-1); &#125; sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(serSoket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(\"bind error\\n\"); closesocket(serSoket); exit(-1); &#125; char recvData[BUFFSIZE]; char sendData[BUFFSIZE]; while(true) &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); printf(\"waiting for message...\\n\"); sockaddr_in remoteAddr; int nAddrLen = sizeof(remoteAddr); int len = recvfrom(serSoket, recvData, BUFFSIZE, 0, (sockaddr*)&amp;remoteAddr, &amp;nAddrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); sendto(serSoket, sendData, strlen(sendData), 0, (sockaddr*)&amp;remoteAddr, nAddrLen); &#125; &#125; closesocket(serSoket); WSACleanup(); return 0;&#125; 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;string&gt;#pragma comment(lib, \"ws2_32.lib\")#define BUFFSIZE 255int main()&#123; WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; if(WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; printf(\"init socket fail\\n\"); exit(-1); &#125; SOCKET sClient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8888); sin.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); int addrLen = sizeof(sockaddr_in); char sendData[BUFFSIZE]; char recvData[BUFFSIZE]; while(true) &#123; scanf(\"%s\", &amp;sendData); if(strcmp(sendData, \"#\") == 0) &#123; printf(\"exit...\\n\"); break; &#125; sendto(sClient, sendData, strlen(sendData), 0, (sockaddr*)&amp;sin, addrLen); int len = recvfrom(sClient, recvData, BUFFSIZE, 0, (sockaddr*)&amp;sin, &amp;addrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; closesocket(sClient); WSACleanup(); return 0;&#125; linux C/C++服务端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#define BUFFSIZE 255const char *getCurrentTime()&#123; time_t timer = time(NULL); struct tm *tblock = localtime(&amp;timer); return asctime(tblock);&#125;int main()&#123; int serSoket = socket(AF_INET, SOCK_DGRAM, 0); if(serSoket &lt; 0) &#123; printf(\"socket error\\n\"); return -1; &#125; sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.s_addr = INADDR_ANY; if(bind(serSoket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) &lt; 0) &#123; printf(\"bind error\\n\"); close(serSoket); return -1; &#125; char recvData[BUFFSIZE]; char sendData[BUFFSIZE]; while(true) &#123; memset(recvData, 0, BUFFSIZE); memset(sendData, 0, BUFFSIZE); printf(\"waiting for message...\\n\"); sockaddr_in remoteAddr; int addrLen = sizeof(remoteAddr); int len = recvfrom(serSoket, recvData, BUFFSIZE, 0, (sockaddr*)&amp;remoteAddr, (socklen_t*)&amp;addrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); const char *curTime = getCurrentTime(); //这里去掉最后的换行符 char tmp[100] = \"\\0\"; memcpy(tmp, curTime, strlen(curTime) - 1); sprintf(sendData, \"[%s] \", tmp); strcat(sendData, recvData); sendto(serSoket, sendData, strlen(sendData), 0, (sockaddr*)&amp;remoteAddr, addrLen); &#125; &#125; close(serSoket); return 0;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#define BUFFSIZE 255int main()&#123; int sClient = socket(AF_INET, SOCK_DGRAM, 0); sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8888); sin.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); int addrLen = sizeof(sockaddr_in); char sendData[BUFFSIZE]; char recvData[BUFFSIZE]; while(true) &#123; scanf(\"%s\", &amp;sendData); if(strcmp(sendData, \"#\") == 0) &#123; printf(\"exit...\\n\"); break; &#125; sendto(sClient, sendData, strlen(sendData), 0, (sockaddr*)&amp;sin, addrLen); int len = recvfrom(sClient, recvData, BUFFSIZE, 0, (sockaddr*)&amp;sin, (socklen_t*)&amp;addrLen); if(len &gt; 0) &#123; recvData[len] = '\\0'; printf(\"%s\\n\", recvData); &#125; &#125; close(sClient); return 0;&#125; Python服务端123456789101112131415161718192021#!/usr/bin/env python3from socket import *from time import ctimeHOST = ''PORT = 8888ADDR = (HOST, PORT)BUFFSIZE = 1024serSock = socket(AF_INET, SOCK_DGRAM)serSock.bind(ADDR)while True: print('waiting for message...') data, addr = serSock.recvfrom(BUFFSIZE) serSock.sendto(b'[%s] %s' % (bytes(ctime(), 'utf-8'), data), addr) print('...received from and returned to:', addr)serSock.close() 客户端12345678910111213141516171819#!/usr/bin/env python3from socket import *HOST = '127.0.0.1'PORT = 8888ADDR = (HOST, PORT)BUFFSIZE = 1024cliSock = socket(AF_INET, SOCK_DGRAM)while True: data = input('&gt;') if data == \"#\": break cliSock.sendto(bytes(data, 'utf-8'), ADDR) data, addr = cliSock.recvfrom(BUFFSIZE) print(data)cliSock.close() websocket参考： 非常有趣的理解websocket HTML5 WebSocket 说明 是什么：HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议 什么用：解决http轮询等的资源消耗，建立连接后，服务器和客户端可以快速地互相传输数据 怎么用：参考下面的例子 例子 服务端各个语言都有实现，仅Python就发现了两种实现1、pywebsocket2、python-websocket-server 打个标记，后面有时间啃一下 客户端比较简单，上面的例子都有","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"二叉树C++实现","date":"2018-01-15T11:23:51.000Z","path":"2018/01/15/二叉树C++实现/","text":"类声明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;iostream&gt;template &lt;class T&gt;class BinaryTree&#123;public: enum ORDER &#123; LEVELORDER, //层次 PREORDER, //先序 &#125;; BinaryTree() : root_(nullptr), size_(0) &#123;&#125; //通过数组构造，其中数组里的值默认按照层次优先排列; //nullVal表示为空的值，order表示传入数组的排列顺序 //下面以T为int，nullVal为-1时举例 // 3 // / \\ // 2 7 // \\ / \\ // 4 5 1 //要构造这样一个二叉树，则各种顺序下需要传入的数组为 //层次：&#123;3, 2, 7, -1, 4, 5, 1&#125; //先序：&#123;3, 2, -1, 4, -1, -1, 7, 5, -1, -1, 1&#125; //目前只想到这两种初始化的方式。 //因为必须先构造父，再构造左右孩子，所以应该只能先序吧 BinaryTree(const std::vector&lt;T&gt; &amp;array, const T &amp;nullVal, ORDER order=LEVELORDER); //前序遍历 std::vector&lt;T&gt; preOrder(bool useRecursive=true) const; //中序遍历 std::vector&lt;T&gt; inOrder(bool useRecursive=true) const; //后序遍历 std::vector&lt;T&gt; postOrder(bool useRecursive=true) const; //层次遍历 std::vector&lt;T&gt; levelOrder() const; ~BinaryTree();private: struct Node &#123; T data_; Node *lchild_; Node *rchild_; Node(const T&amp; data) : data_(data), lchild_(nullptr), rchild_(nullptr) &#123;std::cout &lt;&lt; \"Node constructor: \" &lt;&lt; data_ &lt;&lt; std::endl;&#125; ~Node() &#123;std::cout &lt;&lt; \"Node destructor: \" &lt;&lt; data_ &lt;&lt; std::endl; &#125; &#125;; void levelOrderInit(const std::vector&lt;T&gt; &amp;array, const T &amp;nullVal); void preOrderInit(const std::vector&lt;T&gt; &amp;array, Node *&amp;root, int &amp;index, const T &amp;nullVal); //xxx_recursive表示递归方式遍历；xxx_loop表示循环方式遍历 void preOrder_recursive(Node *, std::vector&lt;T&gt; &amp;) const; void preOrder_loop(std::vector&lt;T&gt; &amp;) const; void inOrder_recursive(Node *, std::vector&lt;T&gt; &amp;) const; void inOrder_loop(std::vector&lt;T&gt; &amp;) const; void postOrder_recursive(Node *, std::vector&lt;T&gt; &amp;) const; void postOrder_loop(std::vector&lt;T&gt; &amp;) const; void clearTree(Node *node); Node *root_; int size_;&#125;; 构造构造函数1234567891011121314151617181920212223template&lt;class T&gt;BinaryTree&lt;T&gt;::BinaryTree(const std::vector&lt;T&gt; &amp;array, const T&amp; nullVal, ORDER order)&#123; size_ = array.size(); if(!size_) &#123; root_ = nullptr; return; &#125; int index = 0; switch(order) &#123; case LEVELORDER: levelOrderInit(array, nullVal); break; case PREORDER: preOrderInit(array, root_, index, nullVal); break; default: break; &#125;&#125; 层次数组初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445template&lt;class T&gt;void BinaryTree&lt;T&gt;::levelOrderInit(const std::vector&lt;T&gt; &amp;array, const T&amp; nullVal)&#123; root_ = new Node(array[0]); std::queue&lt;Node*&gt; q; q.push(root_); int start = 1; //每一层级节点的个（第二层有2个） int levelNums = 2; while(start &lt; size_) &#123; for(int i = start; i &lt; (start + levelNums) &amp;&amp; i &lt; size_; i += 2) &#123; if(q.empty()) &#123; printf(\"input array not valid\\n\"); return; &#125; //从左到右依次取出上一层的父节点 Node *node = q.front(); q.pop(); const T&amp; lVal = array.at(i); if(lVal != nullVal) &#123; Node *lchild = new Node(lVal); node-&gt;lchild_ = lchild; q.push(lchild); &#125; //最后一个右孩子可能没给出，导致i+1越界，这里判断 if(i + 1 &gt;= size_) break; const T&amp; rVal = array.at(i + 1); if(rVal != nullVal) &#123; Node *rchild = new Node(rVal); node-&gt;rchild_ = rchild; q.push(rchild); &#125; &#125; start += levelNums; //每层节点数都是上一层的两倍，即使是无效值，也必须用nullVal给出 levelNums *= 2; &#125;&#125; 先序数组初始化123456789101112131415161718template &lt;class T&gt;void BinaryTree&lt;T&gt;::preOrderInit(const std::vector&lt;T&gt; &amp;array, Node *&amp;root, int &amp;index, const T &amp;nullVal)&#123; if(index &lt; size_) &#123; const T &amp;curData = array.at(index); if(curData != nullVal) &#123; //构造父 root = new Node(curData); //递归构造左孩子 preOrderInit(array, root-&gt;lchild_, ++index, nullVal); //递归构造右孩子 preOrderInit(array, root-&gt;rchild_, ++index, nullVal); &#125; &#125;&#125; 析构1234567891011121314151617//后序遍历递归删除所有节点//这里应该只能使用后序吧，毕竟要把左右孩子删除，才能删除父嘛template &lt;class T&gt;void BinaryTree&lt;T&gt;::clearTree(Node *node)&#123; if(!node) return; clearTree(node-&gt;lchild_); clearTree(node-&gt;rchild_); delete node;&#125;template &lt;class T&gt;BinaryTree&lt;T&gt;::~BinaryTree()&#123; clearTree(root_);&#125; 遍历下面的几种遍历方式都分了递归和循环两种方式。显然递归方式更简单清晰； 但是有些公司是不允许使用递归的，这样就只能使用循环啦 先序遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::preOrder(bool useRecursive) const&#123; std::vector&lt;T&gt; result; if(useRecursive) preOrder_recursive(root_, result); else preOrder_loop(result); return result;&#125;//递归先序遍历，先访问父，再访问左孩子，再访问右孩子template &lt;class T&gt;void BinaryTree&lt;T&gt;::preOrder_recursive(Node *root, std::vector&lt;T&gt; &amp;result) const&#123; if(!root) return; result.push_back(root-&gt;data_); preOrder_recursive(root-&gt;lchild_, result); preOrder_recursive(root-&gt;rchild_, result);&#125;//循环先序遍历template &lt;class T&gt;void BinaryTree&lt;T&gt;::preOrder_loop(std::vector&lt;T&gt; &amp;result) const&#123; Node *root = root_; std::stack&lt;Node*&gt; stk; while(root || !stk.empty()) &#123; if(root) &#123; result.push_back(root-&gt;data_); stk.push(root); root = root-&gt;lchild_; &#125; else &#123; root = stk.top()-&gt;rchild_; stk.pop(); &#125; &#125;&#125; 中序遍历12345678910111213141516171819202122232425262728293031323334353637383940414243template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::inOrder(bool useRecursive) const&#123; std::vector&lt;T&gt; result; if(useRecursive) inOrder_recursive(root_, result); else inOrder_loop(result); return result;&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::inOrder_recursive(Node *root, std::vector&lt;T&gt; &amp;result) const&#123; if(!root) return; inOrder_recursive(root-&gt;lchild_, result); result.push_back(root-&gt;data_); inOrder_recursive(root-&gt;rchild_, result);&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::inOrder_loop(std::vector&lt;T&gt; &amp;result) const&#123; Node *root = root_; std::stack&lt;Node*&gt; stk; while(root || !stk.empty()) &#123; if(root) &#123; stk.push(root); root = root-&gt;lchild_; &#125; else &#123; Node *tmp = stk.top(); stk.pop(); result.push_back(tmp-&gt;data_); root = tmp-&gt;rchild_; &#125; &#125;&#125; 后序遍历后序遍历的非递归有点难,参考 二叉树递归与非递归遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::postOrder(bool useRecursive) const&#123; std::vector&lt;T&gt; result; if(useRecursive) postOrder_recursive(root_, result); else postOrder_loop(result); return result;&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::postOrder_recursive(Node *root, std::vector&lt;T&gt; &amp;result) const&#123; if(!root) return; postOrder_recursive(root-&gt;lchild_, result); postOrder_recursive(root-&gt;rchild_, result); result.push_back(root-&gt;data_);&#125;template &lt;class T&gt;void BinaryTree&lt;T&gt;::postOrder_loop(std::vector&lt;T&gt; &amp;result) const&#123; std::stack&lt;Node*&gt; stk; stk.push(root_); Node *cur = nullptr, *pre = nullptr; while(!stk.empty()) &#123; cur = stk.top(); if((!cur-&gt;lchild_ &amp;&amp; !cur-&gt;rchild_) || (pre &amp;&amp; (pre == cur-&gt;lchild_ || pre == cur-&gt;rchild_))) &#123; result.push_back(cur-&gt;data_); stk.pop(); pre = cur; &#125; else &#123; if(cur-&gt;rchild_) stk.push(cur-&gt;rchild_); if(cur-&gt;lchild_) stk.push(cur-&gt;lchild_); &#125; &#125;&#125; 层次遍历123456789101112131415161718template &lt;class T&gt;std::vector&lt;T&gt; BinaryTree&lt;T&gt;::levelOrder() const&#123; std::vector&lt;T&gt; result; std::queue&lt;Node*&gt; q; q.push(root_); while(!q.empty()) &#123; Node *t = q.front(); q.pop(); result.push_back(t-&gt;data_); if(t-&gt;lchild_) q.push(t-&gt;lchild_); if(t-&gt;rchild_) q.push(t-&gt;rchild_); &#125; return result;&#125; 测试1234567891011121314151617181920212223242526template &lt;class T&gt;void test(char *desc, std::vector&lt;T&gt; &amp;array)&#123; printf(\"%s\", desc); for(int val : array) printf(\"%d \", val); printf(\"\\n\");&#125;int main()&#123; std::vector&lt;int&gt; array&#123;3, 2, 7, -1, 4, 5, 1&#125;; BinaryTree&lt;int&gt; tree(array, -1); //std::vector&lt;int&gt; array&#123;3, 2, -1, 4, -1, -1, 7, 5, -1, -1, 1&#125;; //BinaryTree&lt;int&gt; tree(array, -1, BinaryTree&lt;int&gt;::PREORDER); std::vector&lt;int&gt; result; test(\"pre order recursive: \", tree.preOrder()); //3 2 4 7 5 1 test(\"pre order loop: \", tree.preOrder(false)); //3 2 4 7 5 1 test(\"in order recursive: \", tree.inOrder()); //2 4 3 5 7 1 test(\"in order loop: \", tree.inOrder(false)); //2 4 3 5 7 1 test(\"post order recursive: \", tree.postOrder()); //4 2 5 1 7 3 test(\"post order loop: \", tree.postOrder(false)); //4 2 5 1 7 3 test(\"level order: \", tree.levelOrder()); //3 2 7 4 5 1 return 0;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"C++中常见数据结构的实现","date":"2018-01-05T12:23:51.000Z","path":"2018/01/05/C++中常见数据结构的实现/","text":"vector说明类似于基本数组，但是内存的回收在类内进行 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106template &lt;class T&gt;class Vector&#123;public: explicit Vector(int size = 0) : size_(size), capacity_(size + SPACE_CAPACITY), array_(new T[capacity_]) &#123; &#125; Vector(const Vector &amp;rhs) :array_(nullptr) &#123; operator=(rhs); &#125; ~Vector() &#123; if(array_) delete []array_; &#125; Vector &amp;operator=(const Vector &amp;rhs) &#123; //判断是否自己赋给自己 if(this != &amp;rhs) &#123; if(array_) delete []array_; size_ = rhs.size_; capacity_ = rhs.capacity_; array_ = new T[capacity_]; for(int i = 0; i &lt; size_; ++i) array_[i] = rhs.array_[i]; //这里用memcpy应该也可以吧 //memcpy(array_, rhs.array_, size_*sizeof(T)) &#125; return *this; &#125; void resize(int newSize) &#123; if(newSize &gt; capacity_) reverse(newSize * 2 + 1); size_ = newSize; &#125; void reverse(int newCapacity) &#123; if(newCapacity &lt; size_) return; T *newArray = new T[newCapacity]; for(int i = 0; i &lt; size_; ++i) newArray[i] = array_[i]; capacity_ = newCapacity; delete []array_; array_ = newArray; &#125; T &amp;operator[](int index) &#123; return array_[index]; &#125; //这里两个[]函数分别返回引用和常引用 const T &amp;operator[](int index) const &#123; return array_[index]; &#125; bool empty() &#123; return size_ == 0; &#125; int size()&#123; return size_;&#125; int capacity() &#123; return capacity_;&#125; void push_back(const T &amp;data) &#123; if(size_ == capacity_) reverse(2 * capacity_ + 1); array_[size_++] = data; &#125; void pop_back()&#123; size_--; &#125; const T &amp;back() const &#123; return array_[size_ - 1]; &#125; typedef T* iterator; typedef const T* const_iterator; iterator begin() &#123; return &amp;array_[0];&#125; const_iterator begin() const &#123; return &amp;array_[0];&#125; iterator end() &#123; return &amp;array_[size_]; &#125; const_iterator end() const &#123; return &amp;array_[size_]; &#125; private: enum &#123; SPACE_CAPACITY = 16 &#125;; T *array_; int size_; int capacity_;&#125;; 链表说明此为双向链表的实现 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193template &lt;class T&gt;class List&#123;private: struct Node &#123; Node(const T &amp;data = T(), Node *p=nullptr, Node *q=nullptr) : data_(data), prev_(p), next_(q) &#123;&#125; T data_; Node *prev_; Node *next_; &#125;;public: class const_iterator &#123; public: const_iterator()&#123;&#125; const T &amp;operator*() const &#123; return retrieve(); &#125; //前置++itr const_iterator &amp;operator++() &#123; currentPos_ = currentPos_-&gt;next_; return *this; &#125; //后置itr++ //注意这里不能返回引用了,因为函数返回后old变量已经不存在 const_iterator operator++(int) &#123; const_iterator old = *this; ++(*this); return old; &#125; bool operator==(const const_iterator &amp;rhs) const &#123; return currentPos_ == rhs.currentPos_;&#125; bool operator!=(const const_iterator &amp;rhs) const &#123; return !(*this == rhs);&#125; protected: const_iterator(Node *pos) : currentPos_(pos) &#123;&#125; T &amp;retrieve() const &#123; return currentPos_-&gt;data_; &#125; Node *currentPos_; friend class List&lt;T&gt;; &#125;; class iterator : public const_iterator &#123; public: iterator()&#123;&#125; T &amp;operator*() &#123; return retrieve(); &#125; const T &amp;operator*() const &#123; return const_iterator::operator*();&#125; iterator &amp;operator++() &#123; currentPos_ = currentPos_-&gt;next_; return *this; &#125; iterator operator++(int) &#123; iterator old = *this; ++(*this); return old; &#125; protected: iterator(Node *pos) : const_iterator(pos) &#123;&#125; friend class List&lt;T&gt;; &#125;;public: List() &#123; init(); &#125; List(const List &amp;rhs) &#123; init(); *this = rhs; &#125; ~List() &#123; clear(); delete header_; delete tail_; &#125; const List &amp;operator=(const List &amp;rhs) &#123; if(this != &amp;rhs) &#123; clear(); for(auto itr = rhs.begin(); itr != rhs.end(); ++itr) push_back(*itr); &#125; return *this; &#125; iterator begin() &#123; return iterator(header_-&gt;next_); &#125; const_iterator begin() const &#123; return const_iterator(header_-&gt;next_); &#125; iterator end() &#123; return iterator(tail_); &#125; const_iterator end() const &#123; return const_iterator(tail_); &#125; int size() &#123; return size_; &#125; bool empty() &#123; return size_ == 0; &#125; void clear() &#123; while(size_) pop_front(); &#125; T &amp;front() &#123; return *begin(); &#125; const T &amp;front() const &#123; return *begin(); &#125; T &amp;back() &#123; return *--end(); &#125; const T &amp;back() const &#123; return *--end(); &#125; void push_front(const T &amp;data) &#123; insert(begin(), data); &#125; void push_back(const T &amp;data) &#123; insert(end(), data);&#125; void pop_front() &#123; erase(begin()); &#125; void pop_back() &#123; erase(--end()); &#125; //insert data before itr iterator insert(iterator itr, const T &amp;data) &#123; Node *p = itr.currentPos_; ++size_; Node *newNode = new Node(data, p-&gt;prev_, p); p-&gt;prev_-&gt;next_ = newNode; p-&gt;prev_ = newNode; return iterator(newNode); //或者简写如下 //return iterator(p-&gt;prev_ = p-&gt;prev_-&gt;next_ = new Node(data, p-&gt;prev_, p)) &#125; iterator erase(iterator itr) &#123; if(itr == end()) return end(); Node *p = itr.currentPos_; iterator retVal(p-&gt;next_); --size_; p-&gt;prev_-&gt;next_ = p-&gt;next_; p-&gt;next_-&gt;prev_ = p-&gt;prev_; delete p; return retVal; &#125; iterator erase(iterator from, iterator to) &#123; for(auto itr = begin; i != to;) itr = erase(itr); return to; &#125; private: Node *header_; Node *tail_; int size_; void init() &#123; header_ = new Node; tail_ = new Node; header_-&gt;next_ = tail_; tail_-&gt;prev_ = header_; size_ = 0; &#125;&#125;; stack说明只能通过top元素操作，基本操作是push(进栈)和pop(出栈)。遵循LIFO(后进先出)原则 实现分别可以通过链表和数组实现，较简单书上没有实现。这里借助之前的Vector类简单实现一下。12345678910111213141516171819202122232425262728293031template &lt;class T&gt;class Stack&#123;public: Stack()&#123; topOfArray_ = -1; &#125; //因为Vector和int都为数值类型，所以理论上析构函数，复制构造函数， //operator=都可以使用默认的，无需显示写出 const T &amp;top() &#123; return stack_[topOfArray_];&#125; void push(const T&amp; data) &#123; stack_[++topOfArray_] = data; &#125; const T&amp; pop() &#123; return stack_[topOfArray_--]; &#125; bool empty() &#123; return topOfArray_ == -1;&#125;private: Vector&lt;T&gt; stack_; int topOfArray_;&#125;;int main()&#123; Stack&lt;int&gt; stack; stack.push(5); stack.push(10); stack.push(3); printf(\"%d\\n\", stack.top()); //3 while(!stack.empty()) printf(\"%d \", stack.pop()); //3 10 5 return 0;&#125; 应用检查代码中的平衡符号如[()]合法，而[(])非法。检查方法如下– 初始化一个空栈，读取字符至文件尾。– 若字符是开放符号，则压栈– 若字符是封闭符号，则如果栈为空则报错，若果栈非空则弹出栈元素，如果不是对应的开放符号，则报错– 如果到文件尾，且栈非空则报错 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//检查是否为一组开闭符号bool isPairSymbol(char left, char right)&#123; return (left == '(' &amp;&amp; right == ')') || (left == '&#123;' &amp;&amp; right == '&#125;') || (left == '&lt;' &amp;&amp; right == '&gt;') || (left == '[' &amp;&amp; right == ']');&#125;//是否开放符号bool isOpenSymbol(char ch)&#123; return ch == '(' || ch == '&#123;' || ch == '&lt;' || ch == '[';&#125;//是否封闭符号bool isCloseSymbol(char ch)&#123; return ch == ')' || ch == '&#125;' || ch == '&gt;' || ch == ']';&#125;//函数功能：检查平衡符号是否合法//入参str：包含平衡符号的字符串//返回值：合法为true，非法为falsebool checkEquSymbol(std::string str)&#123; Stack&lt;char&gt; stack; for(int i = 0; i &lt; str.size(); ++i) &#123; char ch = str[i]; if(isOpenSymbol(ch)) stack.push(ch); else if(isCloseSymbol(ch)) &#123; if(stack.empty()) return false; else if(!isPairSymbol(stack.pop(), ch)) return false; &#125; &#125; return stack.empty();&#125;int main()&#123; printf(\"%d\\n\", checkEquSymbol(\"2esvdf&#123;&#125;&lt;^&amp;&gt;\")); //1 printf(\"%d\\n\", checkEquSymbol(\"3&lt;[&#123;()&#125;]&gt;\")); //1 printf(\"%d\\n\", checkEquSymbol(\"2&lt;12&lt;&gt;\")); //0 printf(\"%d\\n\", checkEquSymbol(\"2&gt;\")); //0 return 0;&#125; 后缀表达式比如一个计算表达式为位[4+5+62]可转换为如下后缀（逆波兰)记法[4 5+6 2+] 求值过程如下： 遇到一个数时压入栈 遇到操作符时从栈中弹出两个数，求得结果再入栈 为简单起见，假设所有数字都是一位，且只有+-*/四则运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//通过操作符返回结果值（简单起见这里就不用工厂模式了）double calc(int num1, int num2, char op)&#123; switch(op) &#123; case '+': return num1 + num2; case '-': return num1 - num2; case '*': return num1 * num2; case '/': return num1 / num2; default: return 0; &#125;&#125;bool isOperator(char ch)&#123; return ch == '+' || ch == '-' || ch == '*' || ch == '/';&#125;//函数功能：计算表达式的数值结果，其中表达式为逆波兰记法，数字为1位int calcExp(std::string str)&#123; Stack&lt;double&gt; stack; for(int i = 0; i &lt; str.size(); ++i) &#123; char ch = str[i]; if(isOperator(ch)) &#123; //这里应当判空 double num1 = stack.pop(), num2 = stack.pop(); stack.push(calc(num1, num2, ch)); &#125; else stack.push(ch - '0'); &#125; return stack.pop();&#125;int main()&#123; printf(\"%d\\n\", calcExp(\"6523+8*+3+*\")); //288 return 0;&#125; 从中缀转换为后缀表达式作用：将一个标准形式的（中缀）表达式，转换成上面提到的后缀表达式 为了简化问题假设只包含+*()三种操作符 求值过程如下 读到一个操作数时立即输出 读到一个右括号’)’时，弹出栈元素，直到遇到一个对应的左括号。且左括号不输出 读到其他字符’+’,’*’,’(‘时，弹出栈元素直到发现优先级更低的；并且不能弹出’(‘元素。弹出工作完成之后，再将当前操作符入栈 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//运算符的优先级int priority(char op)&#123; switch(op) &#123; case '+': return 1; case '*': return 2; case '(': case ')': return 999; default: return 0; &#125;&#125;//函数功能：中缀表达式到后缀表达式//入参str：中缀表达式，其中只包含+*()三种运算符，其他数字用字母代替void infixToPostfix(std::string str)&#123; Stack&lt;char&gt; stack; char op; for(int i = 0; i &lt; str.size(); ++i) &#123; char ch = str[i]; if(ch == '+' || ch == '*' || ch == '(') &#123; //1、栈非空 //2、栈顶元素不是'(' //3、栈顶元素优先级不小于当前元素优先级 while(!stack.empty() &amp;&amp; stack.top() != '(' &amp;&amp; priority(stack.top()) &gt;= priority(ch)) printf(\"%c\", stack.pop()); //当前操作符入栈 stack.push(ch); &#125; else if(ch == ')') &#123; while(!stack.empty()) &#123; //出栈直到遇到'('，且'('不输出 op = stack.pop(); if(op != '(') printf(\"%c\", op); else break; &#125; &#125; else &#123; //其他即为操作数，立即输出 printf(\"%c\", ch); &#125; &#125; while(!stack.empty()) printf(\"%c\", stack.pop());&#125;int main()&#123; infixToPostfix(\"a+b*c+(d*e+f)*g\"); //abc*+de*f+g*+ return 0;&#125; 函数调用queue说明队列（queue）也是一种表，基本操作有 enqueue(入队)，在表的末端（队尾）插入一个元素 dequeue(出队)，删除并返回表的开头（队头）元素 实现链表实现较简单1234567891011121314151617181920212223242526template &lt;class T&gt;class Queue&#123;public: Queue()&#123;&#125; void enqueue(const T &amp;data) &#123; queue_.push_back(data); &#125; const T &amp;dequeue() &#123; const T &amp;data = queue_.front(); queue_.pop_front(); return data; &#125; bool empty()&#123; return queue_.empty(); &#125;private: List&lt;T&gt; queue_;&#125;;int main()&#123; Queue&lt;int&gt; queue; queue.enqueue(15); queue.enqueue(4); printf(\"%d\\n\",queue.dequeue());//15 return 0;&#125; 数组实现需要考虑循环数组的问题 二叉树参考:二叉树的C++实现 二叉查找树说明对于每个节点X，其左子树节点的值都小于X对应的值，右子树节点的值都大于X对应的值 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;iostream&gt;#include &lt;stdio.h&gt;template &lt;typename T&gt;class BinarySearchTree&#123;public: BinarySearchTree() : root_(nullptr) &#123;&#125; BinarySearchTree(const BinarySearchTree &amp;rhs) &#123; root_ = clone(rhs.root_); &#125; ~BinarySearchTree() &#123; makeEmpty(); &#125; const T &amp;findMin() const &#123; BinaryNode *t = findMin(root_); return t ? t-&gt;element_ : T(); &#125; const T &amp;findMax() const &#123; BinaryNode *t = findMax(root_); return t ? t-&gt;element_ : T(); &#125; bool contains(const T &amp;x) const &#123; return contains(x, root_); &#125; bool isEmpty() const &#123; return root_ == nullptr; &#125; void printTree() const &#123; printTree(root_); &#125; void makeEmpty() &#123; makeEmpty(root_); &#125; void insert(const T &amp;x) &#123; insert(x, root_); &#125; void remove(const T &amp;x) &#123; remove(x, root_); &#125; const BinarySearchTree &amp;operator=(const BinarySearchTree &amp;rhs) &#123; if(this != &amp;rhs) &#123; makeEmpty(); root_ = clone(rhs.root_); &#125; return *this; &#125;private: struct BinaryNode &#123; T element_; BinaryNode *left_; BinaryNode *right_; BinaryNode(const T &amp;ele, BinaryNode *l, BinaryNode *r) : element_(ele), left_(l), right_(r) &#123;&#125; &#125;; BinaryNode *root_; BinaryNode *findMin(BinaryNode *t) const &#123; if(!t) return nullptr; if(!t-&gt;left_) return t; return findMin(t-&gt;left_); &#125; BinaryNode *findMax(BinaryNode *t) const &#123; if(t) &#123; while(t-&gt;right_) t = t-&gt;right_; &#125; return t; &#125; bool contains(const T &amp;x, BinaryNode *t) const &#123; if(!t) return false; else if(x &lt; t-&gt;element_) return contains(x, t-&gt;left_); else if(t-&gt;element_ &lt; x) return contains(x, t-&gt;right_); return true; //match &#125; void insert(const T &amp;x, BinaryNode *&amp;t) const &#123; if(!t) t = new BinaryNode(x, nullptr, nullptr); else if(x &lt; t-&gt;element_) insert(x, t-&gt;left_); else if(t-&gt;element_ &lt; x) insert(x, t-&gt;right_); else std::cout &lt;&lt; \"already has node :\" &lt;&lt; x &lt;&lt; std::endl; &#125; void remove(const T &amp;x, BinaryNode *&amp;t) const &#123; if(!t) return; // can not find item else if(x &lt; t-&gt;element_) remove(x, t-&gt;left_); else if(t-&gt;element_ &lt; x) remove(x, t-&gt;right_); else if(t-&gt;left_ &amp;&amp; t-&gt;right_) //has two children &#123; //策略：将当前节点的值设为右子树最小节点的值 //并删除右子树最小节点 t-&gt;element_ = findMin(t-&gt;right_)-&gt;element_; remove(t-&gt;element_, t-&gt;right_); &#125; else &#123; //没有或只有一个子节点的情况 //若t没有子节点，删除后t置为空 //若t只有右子节点，删除后t置为其右子节点 //若t只有左子节点，删除后t置为其左子节点 BinaryNode *oldNode = t; t = t-&gt;left_ ? t-&gt;left_ : t-&gt;right_; delete oldNode; &#125; &#125; void makeEmpty(BinaryNode *&amp;t) &#123; if(t) &#123; makeEmpty(t-&gt;left_); makeEmpty(t-&gt;right_); delete t; &#125; t = nullptr; &#125; void printTree(BinaryNode *t) const &#123; if(!t) return; printTree(t-&gt;left_); std::cout &lt;&lt; t-&gt;element_ &lt;&lt; std::endl; printTree(t-&gt;right_); &#125; BinaryNode *clone(BinaryNode *t) &#123; if(!t) return nullptr; return new BinaryNode(t-&gt;element_, clone(t-&gt;left_), clone(t-&gt;right_)); &#125;&#125;;int main()&#123; BinarySearchTree&lt;int&gt; btree; btree.insert(5); btree.insert(3); btree.insert(6); btree.insert(2); btree.insert(1); btree.insert(7); btree.printTree(); btree.remove(2); auto tree2 = btree; tree2.printTree(); return 0;&#125; 散列说明以常数平均时间执行插入、删除和查找的技术。 分离链接法将所有散列到同一个值的所有元素保存到一个链表中。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;string&gt;//判断素数bool isPrime(int num)&#123; if(num &lt;= 1) return false; else if(num == 2) return true; for(int i = 2; i &lt;= num / 2; ++i) if(num % i == 0) return false; return true;&#125;//这里设包含自身，即如果num为101则返回101int nextPrime(int num)&#123; while(!isPrime(num)) num++; return num;&#125;//使用书中第三种hash方法int hash(const std::string &amp;key)&#123; int hashVal = 0; for(const char &amp;c : key) hashVal = 37 * hashVal + c; return hashVal;&#125;template &lt;typename HashedObj&gt;class HashTable&#123;public: HashTable(int size = 101) : currentSize_() &#123; theLists_.resize(nextPrime(size)); &#125; bool contains(const HashedObj &amp;x) const; void makeEmpty(); bool insert(const HashedObj &amp;x); bool remove(const HashedObj &amp;x);private: std::vector&lt;std::list&lt;HashedObj&gt;&gt; theLists_; int currentSize_; void rehash(); int myhash(const HashedObj &amp;x) const;&#125;;template &lt;typename HashedObj&gt;int HashTable&lt;HashedObj&gt;::myhash(const HashedObj &amp;x) const&#123; int hashVal = hash(x); hashVal %= theLists_.size(); if(hashVal &lt; 0) hashVal += theLists_.size(); return hashVal;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::contains(const HashedObj &amp;x) const&#123; const std::list&lt;HashedObj&gt; &amp;lst = theLists_[myhash(x)]; return find(lst.begin(), lst.end(), x) != lst.end();&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::makeEmpty()&#123; for(auto &amp;lst : theLists_) lst.clear();&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::insert(const HashedObj &amp;x)&#123; std::list&lt;HashedObj&gt; &amp;lst = theLists_[myhash(x)]; if(find(lst.begin(), lst.end(), x) != lst.end()) return false; lst.push_back(x); if(++currentSize_ &gt; theLists_.size()) rehash();&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::remove(const HashedObj &amp;x)&#123; std::list&lt;HashedObj&gt; &amp;lst = theLists_[myhash(x)]; auto itr = find(lst.begin(), lst.end(), x); if(itr == lst.end()) return false; //not found lst.erase(itr); --currentSize_; return true;&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::rehash()&#123; auto oldLists = theLists_; theLists_.resize(nextPrime(2 * oldLists.size())); for(auto &amp;lst : theLists_) lst.clear(); currentSize_ = 0; for(const auto &amp;lst : oldLists) &#123; auto itr = lst.begin(); while(itr != lst.end()) insert(*itr++); &#125;&#125; 测试1234567891011121314151617181920212223242526272829class Employee&#123;public: explicit Employee(std::string name=\"\") : name_(name) &#123;&#125; const std::string &amp;getName() const &#123; return name_;&#125; bool operator==(const Employee &amp;rhs) const &#123; return getName() == rhs.getName(); &#125; bool operator!=(const Employee &amp;rhs) const &#123; return !(*this == rhs); &#125;private: std::string name_; double salary_;&#125;;int hash(const Employee &amp;x)&#123; return hash(x.getName());&#125;int main()&#123; HashTable&lt;Employee&gt; htable; Employee ea(\"kdb\"); Employee eb(\"fff\"); Employee ec(\"ddd\"); htable.insert(ea); htable.insert(eb); htable.insert(ec); printf(\"%d\\n\", htable.contains(ea));&#125; 探测散列表方法解决冲突的办法：当冲突发生时，尝试选择另外一个单元，直到找到另外一个单元。 即通过h0(x),h1(x)…一依次试选，其中hi(x) = (hash(x) + f(i)) mod TableSize,且f(0) = 0。 这里就有线性探测f(i) = i，和平方探测f(i) = i*i两种啦。书中以平方探测举例 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//平方探测法template &lt;typename HashedObj&gt;class HashTable&#123;public: explicit HashTable(int size = 101); enum EntryType &#123;ACTIVE, EMPTY, DELETED&#125;; bool contains(const HashedObj &amp;x) const; void makeEmpty(); bool insert(const HashedObj &amp;x); bool remove(const HashedObj &amp;x);private: struct HashEntry &#123; HashedObj element_; EntryType info_; HashEntry(const HashedObj &amp;e=HashedObj(), EntryType type=EMPTY) : element_(e), info_(type) &#123;&#125; &#125;; std::vector&lt;HashEntry&gt; array_; int currentSize_; int findPos(const HashedObj &amp;x) const; bool isActive(int pos) const; void rehash(); int myhash(const HashedObj &amp;x) const;&#125;;template &lt;typename HashedObj&gt;HashTable&lt;HashedObj&gt;::HashTable(int size) : array_(nextPrime(size))&#123; makeEmpty();&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::makeEmpty()&#123; currentSize_ = 0; for(auto &amp;entry : array_) entry.info_ = EMPTY;&#125;template&lt;typename HashedObj&gt;int HashTable&lt;HashedObj&gt;::myhash(const HashedObj &amp;x) const&#123; int hashVal = hash(x); hashVal %= array_.size(); if(hashVal &lt; 0) hashVal += array_.size(); return hashVal;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::contains(const HashedObj &amp;x) const&#123; return isActive(findPos(x));&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::isActive(int pos) const&#123; return array_[pos].info_ == ACTIVE;&#125;template &lt;typename HashedObj&gt;int HashTable&lt;HashedObj&gt;::findPos(const HashedObj &amp;x) const&#123; int offset = 1; int currentPos = myhash(x); while(array_[currentPos].info_ != EMPTY &amp;&amp; array_[currentPos].element_ != x) &#123; //f(i) = f(i - 1) + 2i - 1 currentPos += offset; offset += 2; if(currentPos &gt;= array_.size()) currentPos -= array_.size(); &#125; return currentPos;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::insert(const HashedObj &amp;x)&#123; int pos = findPos(x); if(isActive(pos)) return false; array_[pos] = HashEntry(x, ACTIVE); //这里注意大于表大小一半的时候，就需要rehash了 if(++currentSize_ &gt; array_.size()/2) rehash(); return true;&#125;template &lt;typename HashedObj&gt;bool HashTable&lt;HashedObj&gt;::remove(const HashedObj &amp;x)&#123; int pos = findPos(x); if(!isActive(pos)) return false; array_[pos].info = DELETED; return true;&#125;template &lt;typename HashedObj&gt;void HashTable&lt;HashedObj&gt;::rehash()&#123; std::vector&lt;HashEntry&gt; oldArray = array_; array_.resize(nextPrime(2 * array_.size())); for(auto &amp;entry : array_) entry.info_ = EMPTY; currentSize_ = 0; for(auto &amp;entry : oldArray) &#123; if(entry.info_ = ACTIVE) insert(entry.element_); &#125;&#125; 测试与分离链接法相同 优先队列（堆）一种特殊的队列，包括以下操作 insert，类似于入队操作 deleteMin，找出，返回，删除队列中的最小元素（或者最大元素） 实现通过binary heap(二叉堆)实现。特点 通过数组表示的完全二叉树 首元素索引为1，当节点索引为i时，左儿子索引为2i，右儿子索引为2i+1,父节点索引i/2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;exception&gt;template &lt;typename T&gt;class BinaryHeap&#123;public: BinaryHeap(int capacity = 100); BinaryHeap(const std::vector&lt;T&gt; &amp;items); bool empty() const &#123; return currentSize_ == 0;&#125; const T &amp;findMin() const; void insert(const T &amp;x); void deleteMin(); void deleteMin(T &amp; minItem); void makeEmpty();private: int currentSize_; std::vector&lt;T&gt; array_; void buildHeap(); void percolateDown(int hole);&#125;;template &lt;typename T&gt;BinaryHeap&lt;T&gt;::BinaryHeap(int capacity) : array_(capacity), currentSize_(0) &#123;&#125;template &lt;typename T&gt;BinaryHeap&lt;T&gt;::BinaryHeap(const std::vector&lt;T&gt; &amp;items) : array_(items.size() + 10), currentSize_(items.size())&#123; for(int i = 0; i &lt; items.size(); ++i) array_[i + 1] = items[i]; buildHeap();&#125;template &lt;typename T&gt;const T &amp;BinaryHeap&lt;T&gt;::findMin() const&#123; if(empty()) throw std::underflow_error(\"under flow\"); return array_[1];&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::insert(const T &amp;x)&#123; if(currentSize_ == array_.size() - 1) array_.resize(array_.size() * 2); //percolate up 上滤 int hole = ++currentSize_; //array[hole/2]为父节点的值 //如果当前节点的值小于父节点的值，则交换 for(; hole &gt; 1 &amp;&amp; x &lt; array_[hole / 2]; hole /= 2) array_[hole] = array_[hole / 2]; array_[hole] = x;&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::deleteMin()&#123; if(empty()) throw std::underflow_error(\"under flow\"); array_[1] = array_[currentSize_--]; percolateDown(1);&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::deleteMin(T &amp;minItem)&#123; if(empty()) throw std::underflow_error(\"under flow\"); minItem = array_[1]; array_[1] = array_[currentSize_--]; percolateDown(1);&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::makeEmpty()&#123; currentSize_ = 0;&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::buildHeap()&#123; for(int i = currentSize_ / 2; i &gt;= 1; --i) percolateDown(i);&#125;template &lt;typename T&gt;void BinaryHeap&lt;T&gt;::percolateDown(int hole)&#123; T tmp = array_[hole]; int child; for(; hole * 2 &lt;= currentSize_; hole = child) &#123; //左子节点为 2*hole child = hole * 2; //右子节点为2*hole+1，注意要先判断右子节点是否存在 if(child != currentSize_ &amp;&amp; array_[child + 1] &lt; array_[child]) ++child; if(array_[child] &lt; tmp) array_[hole] = array_[child]; else break; &#125; array_[hole] = tmp;&#125; 测试1234567891011121314151617int main()&#123; std::vector&lt;int&gt; array&#123;3, 1&#125;; BinaryHeap&lt;int&gt; heap(array); printf(\"min:%d\\n\", heap.findMin()); heap.deleteMin(); printf(\"min:%d\\n\", heap.findMin()); heap.deleteMin(); try &#123; heap.deleteMin(); &#125; catch(std::underflow_error &amp;e) &#123; printf(\"catch exception :%s\\n\", e.what()); &#125;&#125; 不相交集类说明基本的想法是使用数来表示每一个集合，因为树上的每一个元素都有相同的根，根即可以用来命名所在的集合。假设树被非显式地存储在数组中，数组的每个成员s[i]表示元素i的父亲 初始令每个数组成员值为-1，比如以下8个成员的数组0 1 2 3 4 5 6 7-1 -1 -1 -1 -1 -1 -1 -1 union(x, y)操作则令s[y] = x，比如union(4,5),union(6,7),union(4,6)之后0 1 2 3 4 5 6 7-1 -1 -1 -1 -1 4 4 6 find(x)操作返回包含x的树的根完成。操作花费时间与x节点的深度成正比。比如find(7)-&gt;find(6)-&gt;find(4)=-1得7所在树的根节点为4 实现1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;vector&gt;class DisjSets&#123;public: explicit DisjSets(int numElements); int find(int x) const; int find(int x); void unionSets(int root1, int root2);private: std::vector&lt;int&gt; arr_;&#125;;DisjSets::DisjSets(int numElements) : arr_(numElements)&#123; for(int i = 0; i &lt; numElements; ++i) arr_[i] = -1;&#125;int DisjSets::find(int x) const&#123; if(arr_[x] &lt; 0) return x; return find(arr_[x]);&#125;void DisjSets::unionSets(int root1, int root2)&#123; arr_[root2] = root1;&#125;int main()&#123; DisjSets dset(8); dset.unionSets(4, 5); dset.unionSets(6, 7); dset.unionSets(4, 6); printf(\"%d\\n\", dset.find(7));&#125; 灵巧求并算法 按大小求并，使得总是较小的树成为较大的树的子树 基本思想是让每个根的数组元素，包含他的树的大小的负值（初始时数组元素都为-1），书中没有给出算法仅需修改union算法即可，find无需修改1234567891011121314151617void DisjSets::unionSets(int root1, int root2)&#123; //root2对应的树的size更小一些 if(-arr_[root1] &gt;= -arr_[root2]) &#123; //root1的size加上root2的size arr_[root1] += arr_[root2]; //将root2对应的根节点设为root1 arr_[root2] = root1; &#125; else //root1对应的树的size更小一些 &#123; //root1的size加上root2的size arr_[root2] += arr_[root1]; //将root2对应的根节点设为root1 arr_[root1] = root2; &#125;&#125; 例子123456索引 0 1 2 3 4 5 6 7初始 -1 -1 -1 -1 -1 -1 -1 -1union(4, 5)后 -1 -1 -1 -1 -2 4 -1 -1union(6, 7)后 -1 -1 -1 -1 -2 4 -2 6union(4, 6)后 -1 -1 -1 -1 -4 4 4 6union(3, 4)后 -1 -1 -1 4 -5 4 4 6 按高度求并，跟踪每棵树的高度而不是大小，使得浅的树成为深的树的子树数组每个项存储高度的负值减去1。初始时所有项都是-1，表示高度为01234567891011void DisjSets::unionSets(int roo1, int root2)&#123; if(arr_[root2] &lt; arr_[root1]) //-a[root1]&lt;-a[root2] root2 is deeper arr_[root1] = root2; //Make root2 new root else &#123; if(arr_[root2] == arr_[root1]) arr_[root1]--; //Update height if same arr_[root2] = root1; //Make root1 new root &#125;&#125; 例子123456索引 0 1 2 3 4 5 6 7初始 -1 -1 -1 -1 -1 -1 -1 -1union(4, 5)后 -1 -1 -1 -1 -2 4 -1 -1union(6, 7)后 -1 -1 -1 -1 -2 4 -2 6union(4, 6)后 -1 -1 -1 -1 -3 4 4 6union(3, 4)后 -1 -1 -1 4 -3 4 4 6 路径压缩在依次find操作期间执行，压缩的效果是从x到根的路径上的每个节点都使他的父节点变成根需要注意的是路径压缩与按大小求并完全兼容，而与按高度求并不完全兼容，因为路径压缩可以改变树的高度123456int DisjSets::find(int x)&#123; if(arr_[x] &lt; 0) return x; return arr_[x] = find(arr_[x]);&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"常见排序算法C++实现","date":"2017-12-30T09:23:51.000Z","path":"2017/12/30/常见排序算法C++实现/","text":"先写出简单的交换两个值的swap函数123456void swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125; 各种排序算法的原理及实现冒泡排序原理已升序为例，依次比较相邻两个数，大数放后。则一轮排序后最后一个值已为最大值。此时再以同样的方法比较前(size - 1)个数。 实现1234567891011121314151617//冒泡排序void bubbleSort(int *array, int size)&#123; for(int i = 0; i &lt; size - 1; ++i) &#123; int swapped = false; for(int j = 0; j &lt; size - i - 1; ++j) &#123; if(array[j] &gt; array[j+1])&#123; swap(array[j], array[j + 1]); swapped = true; &#125; &#125; if(!swapped) break; &#125;&#125; 说明： 此为升序排列，若要降序，则将{array[j] &gt; array[j+1]}改为{array[j] &lt; array[j+1]}即可 swapped标志量的说明：如果该标志量为false，表示某一次循环，每一个a[j]都小于等于a[j + 1]，即已经是排序好的，所以跳出循环 鸡尾酒排序原理冒泡排序的改进，进行双向排序，大数往后放，小数往前放（像摇晃的鸡尾酒） 实现12345678910111213141516//鸡尾酒排序void cocktailSort(int *array, int size)&#123; int begin = 0, end = size - 1; while(begin &lt; end) &#123; for(int i = begin; i &lt; end; ++i) if(array[i] &gt; array[i + 1]) swap(array[i], array[i + 1]); --end;//最后一个已排序好 for(int i = end; i &gt; begin; --i) if(array[i] &lt; array[i - 1]) swap(array[i - 1], array[i]); ++begin;//第一个位置已排序好 &#125;&#125; 选择排序原理已升序为例 第一次从整个数组中选择最小的一个，与第1个值交换，这时第一个值已排序好 第二次从第一个之外剩下的数中选择最小的与第二个值交换，这时第二个值也排序好依次类推 实现12345678910111213141516//选择排序void selectSort(int *array, int size)&#123; for(int i = 0; i &lt; size - 1; ++i) &#123; int minIndex = i; //前i个数已排序好，而第i个值是最小基准值，所以从i + 1开始 for(int j = i + 1; j &lt; size; ++j) &#123; if(array[j] &lt; array[minIndex]) minIndex = j; &#125; if(minIndex != i) swap(array[i], array[minIndex]); &#125;&#125; 直接插入排序原理将原数组想象分为两部分，第一部分是已排序好的，第二部分是乱序的。 每次从乱序的部分取出第一个值，在已排序的部分找出一个合适的位置插入进去。 其中，第一次排序排序时，已排序的部分为一个值 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344//直接插入排序：方法1void insertSort1(int *array, int size)&#123; //未排序的部分，从1开始往后遍历 for(int i = 1; i &lt; size; ++i) &#123; //从未排序的部分取出第一个，为待比较的值 int curData = array[i]; //在第一部分中插入的索引 int insertIndex = i; //已排序的部分为前i个值 for(int j = 0; j &lt; i; ++j) &#123; if(array[j] &gt; curData) &#123; insertIndex = j; break; &#125; &#125; //第一部分从最后一个位置，到待插入的位置，统统向后移一个位置 for(int j = i; j &gt; insertIndex; --j) array[j] = array[j - 1]; //将待比较的值插入 array[insertIndex] = curData; &#125;&#125;//第一种方法稍微有点啰嗦，可以更简略一些//直接插入排序：方法2void insertSort2(int *array, int size)&#123; //未排序的部分，从1开始往后遍历 for(int i = 1; i &lt; size; ++i) &#123; //从未排序的部分取出第一个，为待比较的值 int curData = array[i]; //在第一部分中插入的索引 int j = i; //从已排序部分的最后一个往前遍历，若比标准值大，则往后移一个 for(j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; curData; --j) array[j + 1] = array[j]; array[j + 1] = curData; &#125;&#125; 归并排序原理将数组的排序拆分成小的有序数组的合并。有点抽象，举个例子 原数组有8个无序值-&gt;拆分成2组，每组4个 -&gt; 拆分成4组，每组两个 -&gt; 拆分成8组，每组1个成员。 此时每个组都是包含一个成员的有序数组，将1,2个有序组合并成2个成员的有序组A， 将第3,4个有序组合并成2个成员的有序组B，再将有序组A,B合并，如此返回 实现12345678910111213141516171819202122232425262728293031323334353637//归并排序//将起，中，止范围的数组分为两部分，将这两部分合并void merge(int *array, int p, int q, int r)&#123; //第一部分的起止 int begin1 = p, end1 = q; //第二部分的起止 int begin2 = q + 1, end2 = r; int k = 0; //临时数组，存放p到r之间排序好的数组 int *temp = new int[r - p + 1]; while(begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123; if(array[begin1] &lt; array[begin2]) temp[k++] = array[begin1++]; else temp[k++] = array[begin2++]; &#125; while(begin1 &lt;= end1) temp[k++] = array[begin1++]; while(begin2 &lt;= end2) temp[k++] = array[begin2++]; for(int i = 0; i &lt; k; ++i) array[p + i] = temp[i]; delete []temp;&#125;void mergeSort(int *array, int begin, int end)&#123; if(begin &lt; end) &#123; int mid = (begin + end)/2; mergeSort(array, begin, mid); mergeSort(array, mid + 1, end); printf(\"begin:%d, mid:%d, end:%d\\n\", begin, mid, end); merge(array, begin, mid, end); &#125;&#125; 原数组为{9, 3, 1, 7, 2, 5, 4, 10}，上述打印如下1234567begin:0, mid:0, end:1begin:2, mid:2, end:3begin:0, mid:1, end:3begin:4, mid:4, end:5begin:6, mid:6, end:7begin:4, mid:5, end:7begin:0, mid:3, end:7 可以看到大致的归并过程 优化上述在merge函数中每次去new,delete数组是非常耗时的，可以考虑在排序之前new好一个大数组，排序之后再delete一次就行了。 123456789101112131415161718192021222324252627282930313233343536373839//归并排序-临时数组优化void merge(int *array, int p, int q, int r, int *temp)&#123; //第一部分的起止 int begin1 = p, end1 = q; //第二部分的起止 int begin2 = q + 1, end2 = r; int k = 0; while(begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123; if(array[begin1] &lt; array[begin2]) temp[k++] = array[begin1++]; else temp[k++] = array[begin2++]; &#125; while(begin1 &lt;= end1) temp[k++] = array[begin1++]; while(begin2 &lt;= end2) temp[k++] = array[begin2++]; for(int i = 0; i &lt; k; ++i) array[p + i] = temp[i];&#125;void mergeSort(int *array, int begin, int end, int *temp)&#123; if(begin &lt; end) &#123; int mid = (begin + end)/2; mergeSort(array, begin, mid, temp); mergeSort(array, mid + 1, end, temp); merge(array, begin, mid, end, temp); &#125;&#125;void mergeSort(int *array, int size)&#123; int *temp = new int[size]; mergeSort(array, 0, size - 1, temp); delete []temp;&#125; 不用递归实际上递归会非常耗时的，网上的例子都是使用递归的。自己想了一下，可不可以这样呢： 还是假设数组长度为8 第一轮，待排序子数组长度都为1。(1,2),(3,4),(5,6),(7,8)分别合并。 第二轮，待排序子数组长度都为2。((1,2),(3,4)),((5,6),(7,8))分别合并。 第三轮，待排序子数组长度为4。这时只需合并((1,2,3,4),(5,6,7,8)) 下面来实现一下 123456789101112131415161718192021222324void mergeSort3(int *array, int size)&#123; //每个已排序子数组的大小 int gap = 1; int *temp = new int[size]; //循环，直到分成只有两个数组了 while(gap &lt; size) &#123; for(int i = 0; i &lt; size; i += gap*2)&#123; int begin = i, mid = i + gap - 1, end = std::min(size - 1, i + gap*2 -1); //如果中间值已经超过size，则最后一个数组已不需合并 //比如数组长度为11，begin为8，mid为11，end为15 //则(11到15)的数组已不在范围 if(mid &gt;= size - 1) continue; merge(array, begin, mid, end, temp); printf(\"begin:%d, mid:%d, end:%d\\n\", begin, mid, end); &#125; gap *= 2; &#125; delete []temp;&#125; 以8个成员的数组为例，输出如下，可参考排序的过程1234567begin:0, mid:0, end:1begin:2, mid:2, end:3begin:4, mid:4, end:5begin:6, mid:6, end:7begin:0, mid:1, end:3begin:4, mid:5, end:7begin:0, mid:3, end:7 直观上还是比较好理解这种排序的思想的，感觉就是没有分治和归并的过程了。 直接以2的次方的间隔的数组进行合并排序，类似于希尔排序了。至于具体性能如何，后面再统一讨论。 引申：将n个已排序的数组合并成一个有序数组注：不能使用std的list等类型 先定义一些初始化的值，假设需要合并8个有序数组12345678910111213141516171819int array1[] = &#123;1, 3, 5&#125;;int array2[] = &#123;2, 4, 7, 9&#125;;int array3[] = &#123;8, 10, 11, 19, 23, 56&#125;;int array4[] = &#123;0, 3&#125;;int array5[] = &#123;13&#125;;int array6[] = &#123;32, 42, 52, 79, 86, 111, 222, 333&#125;;int array7[] = &#123;23, 25, 27&#125;;int array8[] = &#123;-10, -1, 7, 10&#125;;//存放n个数组的数组，因为每个数组大小不一定一样，所以不能使用2维数组int *arrays[] = &#123;array1, array2, array3, array4, array5, array6, array7, array8&#125;;//存放每个数组size的数组int sizes[] = &#123;sizeof(array1)/sizeof(int), sizeof(array2)/sizeof(int), sizeof(array3)/sizeof(int), sizeof(array4)/sizeof(int), sizeof(array5)/sizeof(int), sizeof(array6)/sizeof(int), sizeof(array7)/sizeof(int), sizeof(array8)/sizeof(int) &#125;;//数组的个数int size = sizeof(arrays)/sizeof(int*); 方法一：两两合并即第一个和第二个合并，合并好的大数组和第三个合并，以此类推。 这种方法比较好想，但是也比较效率低。就和排序的时候第1,2个数先排序， 再和第三个数排序一样。 实现123456789101112131415161718192021222324252627282930313233343536373839404142//函数功能：合并两个已排序数组//其中array2足够大，可以存放两个数组中的全部元素。void mergeTwoArray(int *array1, int size1, int *array2, int size2)&#123; int i = 0, j = 0, k = 0; int *temp = new int[size1 + size2]; while(i &lt; size1 &amp;&amp; j &lt; size2) &#123; if(array1[i] &lt; array2[j]) temp[k++] = array1[i++]; else temp[k++] = array2[j++]; &#125; while(i &lt; size1) temp[k++] = array1[i++]; while(j &lt; size2) temp[k++] = array2[j++]; for(int i = 0; i &lt; k; ++i) array2[i] = temp[i]; delete []temp;&#125;void mergeArrays(int *arrays[], int size, int sizes[])&#123; int totalSize = 0; for(int i = 0; i &lt; size; ++i) &#123; totalSize += sizes[i]; &#125; int *totalArray = new int[totalSize]; int currentSize = 0; for(int i = 0; i &lt; size; ++i) &#123; mergeTwoArray(arrays[i], sizes[i], totalArray, currentSize); currentSize += sizes[i]; &#125; for(int i = 0; i &lt; totalSize; ++i) printf(\"%d \", totalArray[i]); delete []totalArray;&#125; 其中合并两个数组的方法可以优化成如下12345678910111213141516171819202122//反过来想，从最后一个元素往前遍历//参考http://blog.csdn.net/f81892461/article/details/8583983void mergeTwoArray(int *array1, int size1, int *array2, int size2)&#123; //第一个数组的最后一个元素 int i = size1 - 1; //第二个数组的最后一个元素 int j = size2 - 1; //合成新数组的最后一个元素 int k = size1 + size2 - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; //从后往前遍历 if(array1[i] &gt; array2[j]) array2[k--] = array1[i--]; else array2[k--] = array2[j--]; &#125; while(i &gt;= 0) array2[k--] = array1[i--]; //注意这里不需要再遍历array2中的元素，因为他们已经在array2中&#125; 方法二：利用分治归并的思想网上有例子是用链表做的 http://www.cnblogs.com/TenosDoIt/p/3673188.html https://leetcode.com/problems/merge-k-sorted-lists/ 123456789101112131415161718192021222324252627//合并两个有序链表（这里设head节点不是数据节点）void merge2list(Node *head1, Node *head2)&#123; if(!head1 || !head1-&gt;next_ || !head2 || !head2-&gt;next_) return; Node node(0), *tail = &amp;node; Node *p = head1-&gt;next_, *q = head2-&gt;next_; while(p &amp;&amp; q) &#123; if(p-&gt;key_ &lt;= q-&gt;key_) &#123; tail-&gt;next_ = p; p = p-&gt;next_; &#125; else &#123; tail-&gt;next_ = q; q = q-&gt;next_; &#125; tail = tail-&gt;next_; &#125; if(p) tail-&gt;next_ = p; else if(q) tail-&gt;next_ = q; head1-&gt;next_ = node.next_;&#125; 然后按照下面的思路(以8个链表为例) L0和L1合并到L0，L2和L3合并到L2，L4和L5合并到L4，L6和L7合并到L6 再将L0和L2合并到L0，L4和L6合并到L4 再将L0和L4合并到L012345678910111213//结果保存在lists[0]中void mergeKList(std::vector&lt;Node*&gt; &amp;lists)&#123; int size = lists.size(); int gap = 1; while(gap &lt; size) &#123; for(int i = 0; i &lt; size - gap; i += 2 * gap)&#123; merge2list(lists[i], lists[i + gap]); &#125; gap *= 2; &#125;&#125; 用数组应该也能做，只是每个数组的空间是固定的，不是太好扩充。 快速排序原理依然是分治的思想 将原数组分为3部分，(begin, X - 1), X, (X + 1, end)。其中(begin, X - 1)部分的每个值都比X对应的值要小，(X + 1, end)对应的每个值都比X对应的值要大 对左右两部分数组再进行如上类似操作，进行分治 关键的问题是要找到X的位置，分治还是比较简单的。 对了，好像快速排序是各种库里默认的排序算法。 实现目前看到两种实现 第一种只设置一个向后移动的索引 1234567891011121314151617181920void qsort1(int *array, int begin, int end)&#123; if(begin &gt;= end) return; //记录的就是X对应的位置 //即last左边的都比last对应的值小，last右边的都比last对应的值大 int last = begin; //将第一个值和中间的值交换，即将中间的值作为比较值。并不是必须的。 swap(array[begin], array[(begin + end)/2]); int xData = array[begin]; //索引从第二个值往后，分别与第一个值比较 for(int i = begin + 1; i &lt;= end; ++i) if(array[i] &lt; xData) swap(array[++last], array[i]); //这里没交换之前(begin + 1, last)之间的值都比xData小 swap(array[begin], array[last]); //将begin和last值交换后，(begin, last - 1)的值都比last值小了 qsort1(array, begin, last - 1); qsort1(array, last + 1, end);&#125; 第二种设置前后两个移动的索引 123456789101112131415161718192021222324252627void qsort2(int *array, int begin, int end)&#123; if(begin &gt;= end) return; int i = begin, j = end; //依然设置第一个值为待比较值 int xData = array[begin]; while(i &lt; j) &#123; //当右边索引对应的值一直比待比较值大时，索引左移 while(i &lt; j &amp;&amp; array[j] &gt;= xData) --j; //此时若j没超过范围，则array[j]是右侧第一个比待比较值小的元素 //交换与左侧索引对应的值，并且左侧索引自增 if(i &lt; j) swap(array[i++], array[j]); //左侧索引自增，直到找到一个比待比较值大的元素 while(i &lt; j &amp;&amp; array[i] &lt;= xData) ++i; if(i &lt; j) swap(array[i], array[j--]); &#125; //跳出循环后，索引i对应的就是xData的值 array[i] = xData; qsort2(array, begin, i - 1); qsort2(array, i + 1, end);&#125; 第三种类似于第二种，参考：http://developer.51cto.com/art/201403/430986.htm 12345678910111213141516171819202122232425void qsort3(int *array, int begin, int end)&#123; if(begin &gt;= end) return; int i = begin, j = end; //依然设置第一个值为待比较值 int xData = array[begin]; while(i &lt; j) &#123; //当右边索引对应的值一直比待比较值大时，索引左移 while(i &lt; j &amp;&amp; array[j] &gt;= xData) --j; //左侧索引自增，直到找到一个比待比较值大的元素 while(i &lt; j &amp;&amp; array[i] &lt;= xData) ++i; if(i &lt; j) swap(array[i], array[j]); &#125; //此时array[i]对应的值是要比xData小的 //交换之后xData左边的值都比xData小了 swap(array[begin], array[i]); qsort2(array, begin, i - 1); qsort2(array, i + 1, end);&#125; 希尔排序原理是一种复杂的插入排序。简单插入排序是每次步长都为1的，而希尔排序选取的步进是一个递减的序列，最后一个值为1。为什么希尔排序比较快还是没搞懂，参考知乎：https://www.zhihu.com/question/24637339 实现有两种排序方法，类似12345678910111213141516void shellSort1(int *array, int size)&#123; int gap = size/2; while(gap &gt;= 1) &#123; //下面这部分逻辑和简单插入排序是类似的 for(int i = gap; i &lt; size; ++i) &#123; for(int j = i - gap; (j &gt;= 0) &amp;&amp; (array[j] &gt; array[j + gap]); j -= gap)&#123; swap(array[j + gap] ,array[j]); &#125; &#125; gap /= 2; //步进每次除2，直到步进为1则退化为简单插入排序 &#125;&#125; 123456789101112131415161718void shellSort2(int *array, int size)&#123; //int gap = size/2; int gap = 1; while(gap &gt;= 1) &#123; //下面这部分逻辑和简单插入排序是类似的 for(int i = gap; i &lt; size; ++i) &#123; int curData = array[i]; int j = 0; for(j = i - gap; j &gt;= 0 &amp;&amp; array[j] &gt; curData; j -= gap) array[j + gap] = array[j]; array[j + gap] = curData; &#125; gap /= 2; //步进每次除2，直到步进为1则退化为简单插入排序 &#125;&#125; 堆排序原理 首先什么是堆。堆是一棵完全二叉树，若任意一个节点的值不小于子节点的值，称为大根堆；若任意节点的值不大于子节点的值，称为小根堆。 堆排序的步骤，以升序为例– 将数组构造成大根堆– 交换根节点的值（最大值）与最后一个节点的值– 调整除最后一个节点之外的n-1个值为大根堆– 重复步骤2 参考：https://jingyan.baidu.com/article/5225f26b057d5de6fa0908f3.html 实现1234567891011121314151617181920212223242526272829303132333435363738394041void adjustHeap(int *array, int parent, int size)&#123; //若大于这个值，则其已没有子节点，不需要调整 if(parent &gt; (size/2 - 1)) return; //左右节点的索引 int lchild = parent * 2 + 1, rchild = parent * 2 + 2; //父，左，右三个节点最大值的索引 int max = parent; if(lchild &lt; size &amp;&amp; array[lchild] &gt; array[max]) max = lchild; if(rchild &lt; size &amp;&amp; array[rchild] &gt; array[max]) max = rchild; //最大节点不是父节点时 if(max != parent) &#123; //交换父节点与最大节点的值 swap(array[parent], array[max]); //被交换的最大节点对应的子树，可能不是一个大根堆了，所以需要调整 adjustHeap(array, max, size); &#125;&#125;void buildHeap(int *array, int size)&#123; //这里i的起始值为，非叶子节点的最后一个节点的值。 //画一个图表示一下就知道了 for(int i = size/2 - 1; i &gt;= 0; --i) adjustHeap(array, i, size);&#125;void heapSort(int *array, int size)&#123; buildHeap(array, size); for(int i = size - 1; i &gt;= 0; --i) &#123; //交换根节点和当前无序区最后一个节点的值 swap(array[0], array[i]); adjustHeap(array, 0, i); &#125;&#125; -2018-01-22更新 参考《数据结构与算法分析》所述下滤过程，可将调整堆的过程写为如下，不用递归:123456789101112131415161718192021inline int leftchild(int i)&#123; return 2 * i + 1;&#125;void percolateDown(std::vector&lt;int&gt; &amp;array, int index, int size)&#123; int temp; int child; for(temp = array[index]; leftchild(index) &lt; size; index = child) &#123; child = leftchild(index); if(child != size - 1 &amp;&amp; array[child] &lt; array[child + 1]) child++; if(array[child] &gt; temp) array[index] = array[child]; else break; &#125; array[index] = temp;&#125; 性能比较与总结使用srand和rand函数生成10万个随机数，分别使用以上的各种排序算法，进行排序。 并使用GetTickCount函数计算函数运行时间，结果如下 1234567891011121314bubbleSort elapse time: 55422 mscocktailSort elapse time: 47234 msselectSort elapse time: 20250 msinsertSort1 elapse time: 18141 msinsertSort2 elapse time: 10969 msmergeSort1 elapse time: 46 msmergeSort2 elapse time: 32 msmergeSort3 elapse time: 31 msqsort1 elapse time: 31 msqsort2 elapse time: 16 msqsort3 elapse time: 31 msshellSort1 elapse time: 47 msshellSort2 elapse time: 11516 msheapSort elapse time: 46 ms 可以看出归并排序，快速排序，希尔排序，堆排序，真的是很快。 （希尔排序的第二种写法可以放弃了） 膜拜各位发明算法的大神。 上面这些排序算法，虽然都用代码实现了，但没有图表示，有些还是比较难理解的。后面有时间的话补上。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++常用知识点","date":"2017-12-24T09:23:51.000Z","path":"2017/12/24/C++常用知识点/","text":"使用C++实现单链表操作SingleList.h 123456789101112131415161718192021222324252627282930#ifndef SINGLELIST_H#define SINGLELIST_H#include \"stdio.h\"class SingleList&#123;public: SingleList(); ~SingleList() &#123; clear(); &#125; void print(); int length(); void insert(int pos, int data); void append(int data); void remove(int pos); void reverse();private: struct Node &#123; int data; Node *next; Node(int d) : data(d), next(nullptr) &#123;&#125; ~Node() &#123; printf(\"node released. data:%d\\n\", data); &#125; &#125;; void clear(); int len; Node *head;&#125;;#endif // !SINGLELIST_H SingleList.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include \"stdafx.h\"#include \"SingleList.h\"SingleList::SingleList()&#123; len = 0; head = new Node(0);&#125;void SingleList::clear()&#123; Node *p = head, *q; while (p) &#123; q = p-&gt;next; delete p; p = q; &#125;&#125;int SingleList::length()&#123; return len;&#125;void SingleList::append(int data)&#123; insert(length(), data);&#125;void SingleList::insert(int pos, int data)&#123; if (pos &lt; 0 || pos &gt; len) &#123; printf(\"insert pos:%d is not valid.\\n\", pos); return; &#125; Node *p = head; while (pos) &#123; pos--; p = p-&gt;next; &#125; Node *q = new Node(data); q-&gt;next = p-&gt;next; p-&gt;next = q; len++;&#125;void SingleList::print()&#123; Node *p = head-&gt;next; if (!p) &#123; printf(\"List is null\\n\"); return; &#125; int i = 0; while (p) &#123; printf(\"Node(%d):%d\\n\", i++, p-&gt;data); p = p-&gt;next; &#125;&#125;void SingleList::remove(int pos)&#123; if (pos &lt; 0 || pos &gt;= len) &#123; printf(\"insert pos:%d is not valid.\\n\", pos); return; &#125; Node *p = head, *q; if (pos == 0) &#123; q = p-&gt;next; head-&gt;next = q-&gt;next; delete q; len--; return; &#125; while (pos) &#123; p = p-&gt;next; pos--; &#125; q = p-&gt;next; p-&gt;next = q-&gt;next; delete q; len--;&#125;void SingleList::reverse()&#123; if (len == 0 || len == 1) return; Node *p = head-&gt;next, *q = head-&gt;next-&gt;next, *t; p-&gt;next = nullptr; while (q) &#123; t = q-&gt;next; q-&gt;next = p; p = q; q = t; &#125; head-&gt;next = p;&#125; 使用多态时的注意点 待继承的函数必须为virtual 父类的引用或指针才能实现多态，变量不行 1234567891011121314151617181920212223class A&#123;public: //必须是virtual virtual void print() &#123; printf(\"this is A\\n\"); &#125;;class B : public A&#123;public: void print() &#123; printf(\"this is B\\n\"); &#125;&#125;;int main()&#123; A &amp;a = B(); a.print(); //或者 // A *a = new B() // a-&gt;print() // 若使用A a = B(),则不能实现多态 return 0;&#125; 汉诺塔问题123456789101112131415161718192021222324252627282930313233void move(int num, char from, char to)&#123; printf(\"move %d from %c to %c\\n\", num, from, to);&#125;//正常答案//n:深度, from:起始，to:终止，mid:借助的中间void hannoi(int depth, char from, char mid, char to)&#123; if(depth == 1) move(1, from, to); else &#123; hannoi(depth-1, from, to, mid); move(depth, from, to); hannoi(depth-1, mid, from, to); &#125;&#125;//我一开始理解成只能相邻两个之间移动时的做法//即不能从A-&gt;C,只能A-&gt;B-&gt;Cvoid func(int depth, char from, char to)&#123; if(depth &lt;= 0 || from == to) &#123; return; &#125; else &#123; func(depth-1, from, to); move(depth, from, 'B'); func(depth-1, to, from); move(depth, 'B', to); func(depth-1, from, to); &#125; &#125; 重载输入输出流12345678910111213141516171819202122232425262728293031323334353637//必须声明为友元函数,这样就能不创建对象而直接调用函数。class Fruit&#123;public: Fruit(string name, string color) &#123; name_ = name; color_ = color; &#125; friend istream&amp; operator&gt;&gt;(istream &amp;, Fruit &amp;); friend ostream&amp; operator&lt;&lt;(ostream &amp;, Fruit &amp;); private: string name_; string color_;&#125;;istream&amp; operator&gt;&gt;(istream &amp;in, Fruit &amp;fruit)&#123; in &gt;&gt; fruit.color_ &gt;&gt; fruit.name_; if(!in) cerr &lt;&lt; \"Wrong input\" &lt;&lt; endl; return in;&#125;ostream&amp; operator&lt;&lt;(ostream &amp;out, Fruit &amp;fruit)&#123; out &lt;&lt; fruit.color_ &lt;&lt; \" \" &lt;&lt; fruit.name_ &lt;&lt; endl; return out;&#125;int main()&#123; Fruit apple(\"\", \"\"); cin &gt;&gt; apple; cout &lt;&lt; apple; return 0;&#125; 读写文件读取文件12345678910111213141516171819202122232425262728293031323334void readfile()&#123; char *fname = \"log.txt\"; ifstream inFile(fname); if(!inFile) &#123; printf(\"open file %s file failed\\n\", fname); return; &#125; //逐个读取 /*char ch; while(!inFile.eof()) &#123; inFile.read(&amp;ch, 1); cout &lt;&lt; ch; &#125;*/ //逐行读取 char line[1024]; while(!inFile.eof()) &#123; inFile.getline(line, 100); cout &lt;&lt; line &lt;&lt; endl; &#125; inFile.close(); //以空格为分隔符，将数据读到数组中 /*std::vector&lt;int&gt; array; int data; while(!inFile.eof()) &#123; inFile &gt;&gt; data; array.push_back(data); &#125;*/ &#125; 写文件12345678910void writeFile()&#123; ofstream out(\"out.txt\"); if (out.is_open()) &#123; out &lt;&lt; \"This is a line.\\n\"; out &lt;&lt; \"This is another line.\\n\"; out.close(); &#125; &#125; 指向常量的指针和常指针12345678910const int constData = 15;//指向常量的指针，或者int const *ptr = &amp;constData;const int *ptr = &amp;constData;*ptr = 10; //编译错误ptr = nullptr; //okint data = 10;int *const ptr2 = &amp;data;*ptr2 = 5; //okptr2 = nullptr; // 编译错误 指针数组与数组指针123456789int array[3] = &#123;1, 3, 5&#125;;//数组指针，指向数组的指针int (*arrayPtr)[3];arrayPtr = &amp;array;printf(\"data 0 :%d\\n\", **arrayPtr);//指针数组，每一个元素都是指针char *arrayPtr2[3] = &#123;\"I\", \"Love\", \"China\"&#125;;printf(\"data 1 :%s\\n\", arrayPtr2[1]); 函数指针指向函数的指针1234567891011int func(int in)&#123; return in + 10;&#125;void testFuncPtr()&#123; int (*funcPtr)(int); funcPtr = func; printf(\"%d\\n\", (*funcPtr)(5));&#125; 类的静态成员需要在类外初始化，即使是private1234567891011121314class Object&#123;public: static int shareData() &#123; return shareData_; &#125;private: static int shareData_;&#125;;//不加会报unresolved externalsint Object::shareData_ = 0;void testStaticMember()&#123; printf(\"%d\\n\", Object::shareData());&#125; 求最大公约数1234567891011void gcd(int numA, int numB)&#123; int temp; while(numB) &#123; temp = numB; numB = numA % numB; numA = temp; &#125; printf(\"gcd is %d\\n\", numA);&#125; 数组定义及初始化定义 静态12345678910111213141516171819//静态一维数组int array1[100]; //定义int array2[2] = &#123;1, 3&#125;; //定义并初始化int array3[] = &#123;1, 3, 5, 7&#125;; //可以不指定长度//静态二维数组int array4[10][10];int array5[3][2] = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;int array6[][3] = &#123;&#123;1, 2, 3&#125;, &#123;2, 3, 4&#125;&#125;; //第一个维度可以不指定//动态一数组int *array7 = new int[5]; delete[] array7; //定义int *array8 = new int[3]&#123;1, 3, 5&#125;; delete []array8;//定义并初始化//动态二维数组int (*array10)[2] = new int[3][2]; delete []array10;int (*array11)[2] = new int[3][2]&#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;delete []array11;//变长动态二维数组int **array = new int*[n];for(int i = 0; i &lt; n; ++i) array[i] = new int[n]; 参数传递12345void func1(int *array)&#123;&#125;void func2(int array[])&#123;&#125;void func3(int array[][10])&#123;&#125;void func4(int (*array)[2])&#123;&#125;void func5(int **array)&#123;&#125; 使用std::min时报错添加了windows.h和algorithm头文件时，如下使用报错12int a = 1, b = 2;int c = std::min(a, b); error C2589: ‘(‘: illegal token on right side of ‘::’ 可以修改成如下，解决错误1(std::min)(a, b) 参考：http://www.cppblog.com/matrix/archive/2010/08/05/122329.html 递归的性能到底有多差来看下面计算斐波那契数列时递归和非递归的差距1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;windows.h&gt;long fib_recurisive(int n)&#123; if(n &lt;= 0) &#123; printf(\"error num:%d\\n\", n); return 0; &#125; else if(n &lt;= 2) return n; else return fib_recurisive(n - 1) + fib_recurisive(n - 2);&#125;long fib_normal(int n)&#123; if(n &lt;= 0) &#123; printf(\"error num:%d\\n\", n); &#125; else if(n &lt;= 2) return n; long temp[2] = &#123;1, 2&#125;; for(int i = 3; i &lt;= n; ++i) &#123; int t = temp[0]; temp[0] = temp[1]; temp[1] += t; &#125; return temp[1];&#125;int main()&#123; long begin, end, result; begin = GetTickCount(); result = fib_recurisive(45); end = GetTickCount(); printf(\"fib_recurisive(%d):%ld elapse time :%ld ms\\n\", 45, result, end - begin); begin = GetTickCount(); result = fib_normal(45); end = GetTickCount(); printf(\"fib_normal(%d):%ld elapse time :%ld ms\\n\", 45, result, end - begin); return 0;&#125; 输出12fib_recurisive(45):1836311903 elapse time :9062 msfib_normal(45):1836311903 elapse time :0 ms 以后还是能不用递归就不用递归吧。 求解序列的最大子序列和比如{-2, 11, -4, 13, -5, -2}的最大子序列和为20 1234567891011121314//最大子序列和void maxSubSum(int *array, int size)&#123; int thisSum = 0, maxSum = 0; for(int i = 0; i &lt; size; ++i) &#123; thisSum += array[i]; if(thisSum &gt; maxSum) maxSum = thisSum; else if(thisSum &lt; 0) thisSum = 0; &#125; printf(\"maxSum : %d\\n\", maxSum);&#125; 字符串逆序 方法一123456789101112void reverse(char *str)&#123; int len = strlen(str); //分别指向第一个和最后一个字符 char *p = str, *q = str + len -1; while(p &lt; q) &#123; char t = *p; *p++ = *q; *q-- = t; &#125;&#125; 需要注意的是，不能像下面这么调用12char *str = \"hello, world\";reverse(str)； 这么调用编译可以通过，但是运行会崩溃，因为这里的str其实应该是const char*，值是不可更改的。可以像下面这么调用12char str[] = \"hello, world\";reverse(str)； 方法二1234567891011121314char *reverse2(const char *src)&#123; const int size = strlen(src); char *dst = new char[size + 1]; //指向原数组最后一个字符 const char *p = src + size - 1; //指向目标数组 char *q = dst; int len = size; while(len--) *q++ = *p--; *q = '\\0'; return dst;&#125; 注意额外分配的内存，用完后需要释放的 奶牛生子问题描述：一只刚出生的奶牛，第4年开始生一只奶牛，以后每年生一只。现在给你一只刚出生的奶牛，求20年后有多少奶牛？ 方法一123456789101112//递归最简单int cowCount(int year)&#123; if(year &lt; 0) return 0; if(year == 1 || year == 2 || year == 3) return 1; if(year == 4) return 2; //前一年的数量，加上4年前生产的小牛数量（因为4年后小牛也开始生产了） return cowCount(year - 1) + cowCount(year - 4);&#125; 打印N*N矩阵1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//输入长度n，打印矩阵，格式为螺旋型如下（n为4时）// 1 2 3 4// 12 13 14 5// 11 16 15 6// 10 9 8 7//想法是将矩阵数据先保存到二维数组中，然后统一打印。//保存的方法上将整个矩阵分解成一层一层嵌套的正方形。//比如上面的矩阵可以分解成(1~12)和(13~16)的两个正方形//其中每个正方形的数据又可以分为四条边的数据void printMatrix(int n)&#123; std::vector&lt;std::vector&lt;int&gt;&gt; array(n, std::vector&lt;int&gt;(n)); //每个正方形最左上角开始的值 int start = 1; //最多有(n+1)/2 个正方形 for(int i = 0; i &lt; (n + 1) / 2; ++i) &#123; //正方形的宽度，每层递减2 int width = n - 2 * i; //宽度小于1，异常了退出 if(width &lt; 1) break; //宽度为1，最中心的一个点，特殊处理 if(width == 1) array[i][i] = n*n; //这里开始计算每条边的数据 //注意为了防止重复计算，每条边只计算(width-1)个数据 for(int j = 0; j &lt; width - 1; ++j) &#123; //上边，横坐标为i，因为第一个正方形横坐标为0，第二个正方形横坐标为1.. //纵坐标同样要加上初始值i，理由同上 array[i][j + i] = start + j; //右边 array[j + i][n - 1 - i] = start + j + width- 1; //下边 array[n - 1 - i][ width + i - 1 - j] = start + j + 2 * width - 2; //左边 array[width + i - 1 - j][i] = start + j + 3 * width - 3; &#125; start += 4 * width - 4; &#125; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; printf(\"%3d \", array[i][j]); &#125; printf(\"\\n\"); &#125;&#125; 算法2123456789101112131415161718192021222324252627282930void printMatrix2(int n) &#123; std::vector&lt;std::vector&lt;int&gt;&gt; array(n, std::vector&lt;int&gt;(n)); int i, j, round=0; int m = 1; //这里不设置的话，n为1时不正确 array[0][0] = 1; for(i=n-1;i&gt;=n/2;i--) &#123; //上边（注意每个边只计算k-1个值，这样四条边正好可以首尾连接起来） for(j = round; j &lt; i; ++j) array[round][j] = m++; //右边 for(j = round; j&lt; i; j++) array[j][i] = m++; //下边 for(j = i; j &gt; round; --j) array[i][j] = m++; //左边 for(j = i; j &gt; round; --j) array[j][round] = m++; round++; &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) printf(\"%3d\",array[i][j]); printf(\"\\n\"); &#125;&#125; 找出两个数中的大者，不用判断1int max = ((a + b) + abs(a - b))/2 各种字符串操作原型strcpy原型12345678910char *strcpy(char *dst, char *src)&#123; if(!dst || !src) return nullptr; if(dst == src) return dst; char *tmp = dst; while((*dst++ = *src++) != '\\0'); return tmp;&#125; strcat原型123456789101112131415char *mystrcat(char *dst, const char *src)&#123; if(!dst || !src) return dst; char *p = dst; while(*++p); while((*p++ = *src++) != '\\0'); return dst;&#125;void test()&#123; char dst[50] = \"i love \"; const char *src = \"China\"; printf(\"%s\\n\", mystrcat(dst, src));&#125; strcmp原型123456789101112131415161718int strcmp(const char *left, const char *right)&#123; assert(left != nullptr &amp;&amp; right != nullptr); while(*left &amp;&amp; *right &amp;&amp; (*left == *right)) &#123; ++left; ++right; &#125; return *left - *right;&#125;void test()&#123; char *s1 = \"#\"; char *s2 = \"#\"; printf(\"%d\\n\", strcmp(s1, s2)); //0 //这里要注意 printf(\"%d\\n\", s1 == \"#\"); //false&#125; 判断单链表有环定义指针slow和fast，slow每次移动一格，fast每次移动两格，如果有环，则两者必然重逢。 这就像圆形跑道，跑的快的一定会和跑的跑的慢点相逢，只要时间够长1234567891011121314bool checkHasLoop(Node *head)&#123; if(!head) return false; Node *slow = head, *fast = head-&gt;next_; while(fast &amp;&amp; fast-&gt;next_) &#123; slow = slow-&gt;next_; fast = fast-&gt;next_-&gt;next_; if(slow == fast) return true; &#125; return false;&#125; 求解整数二进制数中1的个数123456789101112int getCountOf1(unsigned int n)&#123; int count = 0; //n为0时则没有1了 while(n) &#123; ++count; //清除最右边的1 n = n &amp; (n - 1); &#125; return count;&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++智能指针","date":"2017-12-18T12:23:51.000Z","path":"2017/12/18/C++智能指针/","text":"定义智能指针是在 标头文件中的 std 命名空间中定义的。 C++标准库智能指针 测试对象定义1234567891011121314151617181920212223class Object&#123;public: Object(string name) &#123; name_ = name; &#125; ~Object() &#123; cout &lt;&lt; \"~Object\" &lt;&lt; endl; &#125; void print() &#123; cout &lt;&lt; \"hello \" &lt;&lt; name_ &lt;&lt; endl; &#125; void setChild(shared_ptr&lt;Object&gt; child) &#123; child_ = child; &#125;private: shared_ptr&lt;Object&gt; child_; string name_;&#125;; unique_ptr只允许基础指针的一个所有者 创建123456//使用指针直接创建，不推荐auto unique1 = unique_ptr&lt;Object&gt;(new Object(\"kdb\"));unique1-&gt;print();//使用make_unique创建，推荐auto unique2 = make_unique&lt;Object&gt;(\"kdb\");unique2-&gt;print(); 赋值12345678910111213auto unique1 = make_unique&lt;Object&gt;(\"kdb\");auto unique2 = unique1; //编译错误auto unique1 = make_unique&lt;Object&gt;(\"kdb\");unique_ptr&lt;Object&gt; unique2(unique1); //编译错误//使用同一裸指针定义多个unique_ptr，会导致崩溃。//因为裸指针指向的内存会被删除多次Object *rawPtr = new Object(\"kdb\");unique_ptr&lt;Object&gt; unique1(rawPtr);unique1-&gt;print();unique_ptr&lt;Object&gt; unique2(rawPtr);unique2-&gt;print();//调用完成之后崩溃 移动1234auto unique1 = make_unique&lt;Object&gt;(\"kdb\"); auto unique2 = move(unique1); unique2-&gt;print(); //OK unique1-&gt;print(); //崩溃，原unique_ptr已无效 示例：向量中使用unique_ptr123456789vector&lt;unique_ptr&lt;Object&gt;&gt; objects;objects.push_back(make_unique&lt;Object&gt;(\"123\"));objects.push_back(make_unique&lt;Object&gt;(\"334\"));objects.push_back(make_unique&lt;Object&gt;(\"567\"));//主要这里不使用引用会导致编译错误for(auto const &amp;object : objects)&#123; object-&gt;print();&#125; 示例，创建指向数组的unique_ptr123456789101112//裸指针方式//int *array = new int[5];//unique_ptr方式auto array = make_unique&lt;int[]&gt;(5);for(int i = 0; i &lt; 5; i++)&#123; array[i] = i;&#125;for(int i = 0; i &lt; 5; i++)&#123; cout &lt;&lt; array[i] &lt;&lt; endl;&#125; 总结而言：可移动，但不可复制 shared_ptr采用引用计数的智能指针。 创建12345678910//推荐auto shared1 = make_shared&lt;Object&gt;(\"kdb\");shared1-&gt;print();//传入裸指针，不推荐auto shared2 = shared_ptr&lt;Object&gt;(new Object(\"kdb\"));shared2-&gt;print();//声明和初始化需要分开时，传入nullptrshared_ptr&lt;Object&gt; shared3(nullptr);shared3 = make_shared&lt;Object&gt;(\"kdb\");shared3-&gt;print(); 复制与C++对象类似123456auto shared1 = make_shared&lt;Object&gt;(\"kdb\");auto shared2 = shared1;auto shared3(shared1);shared1-&gt;print();shared2-&gt;print();shared3-&gt;print(); 存在问题：嵌套引用时导致内存泄漏123456auto shared1 = make_shared&lt;Object&gt;(\"kdb\");auto shared2 = make_shared&lt;Object&gt;(\"233\");shared1-&gt;setChild(shared2);shared2-&gt;setChild(shared1);cout &lt;&lt; \"shared1 count:\" &lt;&lt; shared1.use_count() &lt;&lt; endl; //2cout &lt;&lt; \"shared2 count:\" &lt;&lt; shared2.use_count() &lt;&lt; endl; //2 weak_ptr结合 shared_ptr 使用的特例智能指针。 weak_ptr 提供对一个或多个 shared_ptr 实例拥有的对象的访问，但不参与引用计数。 将类中的成员变量类型改成weak_ptr类型，则上述嵌套引用导致的内存泄漏不存在了 再来看一个循环引用的例子12345678910111213141516171819202122232425//双向链表struct Node&#123; Node(int data) :data_(data) &#123;&#125; ~Node() &#123; printf(\"Node deconstructor, data:%d\\n\", data_); &#125; int data_; shared_ptr&lt;Node&gt; prev_; shared_ptr&lt;Node&gt; next_;&#125;;void testDoubleList()&#123; auto node1 = make_shared&lt;Node&gt;(1); auto node2 = make_shared&lt;Node&gt;(2); node1-&gt;next_ = node2; node2-&gt;prev_ = node1; //引用计数为2导致资源泄漏 printf(\"node1 count:%d\\n\", node1.use_count()); //2 printf(\"node2 count:%d\\n\", node2.use_count()); //2&#125; 修改Node中的成员为weak_ptr则可以解决该问题123456789101112131415161718192021222324252627//双向链表struct Node&#123; Node(int data) :data_(data) &#123;&#125; ~Node() &#123; printf(\"Node deconstructor, data:%d\\n\", data_); &#125; int data_; weak_ptr&lt;Node&gt; prev_; weak_ptr&lt;Node&gt; next_; //shared_ptr&lt;Node&gt; prev_; //shared_ptr&lt;Node&gt; next_;&#125;;void testDoubleList()&#123; auto node1 = make_shared&lt;Node&gt;(1); auto node2 = make_shared&lt;Node&gt;(2); node1-&gt;next_ = node2; node2-&gt;prev_ = node1; //资源释放 printf(\"node1 count:%d\\n\", node1.use_count()); //1 printf(\"node2 count:%d\\n\", node2.use_count()); //1&#125; weak_ptr本身没有重载operator*和-&gt;，所以不具有普通指针的行为 lock函数可以获得一个可用的shared_ptr，从而操作资源。 参考 C++中智能指针的学习 智能指针（现代 C++） 创建和使用 unique_ptr 实例 创建和使用 shared_ptr 实例 创建和使用共享 weak_ptr 实例 shared_ptr造成的循环引用","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"大话设计模式笔记","date":"2017-12-06T12:23:51.000Z","path":"2017/12/06/大话设计模式/","text":"以下为使用C++实现《大话设计模式》中的各种设计模式 简单工厂模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;class Operation&#123;public: virtual ~Operation() &#123; cout &lt;&lt; \"~Operation\" &lt;&lt; endl; &#125; void setNum1(double num) &#123; num1_ = num; &#125; void setNum2(double num) &#123; num2_ = num; &#125; virtual double getResult() &#123; return 0.0; &#125;protected: double num1_; double num2_;&#125;;class OperationAdd : public Operation&#123;public: ~OperationAdd() &#123; cout &lt;&lt; \"~OperationAdd\" &lt;&lt; endl; &#125; double getResult() &#123; return num1_ + num2_; &#125;&#125;;class OperationSub : public Operation&#123;public: ~OperationSub() &#123; cout &lt;&lt; \"~OperationSub\" &lt;&lt; endl; &#125; double getResult() &#123; return num1_ - num2_; &#125;&#125;;class OperationMulti : public Operation&#123;public: ~OperationMulti() &#123; cout &lt;&lt; \"~OperationMulti\" &lt;&lt; endl; &#125; double getResult() &#123; return num1_ * num2_; &#125;&#125;;class OperationDiv : public Operation&#123;public: ~OperationDiv() &#123; cout &lt;&lt; \"~OperationDiv\" &lt;&lt; endl; &#125; double getResult() &#123; if(fabs(num2_) &lt; 1e-15) &#123; cout &lt;&lt; \"div num cannot be zero\" &lt;&lt; endl; return 0.0; &#125; else &#123; return num1_ / num2_; &#125; &#125;&#125;;unique_ptr&lt;Operation&gt; opFactory(string op)&#123; if(op == \"+\") return make_unique&lt;OperationAdd&gt;(); else if(op == \"-\") return make_unique&lt;OperationSub&gt;(); else if(op == \"*\") return make_unique&lt;OperationMulti&gt;(); else if(op == \"/\") return make_unique&lt;OperationDiv&gt;(); else &#123; cout &lt;&lt; \"unsupported operation:\" &lt;&lt; op &lt;&lt; endl;; return nullptr; &#125;&#125;int main()&#123; double num1, num2; string op_s; cout &lt;&lt; \"please input num1:\"; cin &gt;&gt; num1; cout &lt;&lt; \"please input num2:\"; cin &gt;&gt; num2; cout &lt;&lt; \"please input operation:\"; cin &gt;&gt; op_s; auto op = opFactory(op_s); op-&gt;setNum1(num1); op-&gt;setNum2(num2); cout &lt;&lt; \"result:\" &lt;&lt; op-&gt;getResult() &lt;&lt; endl; return 0;&#125; 策略模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Strategy&#123;public: virtual ~Strategy() &#123; cout &lt;&lt; \"~Strategy\" &lt;&lt; endl; &#125; virtual void AlgorithmInterface() = 0;&#125;;class ConcreteStrategyA : public Strategy&#123;public: ~ConcreteStrategyA() &#123; cout &lt;&lt; \"~ConcreteStrategyA\" &lt;&lt; endl; &#125; void AlgorithmInterface() &#123; cout &lt;&lt; \"Algorithm A called\" &lt;&lt; endl; &#125;&#125;;class ConcreteStrategyB : public Strategy&#123;public: ~ConcreteStrategyB() &#123; cout &lt;&lt; \"~ConcreteStrategyB\" &lt;&lt; endl; &#125; void AlgorithmInterface() &#123; cout &lt;&lt; \"Algorithm B called\" &lt;&lt; endl; &#125;&#125;;class Context&#123;public: Context(shared_ptr&lt;Strategy&gt; strategy) &#123; strategy_ = strategy; &#125; ~Context() &#123; cout &lt;&lt; \"~Context\" &lt;&lt; endl; &#125; void ContextInterface() &#123; strategy_-&gt;AlgorithmInterface(); &#125;private: shared_ptr&lt;Strategy&gt; strategy_;&#125;;int main()&#123; auto algo = make_shared&lt;ConcreteStrategyA&gt;(); auto ctx = make_unique&lt;Context&gt;(algo); ctx-&gt;ContextInterface(); return 0;&#125; 示例（与简单工厂结合）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class CashSuper&#123;public: virtual ~CashSuper() &#123; cout &lt;&lt; \"~CashSuper\" &lt;&lt; endl; &#125; virtual double getCash(double money) = 0;&#125;;class CashNormal : public CashSuper&#123;public: ~CashNormal() &#123; cout &lt;&lt; \"~CashNormal\" &lt;&lt; endl; &#125; double getCash(double money)&#123; return money; &#125;&#125;;class CashSale : public CashSuper&#123;public: CashSale(double rate) : rate_(rate) &#123;&#125; ~CashSale() &#123; cout &lt;&lt; \"~CashSale\" &lt;&lt; endl; &#125; double getCash(double money)&#123; return money * rate_;&#125;private: double rate_;&#125;;class CashFullCut : public CashSuper&#123;public: CashFullCut(int full, int ret) : full_(full), ret_(ret) &#123;&#125; ~CashFullCut() &#123; cout &lt;&lt; \"~CashFullCut\" &lt;&lt; endl; &#125; double getCash(double money) &#123; for(int i = 0; i &lt; int(money/full_); i++) money -= ret_; return money; &#125;private: int full_; int ret_;&#125;;class CashContext&#123;public: CashContext(int type) &#123; switch (type) &#123; case 0: cashSuper_ = make_unique&lt;CashNormal&gt;(); break; case 1: cashSuper_ = make_unique&lt;CashSale&gt;(0.9); break; case 2: cashSuper_ = make_unique&lt;CashFullCut&gt;(200, 10); break; default: cashSuper_ = nullptr; break; &#125; &#125; ~CashContext() &#123; cout &lt;&lt; \"~CashContext\" &lt;&lt; endl; &#125; double getResult(double money) &#123; if(cashSuper_) return cashSuper_-&gt;getCash(money); return 0.0; &#125;private: unique_ptr&lt;CashSuper&gt; cashSuper_;&#125;;int main()&#123; int num; double unitPrice; int type; double sum = 0; cout &lt;&lt; \"please input num :\" &lt;&lt; endl; cin &gt;&gt; num; cout &lt;&lt; \"please input unitPrice:\" &lt;&lt; endl; cin &gt;&gt; unitPrice; cout &lt;&lt; \"please input price type:\" &lt;&lt; endl; cin &gt;&gt; type; CashContext ctx(type); cout &lt;&lt; \"sum : \" &lt;&lt; ctx.getResult(num*unitPrice) &lt;&lt; endl; return 0;&#125; 装饰模式原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Component&#123;public: virtual void Operation() = 0;&#125;;class ConcreteComponent : public Component&#123;public: void Operation() &#123; cout &lt;&lt; \"operation of concrete object\" &lt;&lt; endl; &#125;&#125;;class Decorator : public Component&#123;public: Decorator() &#123; component_ = nullptr; &#125; void setComponent(Component *component) &#123; component_ = component; &#125; void Operation() &#123; if(component_) component_-&gt;Operation(); &#125;protected: Component *component_;&#125;;class ConcreteDecoratorA : public Decorator&#123;public: void Operation() &#123; Decorator::Operation(); addedState_ = \"New State\"; cout &lt;&lt; \"decorator a\" &lt;&lt; endl; &#125;private: string addedState_;&#125;;class ConcreteDecoratorB : public Decorator&#123;public: void Operation() &#123; Decorator::Operation(); addedOperation(); cout &lt;&lt; \"decorator b\" &lt;&lt;endl; &#125; void addedOperation() &#123; cout &lt;&lt; \"added operation\" &lt;&lt; endl; &#125;&#125;;void test6()&#123; ConcreteComponent c; ConcreteDecoratorA decoratorA; ConcreteDecoratorB decoratorB; decoratorA.setComponent(&amp;c); decoratorB.setComponent(&amp;decoratorA); decoratorB.Operation();&#125; 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Person&#123;public: Person()&#123;&#125; Person(string name) &#123; name_ = name; &#125; virtual void show() &#123; cout &lt;&lt; name_ &lt;&lt; endl; &#125;private: string name_;&#125;;class Finary : public Person&#123;public: Finary() &#123; person_ = nullptr; &#125; void Decorate(Person *person) &#123; person_ = person; &#125; void show() &#123; if(person_) person_-&gt;show(); &#125;private: Person *person_;&#125;;class TShirt : public Finary&#123;public: void show() &#123; cout &lt;&lt; \"wear TShirts \"; Finary::show(); &#125;&#125;;class Suite : public Finary&#123;public: void show() &#123; cout &lt;&lt; \"wear suite \"; Finary::show(); &#125;&#125;;void test6()&#123; Person kongdb(\"kongdb\"); TShirt tshirt; Suite suite; tshirt.Decorate(&amp;kongdb); suite.Decorate(&amp;tshirt); suite.show();&#125; 代理模式原型12345678910111213141516171819202122232425262728293031323334353637class Subject&#123;public: virtual void request() = 0;&#125;;class ReadSubject : public Subject&#123;public: void request() &#123; cout &lt;&lt; \"real request\" &lt;&lt; endl; &#125;&#125;;class Proxy : public Subject&#123;public: Proxy() &#123; realSubj_ = nullptr; &#125; void request() &#123; if(!realSubj_) realSubj_ = new ReadSubject; realSubj_-&gt;request(); &#125;private: ReadSubject *realSubj_;&#125;;void test7()&#123; Proxy proxy; proxy.request();&#125; 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class GiveGift&#123;public: virtual void giveDolls() = 0; virtual void giveFlowers() = 0; virtual void giveChocolate() = 0; &#125;;class SchoolGirl&#123;public: SchoolGirl(string name) &#123; name_ = name; &#125; string name()&#123; return name_; &#125;private: string name_;&#125;;class Persuit : public GiveGift&#123;public: Persuit(SchoolGirl *mm) &#123; mm_ = mm; &#125; void giveDolls() &#123; cout &lt;&lt; \"give dolls for \" &lt;&lt; mm_-&gt;name() &lt;&lt; endl; &#125; void giveFlowers() &#123; cout &lt;&lt; \"give flowers for \" &lt;&lt; mm_-&gt;name() &lt;&lt; endl; &#125; void giveChocolate() &#123; cout &lt;&lt; \"give chocolate for \" &lt;&lt; mm_-&gt;name() &lt;&lt; endl; &#125;private: SchoolGirl *mm_;&#125;;class Proxy : public GiveGift&#123;public: Proxy(SchoolGirl *mm) &#123; persuit_ = new Persuit(mm); &#125; ~Proxy() &#123; delete persuit_; &#125; void giveDolls() &#123; persuit_-&gt;giveDolls(); &#125; void giveFlowers() &#123; persuit_-&gt;giveFlowers(); &#125; void giveChocolate() &#123; persuit_-&gt;giveChocolate(); &#125;private: Persuit *persuit_;&#125;;void test7()&#123; SchoolGirl mm(\"jiaojiao\"); Proxy proxy(&amp;mm); proxy.giveDolls(); proxy.giveFlowers(); proxy.giveChocolate();&#125; 工厂模式示例：加减法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Operation&#123;public: virtual ~Operation() &#123; cout &lt;&lt; \"~Operation\" &lt;&lt; endl; &#125; void setNumA(double num) &#123; numA_ = num; &#125; void setNumB(double num) &#123; numB_ = num; &#125; virtual double getResult() = 0;protected: double numA_; double numB_;&#125;;class OperationAdd : public Operation&#123;public: ~OperationAdd() &#123; cout &lt;&lt; \"~OperationAdd\" &lt;&lt; endl; &#125; double getResult() &#123; return numA_ + numB_; &#125;&#125;;class OperationSub : public Operation&#123;public: ~OperationSub() &#123; cout &lt;&lt; \"~OperationSub\" &lt;&lt; endl; &#125; double getResult() &#123; return numA_ - numB_; &#125;&#125;;class IFactory&#123;public: virtual ~IFactory() &#123; cout &lt;&lt; \"~IFactory\" &lt;&lt; endl; &#125; virtual unique_ptr&lt;Operation&gt; getOperation() = 0;&#125;;class AddFactory : public IFactory&#123;public: ~AddFactory() &#123; cout &lt;&lt; \"~AddFactory\" &lt;&lt; endl; &#125; unique_ptr&lt;Operation&gt; getOperation() &#123; return make_unique&lt;OperationAdd&gt;(); &#125;&#125;;class SubFactory : public IFactory&#123;public: ~SubFactory() &#123; cout &lt;&lt; \"~SubFactory\" &lt;&lt; endl; &#125; unique_ptr&lt;Operation&gt; getOperation() &#123; return make_unique&lt;OperationSub&gt;(); &#125;&#125;;int main()&#123; auto factoy = make_unique&lt;AddFactory&gt;(); auto operation = factoy-&gt;getOperation(); operation-&gt;setNumA(10); operation-&gt;setNumB(30); cout &lt;&lt; operation-&gt;getResult() &lt;&lt; endl; return 0;&#125; 原型模式C++中的拷贝构造函数和operator=编译器会生成默认的拷贝构造函数和operator=函数，对于只包含数据成员的类就够了（浅拷贝）1234567891011121314151617181920212223class People&#123;public: People(int age) :age_(age) &#123;&#125; int age()&#123; return age_; &#125;private: int age_;&#125;;int main()&#123; People peopleA(20); //copy constuctor People peopleB(peopleA); cout &lt;&lt; \"people B age:\" &lt;&lt; peopleB.age() &lt;&lt; endl; //20 People peopleC(30); //operator= peopleC = peopleA; cout &lt;&lt; \"people C age:\" &lt;&lt; peopleC.age() &lt;&lt; endl; //20 return 0;&#125; 但是对于包含指针成员的类，仅有默认构造函数就不够了，还会导致崩溃 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class People&#123;public: People(int age, char *name) :age_(age) &#123; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125; ~People() &#123; delete name_; &#125; int age()&#123; return age_; &#125; char *name() &#123; return name_; &#125; void setName(char *name) &#123; if(name_) &#123; cout &lt;&lt; \"release previous name\" &lt;&lt; endl; delete name_; &#125; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125;private: char *name_; int age_;&#125;;int main()&#123; People peopleA(20, \"kongdb\"); People peopleB(peopleA); People peopleC(30, \"fdg\"); peopleC = peopleA; cout &lt;&lt; peopleB.name() &lt;&lt; endl; cout &lt;&lt; peopleC.name() &lt;&lt; endl; peopleA.setName(\"other\"); cout &lt;&lt; peopleA.name() &lt;&lt; endl; //other cout &lt;&lt; peopleB.name() &lt;&lt; endl; //crash, peopleB's name_ point memory has released cout &lt;&lt; peopleC.name() &lt;&lt; endl; //crash return 0;&#125; 此时必须重载默认拷贝构造函数和operator=（深拷贝）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class People&#123;public: People(int age, char *name) :age_(age) &#123; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125; People(const People &amp;other) &#123; cout &lt;&lt; \"copy constructor\" &lt;&lt; endl; age_ = other.age_; int len = strlen(other.name_) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, other.name_); &#125; People &amp;operator=(const People &amp;rhs) &#123; cout &lt;&lt; \"operator =\" &lt;&lt; endl; if(this == &amp;rhs) return *this; delete name_; age_ = rhs.age_; int len = strlen(rhs.name_) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, rhs.name_); return *this; &#125; ~People() &#123; delete name_; &#125; int age()&#123; return age_; &#125; char *name() &#123; return name_; &#125; void setName(char *name) &#123; if(name_) &#123; cout &lt;&lt; \"release previous name\" &lt;&lt; endl; delete name_; &#125; int len = strlen(name) + 1; name_ = new char[len]; if(name_) strcpy_s(name_, len, name); &#125;private: char *name_; int age_;&#125;;int main()&#123; People peopleA(20, \"kongdb\"); People peopleB(peopleA); People peopleC(30, \"fdg\"); peopleC = peopleA; cout &lt;&lt; peopleB.name() &lt;&lt; endl; cout &lt;&lt; peopleC.name() &lt;&lt; endl; peopleA.setName(\"otherA\"); cout &lt;&lt; peopleA.name() &lt;&lt; endl; //other cout &lt;&lt; peopleB.name() &lt;&lt; endl; //kongdb cout &lt;&lt; peopleC.name() &lt;&lt; endl; //kongdb return 0;&#125; 为什么有了拷贝构造函数，还需要prototype参考：https://www.zhihu.com/question/52610176陈硕：Prototype 的意义在于，你拿到一个 Base* ，它指向某个 Derived 对象，你想克隆出 Derived 对象，但代码中不写出 Derived 的具体类型，因为有很多派生类，这种情况下你用构造函数是搞不定的，type-switch 是 bad smells 。另外，这里考虑 virtual 的性能损失是主次不分，构造对象需要分 配内存，这开销比一次虚函数调用大多了。Prorobuf Message 就采用了 prototype 模式，你可以参考一下。 例子1234567891011121314151617181920212223242526class Base&#123;public: virtual ~Base() &#123; printf(\"~Base\\n\");&#125;&#125;;class DerivedA : public Base&#123;public: ~DerivedA() &#123; printf(\"~DerivedA\\n\");&#125;&#125;;class DerivedB : public Base&#123;public: ~DerivedB() &#123; printf(\"~DerivedB\\n\");&#125;&#125;;int main()&#123; unique_ptr&lt;Base&gt; basePtr = make_unique&lt;DerivedA&gt;(); //很多其他的代码处理 //到了这里已经不知道basePtr的具体类型，通过typeid等方法很差 DerivedA da(*basePtr); //编译错误 return 0;&#125; 如何实现对于原型模式同样存在浅拷贝、深拷贝的问题。 1234567891011121314151617181920212223242526272829303132class Base&#123;public: virtual ~Base() &#123; printf(\"~Base\\n\");&#125; virtual void print() &#123; printf(\"this is Base\\n\");&#125;; virtual unique_ptr&lt;Base&gt; clone() &#123; return unique_ptr&lt;Base&gt;(new Base(*this)); &#125;&#125;;class Derived : public Base&#123;public: ~Derived() &#123; printf(\"~Derived\\n\");&#125; void print()&#123; printf(\"this is Derived\\n\");&#125; //上面链接的知乎大神把这里返回值设为unique&lt;Derived&gt;，不明白为什么 unique_ptr&lt;Base&gt; clone() &#123; //调用拷贝构造，若是深拷贝，还需重载拷贝函数 return unique_ptr&lt;Base&gt;(new Derived(*this)); &#125;&#125;;int main()&#123; unique_ptr&lt;Base&gt; basePtr = make_unique&lt;Derived&gt;(); //很多其他的代码处理 auto basePtr2 = basePtr-&gt;clone(); basePtr2-&gt;print();// print:this is derived return 0;&#125; 模板方法模式需要注意与建造者模式的不同，参考 建造者模式中指挥者类的作用 模板方法模式VS建造者模式 原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class AbstractClass&#123;public: virtual ~AbstractClass() &#123; printf(\"~AbstractClass\\n\");&#125; virtual void PrimitiveOperation1() = 0; virtual void PrimitiveOperation2() = 0; void TemplateMethod() &#123; PrimitiveOperation1(); PrimitiveOperation2(); &#125;&#125;;class ConcreteClassA : public AbstractClass&#123;public: ~ConcreteClassA() &#123; printf(\"~ConcreteClassA\\n\");&#125; void PrimitiveOperation1() &#123; printf(\"operation 1 of class A\\n\"); &#125; void PrimitiveOperation2() &#123; printf(\"operation 2 of class A\\n\"); &#125;&#125;;class ConcreteClassB : public AbstractClass&#123;public: ~ConcreteClassB() &#123; printf(\"~ConcreteClassB\\n\");&#125; void PrimitiveOperation1() &#123; printf(\"operation 1 of class B\\n\"); &#125; void PrimitiveOperation2() &#123; printf(\"operation 2 of class B\\n\"); &#125;&#125;;int main()&#123; auto classA = make_unique&lt;ConcreteClassA&gt;(); classA-&gt;TemplateMethod(); auto classB = make_unique&lt;ConcreteClassB&gt;(); classB-&gt;TemplateMethod(); return 0;&#125; 示例123456789101112131415161718192021222324252627282930313233343536class Paper&#123;public: virtual ~Paper() &#123; printf(\"~Paper\\n\");&#125; void question() &#123; printf(\"question is balabala, answer is %s\\n\", answer().c_str()); &#125; virtual string answer() = 0;&#125;;class StudentA : public Paper&#123;public: ~StudentA() &#123; printf(\"~StudentA\\n\");&#125; string answer() &#123; return \"A\"; &#125;&#125;;class StudentB : public Paper&#123;public: ~StudentB() &#123; printf(\"~StudentB\\n\");&#125; string answer() &#123; return \"B\"; &#125;&#125;;int main()&#123; StudentA stuA; stuA.question(); StudentB stuB; stuB.question(); return 0;&#125; 外观模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class SubSystemOne&#123;public: ~SubSystemOne()&#123;printf(\"~SubSystemOne\\n\");&#125; void methodOne() &#123; printf(\"method one\\n\"); &#125;&#125;;class SubSystemTwo&#123;public: ~SubSystemTwo()&#123;printf(\"~SubSystemTwo\\n\");&#125; void methodTwo() &#123; printf(\"method two\\n\"); &#125;&#125;;class SubSystemThree&#123;public: ~SubSystemThree()&#123;printf(\"~SubSystemThree\\n\");&#125; void methodThree() &#123; printf(\"method three\\n\"); &#125;&#125;;class SubSystemFour&#123;public: ~SubSystemFour()&#123; printf(\"~SubSystemFour\\n\");&#125; void methodFour() &#123; printf(\"method four\\n\"); &#125;&#125;;class Facade&#123;public: Facade() &#123; sysOne_ = make_unique&lt;SubSystemOne&gt;(); sysTwo_ = make_unique&lt;SubSystemTwo&gt;(); sysThree_ = make_unique&lt;SubSystemThree&gt;(); sysFour_ = make_unique&lt;SubSystemFour&gt;(); &#125; ~Facade()&#123;printf(\"~Facade\\n\");&#125; void methodA() &#123; sysOne_-&gt;methodOne(); sysFour_-&gt;methodFour(); &#125; void methodB() &#123; sysTwo_-&gt;methodTwo(); sysThree_-&gt;methodThree(); &#125;private: unique_ptr&lt;SubSystemOne&gt; sysOne_; unique_ptr&lt;SubSystemTwo&gt; sysTwo_; unique_ptr&lt;SubSystemThree&gt; sysThree_; unique_ptr&lt;SubSystemFour&gt; sysFour_;&#125;;int main()&#123; auto facade = make_unique&lt;Facade&gt;(); facade-&gt;methodA(); facade-&gt;methodB(); return 0;&#125; 建造者模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class Product&#123;public: ~Product()&#123; printf(\"~Product\\n\");&#125; void addParts(string part) &#123; parts_.push_back(part); &#125; void show() &#123; auto i = parts_.begin(); while(i != parts_.end()) &#123; printf(\"%s\\n\", i-&gt;c_str()); i++; &#125; &#125;private: list&lt;string&gt; parts_;&#125;;class Builder&#123;public: virtual ~Builder() &#123;printf(\"~Builder\\n\");&#125; virtual void stepA() = 0; virtual void stepB() = 0; virtual void getResult() = 0;protected: &#125;;class ConcreteBuilderA : public Builder&#123;public: ConcreteBuilderA() &#123; product_ = make_unique&lt;Product&gt;(); &#125; ~ConcreteBuilderA() &#123;printf(\"~ConcreteBuilderA\\n\");&#125; void stepA() &#123; product_-&gt;addParts(\"parts A\"); &#125; void stepB() &#123; product_-&gt;addParts(\"parts B\"); &#125; void getResult() &#123; product_-&gt;show(); &#125;private: unique_ptr&lt;Product&gt; product_;&#125;;class ConcreteBuilderB : public Builder&#123;public: ConcreteBuilderB() &#123; product_ = make_unique&lt;Product&gt;(); &#125; ~ConcreteBuilderB() &#123;printf(\"~ConcreteBuilderB\\n\");&#125; void stepA() &#123; product_-&gt;addParts(\"parts X\"); &#125; void stepB() &#123; product_-&gt;addParts(\"parts Y\"); &#125; void getResult() &#123; product_-&gt;show(); &#125;private: unique_ptr&lt;Product&gt; product_;&#125;;class Director&#123;public: ~Director()&#123; printf(\"~Director\\n\");&#125; void Construct(unique_ptr&lt;Builder&gt; &amp;builder) &#123; builder-&gt;stepA(); builder-&gt;stepB(); &#125;&#125;;int main()&#123; auto director = make_unique&lt;Director&gt;(); unique_ptr&lt;Builder&gt; builderA = make_unique&lt;ConcreteBuilderA&gt;(); director-&gt;Construct(builderA); builderA-&gt;getResult(); unique_ptr&lt;Builder&gt; builderB = make_unique&lt;ConcreteBuilderB&gt;(); director-&gt;Construct(builderB); builderB-&gt;getResult(); return 0;&#125; 观察者模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Observer&#123;public: virtual ~Observer() &#123; printf(\"~Observer\\n\");&#125; virtual void update() = 0;&#125;;class Subject&#123;public: virtual ~Subject()&#123; printf(\"~Subject\\n\");&#125; void attach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.push_back(observer); &#125; void detach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.remove(observer); &#125; void notify() &#123; for(auto &amp;observer : observers_) observer-&gt;update(); &#125;private: list&lt;shared_ptr&lt;Observer&gt;&gt; observers_;&#125;;class ConcreteSubject : public Subject&#123;public: void setState(string state) &#123; state_ = state; &#125; const char *state() &#123; return state_.c_str(); &#125;private: string state_;&#125;;class ConcreteObserver : public Observer&#123;public: ConcreteObserver(shared_ptr&lt;ConcreteSubject&gt; sub, string name) &#123; sub_ = sub; name_ = name; &#125; void update() &#123; printf(\"observer %s new state is:%s\\n\", name_.c_str(), sub_.lock()-&gt;state()); &#125;private: weak_ptr&lt;ConcreteSubject&gt; sub_; string name_;&#125;;int main()&#123; auto sub = make_shared&lt;ConcreteSubject&gt;(); sub-&gt;attach(make_shared&lt;ConcreteObserver&gt;(sub, \"X\")); sub-&gt;attach(make_shared&lt;ConcreteObserver&gt;(sub, \"Y\")); sub-&gt;attach(make_shared&lt;ConcreteObserver&gt;(sub, \"Z\")); sub-&gt;setState(\"abc\"); sub-&gt;notify(); return 0;&#125; 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101class Observer;class Subject&#123;public: virtual ~Subject()&#123; printf(\"~Subject\\n\");&#125; virtual void attach(shared_ptr&lt;Observer&gt;) = 0; virtual void detach(shared_ptr&lt;Observer&gt;) = 0; virtual void notify() = 0; virtual void setState(string) = 0; virtual const char *state() = 0;&#125;;class Observer&#123;public: Observer(string name, shared_ptr&lt;Subject&gt; sub) &#123; name_ = name; sub_ = sub; &#125; virtual ~Observer()&#123; printf(\"~Observer\\n\");&#125; virtual void update() = 0;protected: string name_; weak_ptr&lt;Subject&gt; sub_;&#125;;class Boss : public Subject&#123;public: ~Boss()&#123; printf(\"~Boss\\n\");&#125; void attach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.push_back(observer); &#125; void detach(shared_ptr&lt;Observer&gt; observer) &#123; observers_.remove(observer); &#125; void notify() &#123; auto i = observers_.begin(); while(i != observers_.end()) &#123; (*i)-&gt;update(); ++i; &#125; &#125; void setState(string state)&#123; state_ = state;&#125; const char *state()&#123; return state_.c_str();&#125;private: string state_; list&lt;shared_ptr&lt;Observer&gt;&gt; observers_;&#125;;class StockObserver : public Observer&#123;public: StockObserver(string name, shared_ptr&lt;Subject&gt; sub) :Observer(name, sub) &#123;&#125; ~StockObserver()&#123; printf(\"~StockObserver\\n\");&#125; void update() &#123; printf(\"%s, %s close stock \\n\", sub_.lock()-&gt;state(), name_.c_str()); &#125;&#125;;class NBAObserver : public Observer&#123;public: NBAObserver(string name, shared_ptr&lt;Subject&gt; sub) :Observer(name, sub) &#123;&#125; ~NBAObserver()&#123; printf(\"~NBAObserver\\n\");&#125; void update() &#123; printf(\"%s, %s close NBA \\n\", sub_.lock()-&gt;state(), name_.c_str()); &#125;&#125;;int main()&#123; auto huhansan = make_shared&lt;Boss&gt;(); auto kdb = make_shared&lt;StockObserver&gt;(\"kdb\", huhansan); auto fxdpig = make_shared&lt;NBAObserver&gt;(\"fxdpig\", huhansan); huhansan-&gt;attach(kdb); huhansan-&gt;attach(fxdpig); huhansan-&gt;detach(fxdpig); huhansan-&gt;setState(\"I'm back\"); huhansan-&gt;notify(); return 0;&#125; 观察者模式使用的还是很多的，比如/chromium/ash/system/tray/system_tray_notifier.cc 抽象工厂模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class AbstractProductA&#123;public: virtual ~AbstractProductA() &#123; printf(\"~AbstractProductA\\n\");&#125;&#125;;class AbstractProductB&#123;public: virtual ~AbstractProductB() &#123; printf(\"~AbstractProductB\\n\");&#125;&#125;;class AbstractFactory&#123;public: virtual ~AbstractFactory() &#123; printf(\"~AbstractFactory\\n\");&#125; virtual unique_ptr&lt;AbstractProductA&gt; createProductA() = 0; virtual unique_ptr&lt;AbstractProductB&gt; createProductB() = 0;&#125;;class ProductA1 : public AbstractProductA&#123;public: ProductA1()&#123;printf(\"ProductA1 constructed\\n\");&#125; ~ProductA1() &#123; printf(\"~ProductA1\\n\");&#125;&#125;;class ProductA2 : public AbstractProductA&#123;public: ProductA2()&#123;printf(\"ProductA2 constructed\\n\");&#125; ~ProductA2() &#123; printf(\"~ProductA2\\n\");&#125;&#125;;class ProductB1 : public AbstractProductB&#123;public: ProductB1()&#123;printf(\"ProductB1 constructed\\n\");&#125; ~ProductB1() &#123; printf(\"~ProductB1\\n\");&#125;&#125;;class ProductB2 : public AbstractProductB&#123;public: ProductB2()&#123;printf(\"ProductB2 constructed\\n\");&#125; ~ProductB2() &#123; printf(\"~ProductB2\\n\");&#125;&#125;;class ConcreteFactory1 : public AbstractFactory&#123;public: ~ConcreteFactory1() &#123; printf(\"~ConcreteFactory1\\n\");&#125; unique_ptr&lt;AbstractProductA&gt; createProductA() &#123; return make_unique&lt;ProductA1&gt;(); &#125; unique_ptr&lt;AbstractProductB&gt; createProductB() &#123; return make_unique&lt;ProductB1&gt;(); &#125;&#125;;class ConcreteFactory2 : public AbstractFactory&#123;public: ~ConcreteFactory2() &#123; printf(\"~ConcreteFactory2\\n\");&#125; unique_ptr&lt;AbstractProductA&gt; createProductA() &#123; return make_unique&lt;ProductA2&gt;(); &#125; unique_ptr&lt;AbstractProductB&gt; createProductB() &#123; return make_unique&lt;ProductB2&gt;(); &#125;&#125;;int main()&#123; auto factory1 = make_unique&lt;ConcreteFactory1&gt;(); factory1-&gt;createProductA(); factory1-&gt;createProductB(); auto factory2 = make_unique&lt;ConcreteFactory2&gt;(); factory2-&gt;createProductA(); factory2-&gt;createProductB(); return 0;&#125; 状态模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;memory&gt;class Context;class State&#123;public: virtual ~State()&#123;&#125; virtual void handle(Context *ctx) = 0; virtual const char *name() const = 0;&#125;;class Context&#123;public: Context(std::shared_ptr&lt;State&gt; state) : state_(state) &#123;&#125; ~Context()&#123;&#125; void request() &#123; state_-&gt;handle(this); &#125; void setState(std::shared_ptr&lt;State&gt; state) &#123; state_ = state; printf(\"state change to %s\\n\", state_-&gt;name()); &#125;private: std::shared_ptr&lt;State&gt; state_;&#125;;class ConcreteStateA : public State&#123;public: ~ConcreteStateA()&#123;&#125; const char *name() const &#123; return \"StateA\";&#125; void handle(Context *ctx);&#125;;class ConcreteStateB : public State&#123;public: ~ConcreteStateB()&#123;&#125; const char *name() const &#123; return \"StateB\";&#125; void handle(Context *ctx);&#125;;void ConcreteStateA::handle(Context *ctx)&#123; if(ctx) ctx-&gt;setState(std::make_shared&lt;ConcreteStateB&gt;());&#125;void ConcreteStateB::handle(Context *ctx)&#123; if(ctx) ctx-&gt;setState(std::make_shared&lt;ConcreteStateA&gt;());&#125;int main()&#123; Context ctx(std::make_shared&lt;ConcreteStateA&gt;()); ctx.request(); ctx.request(); ctx.request(); return 0;&#125; 适配器模式原型1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;memory&gt;class Target&#123;public: virtual ~Target()&#123;&#125; void request() &#123; printf(\"normal request\\n\");&#125;&#125;;class Adaptee&#123;public: void specifiedRequest() &#123; printf(\"specified request\\n\");&#125;&#125;;class Adapter : public Target&#123;public: Adapter() &#123; adaptee_ = std::make_unique&lt;Adaptee&gt;(); &#125; void request() &#123; adaptee_-&gt;specifiedRequest(); &#125;private: std::unique_ptr&lt;Adaptee&gt; adaptee_;&#125;;int main()&#123; auto target = std::make_unique&lt;Adapter&gt;(); target-&gt;request(); return 0;&#125; 备忘录模式原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;memory&gt;struct Memento&#123; int state_;&#125;;class Originator&#123;public: ~Originator()&#123;printf(\"~Originator\\n\");&#125; std::shared_ptr&lt;Memento&gt; createMemento() &#123; auto memento = std::make_shared&lt;Memento&gt;(); memento-&gt;state_ = state_; return memento; &#125; void resetMemento(const std::shared_ptr&lt;Memento&gt; &amp;memento) &#123; state_ = memento-&gt;state_; &#125; void setState(int state) &#123; state_ = state;&#125; int state() &#123; return state_; &#125;private: int state_;&#125;;class Caretaker&#123;public: void setMemento(std::shared_ptr&lt;Memento&gt; memento) &#123; memento_ = memento; &#125; std::shared_ptr&lt;Memento&gt; getMemento() &#123; return memento_; &#125;private: std::shared_ptr&lt;Memento&gt; memento_;&#125;;int main()&#123; Originator origin; Caretaker taker; taker.setMemento(origin.createMemento()); origin.setState(5); origin.resetMemento(taker.getMemento()); return 0;&#125; 书上Memento是写成类的，但我觉得因为备忘录纯粹为了存储数据，或许用结构体更合适。只有Caretaker类是否需要，根据实际情况而定。 实例以memento为关键字搜索chromium源码，找到如下示例 12345678BrotliBitReaderState memento;BrotliBitReaderSaveState(br, &amp;memento);//保存数据if (!SafeReadSymbol(type_tree, br, &amp;block_type)) return BROTLI_FALSE;if (!SafeReadBlockLength(s, &amp;s-&gt;block_length[tree_type], len_tree, br)) &#123; s-&gt;substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_NONE; BrotliBitReaderRestoreState(br, &amp;memento);//重置数据 return BROTLI_FALSE;&#125; 其中BrotliBitReaderState声明如下123456typedef struct &#123; reg_t val_; uint32_t bit_pos_; const uint8_t* next_in; size_t avail_in;&#125; BrotliBitReaderState; 组合模式原型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;memory&gt;#include &lt;string&gt;#include &lt;list&gt;class Component&#123;public: Component(std::string name) : name_(name) &#123;&#125; virtual ~Component() &#123;printf(\"~Component\\n\");&#125; virtual void add(std::shared_ptr&lt;Component&gt;) = 0; virtual void remove(std::shared_ptr&lt;Component&gt;) = 0; virtual void display(int depth) = 0;protected: std::string name_;&#125;;class Leaf : public Component&#123;public: Leaf(std::string name) : Component(name) &#123;&#125; ~Leaf() &#123; printf(\"~Leaf\\n\");&#125; void add(std::shared_ptr&lt;Component&gt;) &#123; printf(\"Leaf do not support add\\n\");&#125; void remove(std::shared_ptr&lt;Component&gt;) &#123; printf(\"Leaf do not support remove\\n\");&#125; void display(int depth) &#123; for(int i = 0; i &lt; depth; ++i) printf(\"-\"); printf(\"%s\\n\", name_.c_str()); &#125;&#125;;class Composite : public Component&#123;public: Composite(std::string name) : Component(name) &#123;&#125; ~Composite() &#123;printf(\"~Composite\\n\");&#125; void add(std::shared_ptr&lt;Component&gt; comp) &#123; components_.push_back(comp); &#125; void remove(std::shared_ptr&lt;Component&gt; comp) &#123; components_.remove(comp); &#125; void display(int depth) &#123; for(int i = 0; i &lt; depth; ++i) printf(\"-\"); printf(\"%s\\n\", name_.c_str()); for(auto i : components_) i-&gt;display(depth + 1); &#125;private: std::list&lt;std::shared_ptr&lt;Component&gt;&gt; components_;&#125;;int main()&#123; auto bj = std::make_shared&lt;Composite&gt;(\"beijing\"); bj-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); bj-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); auto sh = std::make_shared&lt;Composite&gt;(\"shanghai\"); bj-&gt;add(sh); sh-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); sh-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); auto nj = std::make_shared&lt;Composite&gt;(\"nanjing\"); nj-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); nj-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); auto hz = std::make_shared&lt;Composite&gt;(\"hangzhou\"); hz-&gt;add(std::make_shared&lt;Leaf&gt;(\"renshi\")); hz-&gt;add(std::make_shared&lt;Leaf&gt;(\"caiwu\")); sh-&gt;add(nj); sh-&gt;add(hz); bj-&gt;display(0); return 0;&#125; 迭代器模式感觉没啥用，不如直接用stl里的 单例模式原型123456789101112131415161718192021222324#include &lt;stdio.h&gt;class Singleton&#123;public: static Singleton *instance() &#123; if(instance_ == nullptr) instance_ = new Singleton; return instance_; &#125; void display()&#123;printf(\"this is Singleton\\n\");&#125;private: static Singleton *instance_; Singleton() &#123; printf(\"Singleton constructor\\n\");&#125;&#125;;Singleton *Singleton::instance_ = nullptr;int main()&#123; Singleton::instance()-&gt;display(); return 0;&#125; 多线程时的单例模式如果两个线程同时调用instance()函数，极有可能导致Singleton被初始化两次。违背了单例模式的意图。可通过双重锁定解决这种问题 1234567891011121314#include &lt;mutex&gt;static Singleton *instance()&#123; if(instance_ == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lk(mut); if(instance_ == nullptr) &#123; instance_ = new Singleton; &#125; &#125; return instance_;&#125; 《C++并发编程实战》中说这种双重锁是声名狼藉的，也就是不好的。没有完全理解为什么这么说。 桥接模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Implementor&#123;public: virtual ~Implementor() &#123; printf(\"~Implementor\\n\");&#125; virtual void operation() = 0;&#125;;class Abstraction&#123;public: virtual ~Abstraction() &#123; printf(\"~Abstraction\\n\");&#125; void setImpl(std::shared_ptr&lt;Implementor&gt; impl) &#123; impl_ = impl; &#125; virtual void operation() = 0;protected: std::shared_ptr&lt;Implementor&gt; impl_;&#125;;class RedifinedAbstraction : public Abstraction&#123;public: ~RedifinedAbstraction() &#123; printf(\"~RedifinedAbstraction\\n\");&#125; void operation() &#123; if(impl_) impl_-&gt;operation(); &#125;&#125;;class ConcreteImplementorA : public Implementor&#123;public: ~ConcreteImplementorA() &#123; printf(\"~ConcreteImplementorA\\n\");&#125; void operation() &#123; printf(\"operation A called\\n\");&#125;&#125;;class ConcreteImplementorB : public Implementor&#123;public: ~ConcreteImplementorB() &#123; printf(\"~ConcreteImplementorB\\n\");&#125; void operation() &#123; printf(\"operation B called\\n\");&#125;&#125;;int main()&#123; auto caller = std::make_unique&lt;RedifinedAbstraction&gt;(); auto implA = std::make_shared&lt;ConcreteImplementorA&gt;(); auto implB = std::make_shared&lt;ConcreteImplementorB&gt;(); caller-&gt;setImpl(implA); caller-&gt;operation(); caller-&gt;setImpl(implB); caller-&gt;operation(); return 0;&#125; 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;memory&gt;class App&#123;public: virtual ~App() &#123; printf(\"~App\\n\");&#125; virtual void run() = 0;&#125;;class Phone&#123;public: Phone() : app_(nullptr) &#123;&#125; virtual ~Phone() &#123; printf(\"~Phone\\n\");&#125; void setApp(std::shared_ptr&lt;App&gt; app) &#123; app_ = app; &#125; virtual void run() = 0;protected: std::shared_ptr&lt;App&gt; app_;&#125;;class WangZheRongYao : public App&#123;public: ~WangZheRongYao() &#123; printf(\"~WangZheRongYao\\n\");&#125; void run() &#123; printf(\"run wang zhe rong yao\\n\");&#125;&#125;;class ZhiFuBao : public App&#123;public: ~ZhiFuBao() &#123; printf(\"~ZhiFuBao\\n\");&#125; void run() &#123; printf(\"run zhi fu bao\\n\");&#125;&#125;;class HuaWei : public Phone&#123;public: ~HuaWei() &#123; printf(\"~HuaWei\\n\");&#125; void run() &#123; if(app_) &#123; printf(\"current phone is huawei, \"); app_-&gt;run(); &#125; &#125;&#125;;class XioMi : public Phone&#123;public: ~XioMi() &#123; printf(\"~XioMi\\n\");&#125; void run() &#123; if(app_) &#123; printf(\"curren phone is xioami, \"); app_-&gt;run(); &#125; &#125;&#125;;int main()&#123; auto huawei = std::make_unique&lt;HuaWei&gt;(); auto xiaomi = std::make_unique&lt;XioMi&gt;(); auto wzry = std::make_shared&lt;WangZheRongYao&gt;(); auto zfb = std::make_shared&lt;ZhiFuBao&gt;(); huawei-&gt;setApp(wzry); huawei-&gt;run(); huawei-&gt;setApp(zfb); huawei-&gt;run(); xiaomi-&gt;setApp(wzry); xiaomi-&gt;run(); xiaomi-&gt;setApp(zfb); xiaomi-&gt;run(); return 0;&#125; 命令模式原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Receiver&#123;public: virtual ~Receiver() &#123; printf(\"~Receiver\\n\");&#125; void action() &#123; printf(\"recver action\\n\");&#125;&#125;;class Command&#123;public: explicit Command(std::shared_ptr&lt;Receiver&gt; recver) : recver_(recver) &#123;&#125; virtual ~Command () &#123; printf(\"~Command\\n\");&#125; virtual void execute() = 0;protected: std::shared_ptr&lt;Receiver&gt; recver_;&#125;;class ConcreteCommand : public Command&#123;public: explicit ConcreteCommand(std::shared_ptr&lt;Receiver&gt; recver) : Command(recver) &#123;&#125; ~ConcreteCommand() &#123; printf(\"~ConcreteCommand\\n\");&#125; void execute() &#123; if(recver_) recver_-&gt;action(); &#125;&#125;;class Invoker&#123;public: void setCommand(std::shared_ptr&lt;Command&gt; cmd) &#123; cmd_ = cmd; &#125; void notify() &#123; if(cmd_) cmd_-&gt;execute(); &#125;private: std::shared_ptr&lt;Command&gt; cmd_;&#125;;int main()&#123; Invoker invoker; auto recver = std::make_shared&lt;Receiver&gt;(); auto cmd = std::make_shared&lt;ConcreteCommand&gt;(recver); invoker.setCommand(cmd); invoker.notify(); return 0;&#125; 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;memory&gt;#include &lt;list&gt;class Barbecuer&#123;public: ~Barbecuer() &#123; printf(\"~Barbecuer\\n\");&#125; void bakeMutton() &#123; printf(\"bake mutton\\n\");&#125; void bakeChicken() &#123; printf(\"bake chicken\\n\");&#125;&#125;;class Command&#123;public: explicit Command(std::shared_ptr&lt;Barbecuer&gt; recver) : recver_(recver) &#123;&#125; virtual ~Command() &#123; printf(\"~Command\\n\");&#125; virtual void execute() = 0;protected: std::shared_ptr&lt;Barbecuer&gt; recver_;&#125;;class MuttonCommand : public Command&#123;public: explicit MuttonCommand(std::shared_ptr&lt;Barbecuer&gt; recver) : Command(recver) &#123;&#125; ~MuttonCommand() &#123; printf(\"~MuttonCommand\\n\");&#125; void execute() &#123; if(recver_) recver_-&gt;bakeMutton(); &#125;&#125;;class ChickedCommand : public Command&#123;public: explicit ChickedCommand(std::shared_ptr&lt;Barbecuer&gt; recver) : Command(recver) &#123;&#125; ~ChickedCommand() &#123; printf(\"~ChickedCommand\\n\");&#125; void execute() &#123; if(recver_) recver_-&gt;bakeChicken(); &#125;&#125;;class Waiter&#123;public: void addOrder(std::shared_ptr&lt;Command&gt; cmd) &#123; cmds_.push_back(cmd); &#125; void cancelOrder(std::shared_ptr&lt;Command&gt; cmd) &#123; cmds_.remove(cmd); &#125; void notify() &#123; for(auto &amp; cmd : cmds_) cmd-&gt;execute(); &#125;private: std::list&lt;std::shared_ptr&lt;Command&gt;&gt; cmds_;&#125;;int main()&#123; Waiter mm; auto gg = std::make_shared&lt;Barbecuer&gt;(); auto muttonCmd = std::make_shared&lt;MuttonCommand&gt;(gg); auto chickenCmd = std::make_shared&lt;ChickedCommand&gt;(gg); mm.addOrder(muttonCmd); mm.addOrder(chickenCmd); mm.cancelOrder(muttonCmd); mm.notify();&#125; 职责连模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;memory&gt;class Handler&#123;public: virtual ~Handler() &#123; printf(\"~Handler\\n\");&#125; virtual void handleRequest(int level) = 0; void setSuccessor(std::shared_ptr&lt;Handler&gt; successor) &#123; successor_ = successor; &#125;protected: std::shared_ptr&lt;Handler&gt; successor_;&#125;;class ConcreteHandlerA : public Handler&#123;public: ~ConcreteHandlerA() &#123; printf(\"~ConcreteHandlerA\\n\");&#125; void handleRequest(int level) &#123; if(level &lt; 10) printf(\"request handle by A\\n\"); else if(successor_) successor_-&gt;handleRequest(level); &#125;&#125;;class ConcreteHandlerB : public Handler&#123;public: ~ConcreteHandlerB() &#123; printf(\"~ConcreteHandlerB\\n\");&#125; void handleRequest(int level) &#123; printf(\"request handle by B\\n\"); &#125;&#125;;int main()&#123; auto handlerA = std::make_shared&lt;ConcreteHandlerA&gt;(); auto handlerB = std::make_shared&lt;ConcreteHandlerB&gt;(); handlerA-&gt;setSuccessor(handlerB); handlerA-&gt;handleRequest(5); handlerA-&gt;handleRequest(20);&#125; 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081struct Request&#123; std::string type; int num;&#125;;class Manager&#123;public: Manager() : super_(nullptr) &#123;&#125; virtual ~Manager() &#123; printf(\"~Manager\\n\");&#125; void setSuperior(std::shared_ptr&lt;Manager&gt; super) &#123; super_ = super; &#125; virtual void handleRequest(const Request &amp;req) = 0;protected: std::shared_ptr&lt;Manager&gt; super_;&#125;;class Jinli : public Manager&#123;public: ~Jinli() &#123; printf(\"~Jinli\\n\");&#125; void handleRequest(const Request &amp;req) &#123; if(req.type == \"qingjia\" &amp;&amp; req.num &lt;= 10) printf(\"qingjia %d day passed by Jinli\\n\", req.num); else if(super_) super_-&gt;handleRequest(req); &#125;&#125;;class ZongJinli : public Manager&#123;public: ~ZongJinli() &#123; printf(\"~Zongjinli\\n\");&#125; void handleRequest(const Request &amp;req) &#123; if(req.type == \"qingjia\" &amp;&amp; req.num &lt;= 100) printf(\"qingjia %d day passed by ZongJinli\\n\", req.num); else if(super_) super_-&gt;handleRequest(req); &#125;&#125;;class Boss : public Manager&#123;public: ~Boss() &#123; printf(\"~Boss\\n\");&#125; void handleRequest(const Request &amp;req) &#123; if(req.type == \"qingjia\") printf(\"qingjia %d day passed by Boss\\n\", req.num); else if(req.type == \"zhanggongzi\" &amp;&amp; req.num &lt;= 1000) printf(\"zhanggongzi %d yuan passed by Boss\\n\", req.num); else if(req.type == \"zhanggongzi\" &amp;&amp; req.num &gt; 1000) printf(\"shao nian zai deng deng ba\\n\"); &#125;&#125;;int main()&#123; auto jinli = std::make_shared&lt;Jinli&gt;(); auto zongjinli = std::make_shared&lt;ZongJinli&gt;(); auto boss = std::make_shared&lt;Boss&gt;(); jinli-&gt;setSuperior(zongjinli); zongjinli-&gt;setSuperior(boss); Request req; req.type = \"qingjia\"; req.num = 3; jinli-&gt;handleRequest(req); req.type = \"qingjia\"; req.num = 20; jinli-&gt;handleRequest(req); req.type = \"qingjia\"; req.num = 365; jinli-&gt;handleRequest(req); req.type = \"zhanggongzi\"; req.num = 500; jinli-&gt;handleRequest(req); req.type = \"zhanggongzi\"; req.num = 10000; jinli-&gt;handleRequest(req);&#125; 中介者模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;memory&gt;class Colleague;class Mediator&#123;public: virtual ~Mediator() &#123; printf(\"~Mediator\\n\");&#125; virtual void send(const Colleague *, const std::string &amp;) const = 0;&#125;;class Colleague&#123;public: explicit Colleague(std::shared_ptr&lt;Mediator&gt; mediator) : mediator_(mediator) &#123;&#125; virtual ~Colleague() &#123; printf(\"~Colleague\\n\");&#125; virtual void sendMsg(const std::string &amp;msg) const = 0; virtual void notify(const std::string &amp;msg) const = 0;protected: std::shared_ptr&lt;Mediator&gt; mediator_;&#125;;class ConcreteColleagueA : public Colleague&#123;public: explicit ConcreteColleagueA(std::shared_ptr&lt;Mediator&gt; mediator) : Colleague(mediator) &#123;&#125; ~ConcreteColleagueA() &#123; printf(\"~ConcreteColleagueA\\n\");&#125; void sendMsg(const std::string &amp;msg) const &#123; printf(\"colleague A send msg:%s\\n\", msg.c_str()); mediator_-&gt;send(this, msg); &#125; void notify(const std::string &amp;msg) const &#123; printf(\"colleague A get msg:%s\\n\", msg.c_str()); &#125;&#125;;class ConcreteColleagueB : public Colleague&#123;public: explicit ConcreteColleagueB(std::shared_ptr&lt;Mediator&gt; mediator) : Colleague(mediator) &#123;&#125; ~ConcreteColleagueB() &#123; printf(\"~ConcreteColleagueB\\n\");&#125; void sendMsg(const std::string &amp;msg) const &#123; printf(\"colleague B send msg:%s\\n\", msg.c_str()); mediator_-&gt;send(this, msg); &#125; void notify(const std::string &amp;msg) const &#123; printf(\"colleague B get msg:%s\\n\", msg.c_str()); &#125;&#125;;class ConcreteMediator : public Mediator&#123;public: ~ConcreteMediator() &#123; printf(\"~ConcreteMediator\\n\");&#125; void setColleagueA(ConcreteColleagueA *ca) &#123; colleagueA_ = ca; &#125; void setColleagueB(ConcreteColleagueB *cb) &#123; colleagueB_ = cb; &#125; void send(const Colleague *colleague, const std::string &amp;msg) const &#123; if(colleague == colleagueA_) colleagueB_-&gt;notify(msg); else if(colleague == colleagueB_) colleagueA_-&gt;notify(msg); &#125;private: ConcreteColleagueA *colleagueA_; ConcreteColleagueB *colleagueB_;&#125;;int main()&#123; auto mediator = std::make_shared&lt;ConcreteMediator&gt;(); auto colleagueA = std::make_unique&lt;ConcreteColleagueA&gt;(mediator); auto colleagueB = std::make_unique&lt;ConcreteColleagueB&gt;(mediator); mediator-&gt;setColleagueA(colleagueA.get()); mediator-&gt;setColleagueB(colleagueB.get()); colleagueA-&gt;sendMsg(\"How are you!\"); colleagueB-&gt;sendMsg(\"Fine, thank you, and you!\"); return 0;&#125; 享元模式原型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;string&gt;class Flyweight&#123;public: virtual ~Flyweight() &#123; printf(\"~Flyweight\\n\");&#125; virtual void operation(int) = 0;&#125;;class ConcreteFlyweight : public Flyweight&#123;public: ~ConcreteFlyweight() &#123; printf(\"ConcreteFlyweight\\n\");&#125; void operation(int extrinsicstate) &#123; printf(\"concrete operation : %d\\n\", extrinsicstate); &#125;&#125;;class UnsharedConcreteFlyweight : public Flyweight&#123;public: ~UnsharedConcreteFlyweight() &#123; printf(\"~UnsharedConcreteFlyweight\\n\");&#125; void operation(int extrinsicstate) &#123; printf(\"unshared operation : %d\\n\", extrinsicstate); &#125;&#125;;class FlyweightFactorty&#123;public: FlyweightFactorty() &#123; flyweights_[\"X\"] = std::make_shared&lt;ConcreteFlyweight&gt;(); flyweights_[\"Y\"] = std::make_shared&lt;ConcreteFlyweight&gt;(); flyweights_[\"Z\"] = std::make_shared&lt;ConcreteFlyweight&gt;(); &#125; std::shared_ptr&lt;Flyweight&gt; &amp;getFlyweight(const std::string &amp;key) &#123; return flyweights_[key]; &#125;private: std::map&lt;std::string, std::shared_ptr&lt;Flyweight&gt;&gt; flyweights_;&#125;;int main()&#123; FlyweightFactorty factory; int extrinsicstate = 22; auto f1 = factory.getFlyweight(\"X\"); f1-&gt;operation(--extrinsicstate); auto f2 = factory.getFlyweight(\"Y\"); f2-&gt;operation(--extrinsicstate); auto f3 = factory.getFlyweight(\"Z\"); f3-&gt;operation(--extrinsicstate); auto unshared = std::make_unique&lt;UnsharedConcreteFlyweight&gt;(); unshared-&gt;operation(--extrinsicstate);&#125; 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct User&#123; User(const std::string &amp;id) : id_(id) &#123;&#125; std::string id_;&#125;;class Website&#123;public: virtual ~Website() &#123; printf(\"~Website\\n\");&#125; virtual void visit(const User &amp;) = 0;&#125;;class ConcreteWebsite : public Website&#123;public: explicit ConcreteWebsite(const std::string &amp;name) : name_(name) &#123;&#125; ~ConcreteWebsite() &#123; printf(\"~ConcreteWebsite\\n\");&#125; void visit(const User &amp;usr) &#123; printf(\"user %s visit website %s\\n\", usr.id_.c_str(), name_.c_str()); &#125;private: std::string name_;&#125;;class WebsiteFactory&#123;public: std::shared_ptr&lt;Website&gt; &amp;getWesite(const std::string &amp;key) &#123; if(websites_.find(key) == websites_.end()) websites_[key] = std::make_shared&lt;ConcreteWebsite&gt;(key); return websites_[key]; &#125;private: std::map&lt;std::string, std::shared_ptr&lt;Website&gt;&gt; websites_;&#125;;int main()&#123; WebsiteFactory factory; auto web1 = factory.getWesite(\"blog\"); web1-&gt;visit(User(\"kongdb\")); auto web2 = factory.getWesite(\"blog\"); web2-&gt;visit(User(\"yzy\")); auto web3 = factory.getWesite(\"game\"); web3-&gt;visit(User(\"fff\")); auto web4 = factory.getWesite(\"game\"); web4-&gt;visit(User(\"ggg\"));&#125; 解释器模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;memory&gt;class Context&#123;public: void setInput(const std::string &amp;in) &#123; input_ = in; &#125; const std::string &amp;input() const &#123; return input_; &#125; void setOutput(const std::string &amp;out) &#123; output_ = out; &#125; const std::string &amp;output() const &#123; return output_; &#125;private: std::string input_; std::string output_;&#125;;class AbstractExpression&#123;public: virtual ~AbstractExpression() &#123; printf(\"~AbstractExpression\\n\");&#125; virtual void interpret(Context &amp;ctx) = 0;&#125;;class TerminalExpression : public AbstractExpression&#123;public: ~TerminalExpression() &#123; printf(\"~TerminalExpression\\n\");&#125; void interpret(Context &amp;ctx) &#123; printf(\"terminal expression\\n\");&#125;&#125;;class NonTerminalExpression : public AbstractExpression&#123;public: ~NonTerminalExpression() &#123; printf(\"~NonTerminalExpression\\n\");&#125; void interpret(Context &amp;ctx) &#123; printf(\"non terminal expression\\n\");&#125;&#125;;int main()&#123; Context ctx; auto terminal = std::make_unique&lt;TerminalExpression&gt;(); terminal-&gt;interpret(ctx); auto nonterminal = std::make_unique&lt;NonTerminalExpression&gt;(); nonterminal-&gt;interpret(ctx); return 0;&#125; 实例-音乐解释器描述 O表示音阶，‘O 1’表示低音阶，‘O 2’表示中音阶，‘O 3’高音阶 P表示休止符 ‘C D E F G A B’ 表示‘Do-Re-Mi-Fa-So-La-Ti’ 音符长度1表示一拍，2表示二拍，0.5表示半拍，0.25表示1/4拍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133class PlayContext&#123;public: void setPlatText(const std::string &amp;text) &#123; playText_ = text; &#125; std::string playText() const &#123; return playText_; &#125;private: std::string playText_;&#125;;class Expression&#123;public: virtual ~Expression() &#123; printf(\"~Expression\\n\");&#125; void interpret(PlayContext &amp;ctx) &#123; std::string text = ctx.playText(); if(text.empty()) return; //首字母为键 char key = text[0]; //第一个到第二个空格之间的为value size_t pos = text.find(' ', 2); double value = std::stod(text.substr(2, pos - 2)); ctx.setPlatText(text.substr(pos + 1)); execute(key, value); &#125; virtual void execute(char key, double value) = 0;&#125;;//音阶class Scale : public Expression&#123;public: ~Scale() &#123; printf(\"~Scale\\n\");&#125; void execute(char key, double value) &#123; if(key != 'O') &#123; printf(\"error scale :%c\\n\", key); return; &#125; int intVal = int(value); switch(intVal) &#123; case 1: printf(\"lowPitch \"); break; case 2: printf(\"midPitch \"); break; case 3: printf(\"highPitch \"); break; default: break; &#125; &#125;&#125;;//音符class Note : public Expression&#123;public: ~Note() &#123; printf(\"~Note\\n\");&#125; void execute(char key, double value) &#123; const char *note; switch(key) &#123; case 'C': note = \"Do\"; break; case 'D': note = \"Re\"; break; case 'E': note = \"Mi\"; break; case 'F': note = \"Fa\"; break; case 'G': note = \"So\"; break; case 'A': note = \"La\"; break; case 'B': note = \"Ti\"; break; default: note = \"\"; break; &#125; printf(\"%s \", note); &#125;&#125;;int main()&#123; PlayContext ctx; ctx.setPlatText(\"O 2 E 0.5 G 0.5 A 3 E 0.5 G 0.5 D 3 E 0.5 G 0.5 A 0.5 O 3 C 1 O 2 A 0.5 G 1 C 0.5 E 0.5 D 3 \"); auto scaleExp = std::make_shared&lt;Scale&gt;(); auto noteExp = std::make_shared&lt;Note&gt;(); while(!ctx.playText().empty()) &#123; char key = ctx.playText()[0]; std::shared_ptr&lt;Expression&gt; exp = nullptr; switch(key) &#123; case 'O': exp = scaleExp; break; case 'C': case 'D': case 'E': case 'F': case 'G': case 'A': case 'B': exp = noteExp; break; default: break; &#125; if(exp) exp-&gt;interpret(ctx); &#125; printf(\"\\n\"); return 0;&#125; 访问者模式原型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;list&gt;#include &lt;memory&gt;class ElementA;class ElementB;class Visitor&#123;public: virtual ~Visitor() &#123; printf(\"~Visitor\\n\");&#125; virtual void visitA(ElementA *) = 0; virtual void visitB(ElementB *) = 0;&#125;;class Element&#123;public: virtual ~Element() &#123; printf(\"~Element\\n\");&#125; virtual void accept(std::shared_ptr&lt;Visitor&gt;) = 0;&#125;;class ElementA : public Element&#123;public: ~ElementA() &#123; printf(\"~ElementA\\n\");&#125; void accept(std::shared_ptr&lt;Visitor&gt; visitor) &#123; visitor-&gt;visitA(this); &#125;&#125;;class ElementB : public Element&#123;public: ~ElementB() &#123; printf(\"~ElementB\\n\");&#125; void accept(std::shared_ptr&lt;Visitor&gt; visitor) &#123; visitor-&gt;visitB(this); &#125;&#125;;class ConcreteVisitor1 : public Visitor&#123;public: ~ConcreteVisitor1() &#123; printf(\"~ConcreteVisitor1\\n\");&#125; void visitA(ElementA *) &#123; printf(\"ElementA visited by visitor1\\n\");&#125; void visitB(ElementB *) &#123; printf(\"ElementB visited by visitor1\\n\");&#125;&#125;;class ConcreteVisitor2 : public Visitor&#123;public: ~ConcreteVisitor2() &#123; printf(\"~ConcreteVisitor2\\n\");&#125; void visitA(ElementA *) &#123; printf(\"ElementA visited by visitor2\\n\");&#125; void visitB(ElementB *) &#123; printf(\"ElementB visited by visitor2\\n\");&#125;&#125;;class ObjectStructre&#123;public: void attach(std::shared_ptr&lt;Element&gt; ele) &#123; elements_.push_back(ele); &#125; void detach(std::shared_ptr&lt;Element&gt; ele) &#123; elements_.remove(ele); &#125; void accept(std::shared_ptr&lt;Visitor&gt; visitor) &#123; for(const auto &amp;ele : elements_) ele-&gt;accept(visitor); &#125;private: std::list&lt;std::shared_ptr&lt;Element&gt;&gt; elements_;&#125;;int main()&#123; ObjectStructre obj; obj.attach(std::make_shared&lt;ElementA&gt;()); obj.attach(std::make_shared&lt;ElementB&gt;()); auto v1 = std::make_shared&lt;ConcreteVisitor1&gt;(); auto v2 = std::make_shared&lt;ConcreteVisitor2&gt;(); obj.accept(v1); obj.accept(v2);&#125;","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"统计超大文件中字符串出现次数","date":"2017-11-25T11:50:17.000Z","path":"2017/11/25/统计超大文件中字符串出现次数/","text":"背景：有一个超大的文件，需要统计里面某个字符串出现的次数 注：下文中的log.txt为500万行左右 Python实现逐行读取方式（单线程）1234567891011count = 0def getCountInFile(fname, s): global count with open(fname, 'rb') as f: for line in f: count += line.count(s)if __name__ == '__main__': getCountInFile('log.txt', b'kongdb') print('total count is:%d' % count) 使用Ipython timeit命令得出时间大概在2.8s 123456%timeit %run single_thread_1.pytotal count is:884736total count is:884736total count is:884736total count is:8847361 loop, best of 3: 2.78 s per loop 逐块读取方式（单线程）1234567891011121314151617181920import oscount = 0#逐块读取，每块的大小CHUNK_SIZE = 500000def getCountInFile(fname, s): global count #先获取文件总大小 total_size = os.path.getsize(fname) with open(fname, 'rb') as f: #分块 piece_count = int(total_size/CHUNK_SIZE) + 1 for i in range(piece_count): content = f.read(CHUNK_SIZE) count += content.count(s)if __name__ == '__main__': getCountInFile('log.txt', b'kongdb') print('total count is:%d' % count) 使用Ipython timeit命令得出时间大概在80ms 1234567%timeit %run single_thread_2.pytotal count is:884736total count is:884736...total count is:884736total count is:88473610 loops, best of 3: 79.3 ms per loop 不过我想了一下，这样分块可能会存在这样一个问题。 比如第n块的最后一个字母是’k’，而第n+1块的前几个字母是’ongdb’，即分的块正好把待查询的子块切割了。这样就会导致子块遗漏了。 想了以下的解决办法，可能不是太好。 123456789...current_pos = 0for i in range(piece_count): content = f.read(CHUNK_SIZE) count += content.count(s) #每次读完一个子块之后，位置向后退\"子串长度减1\"个字符 current_pos += CHUNK_SIZE - len(s) + 1 f.seek(current_pos)... 逐行读取方式（多线程）尝试使一个线程从某一个固定行开始读取，但是因为Python没有从某一行开始读取的方法。只能使用next(f)这种方法来跳过前n行。但这样并不能使时间减少。放弃 也有可能是我使用的方法不对。 逐块读取方式（多线程）Python有seek方法来跳过前n个字符。所以思路就是： 每个线程都有一个start属性 先跳过前start个字符 读取一个固定大小的块，并计算count 合并各个线程的结果 123456789101112131415161718192021222324252627282930313233import osimport threadingg_lock = threading.Lock()count = 0#逐块读取，每块的大小CHUNK_SIZE = 500000def getCountInFile(fname, start, s): with open(fname, 'rb') as f: f.seek(start) content = f.read(CHUNK_SIZE + len(s) -1) if not content: return with g_lock: global count count += content.count(s)#线程列表threads = []if __name__ == '__main__': fname = 'log.txt' #先获取文件总大小 total_size = os.path.getsize(fname) for i in range(int(total_size/CHUNK_SIZE) + 1): t = threading.Thread(target=getCountInFile, args=(fname, i*CHUNK_SIZE, b'kongdb')) threads.append(t) for t in threads: t.start() for t in threads: t.join() print('total count is:%d' % count) 想法很天真，然鹅 1234567%timeit %run multithread_thread_1.pytotal count is:884736total count is:884736...total count is:884736total count is:88473610 loops, best of 3: 105 ms per loop 时间并没有实际缩短，还增加了大约20ms，汗。 是因为Python的GIL限制了呢，还是我的使用方法不正确呢。 C++实现C++ std里的读写文件用的不是很多，但理所当然的觉得C++肯定要比Python快吧 然而结果好像并不是这样的。 先实现统计子串次数的函数 123456789101112131415161718#include \"stdafx.h\"#include &lt;string&gt;#include &lt;stdio.h&gt;//统计子串出现次数int getStrCount(const char *src, const char *sub)&#123; int len = strlen(sub); if (src == nullptr || sub == nullptr || strlen(src) == 0 || len == 0) return 0; int num = 0; while (src = strstr(src, sub)) &#123; num++; src += len; &#125; return num;&#125; 逐行读取方式（单线程）12345678910111213141516171819202122#include &lt;fstream&gt;#include&lt;windows.h&gt;static int count = 0;void getCountInFile(const char *fname, const char *sub)&#123; std::ifstream f(fname); while (!f.eof()) &#123; char line[51] = \"\\0\"; f.getline(line, 50); count += getStrCount(line, sub); &#125;&#125;int main()&#123; int start = GetTickCount(); getCountInFile(\"log.txt\", \"kongdb\"); int end = GetTickCount(); printf(\"time elapse:%d\\n\", end - start); printf(\"total count is:%d\\n\", count); return 0;&#125; 其中使用GetTickCount函数来计算性能 结果如下 time elapse:8531total count:884736 大约是8.5s，竟然比Python的逐行读取慢这么多，不科学啊。","tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python数据分析与展示笔记","date":"2017-11-17T11:50:17.000Z","path":"2017/11/17/Python数据分析与展示笔记/","text":"IPython常用命令 常用命令 说明 ? 查看变量名函数名 %run 执行某个python文件 %magic 显示所有魔术命令 %hist IPython命令的输入历史 %pdb 异常发生后自动进入调试器 %reset 删除当前命名空间中的全部变量和名称 %who 显示当前命名空间中已经定义的变量 %time 给出代码的执行时间 %timeit 多次执行代码，计算综合平均执行时间 NumPy库一般导入方法 1import numpy as np ndarray类型**数组对象可以去掉元素间运算所需的循环，使一维向量更像单个数据 123a = np.array([1, 3, 5])b = np.array([2, 4, 6])c = a**2 + b**3 **设置专门的数组对象，经过优化，可以提升运算速度 **数组对象采用相同的数据类型，有助于节省运算和存储空间 ndarray是一个多维数组对象，由两部分组成 实际的数据 描述这些数据的元数据（数据维度、数据类型等） ndarray对象的属性 属性 说明 ndim 秩，即轴的数量或维度的数量 shape 对象的尺度，对于矩阵，n行m列 size 对象元素的个数，相当于shape的n*m dtype 对象的元素类型 itemsize 对象中每个元素的大小，以字节为单位 ndarray的元素类型 数据类型 说明 bool True或False intc 与C语言中的int类型一致，一般是int32或int64 intp 用于索引的整数 int8 字节字节长度的整数[-128, 127] int16,int32,int64 对应长度类型的整数 uint8,uint16,uint32,uint32,uint64 对应长度的无符号整数 float16 1位符号位，5位指数，10位尾数 float32 1位符号位，8位指数，23位尾数 float64 1位符号位，11位指数，52位尾数 complex64 实部虚部都是32位浮点数 complex128 实部虚部都是64位浮点数 ndarray数组的创建方法 从Python的列表，元祖等类型创建 12a = np.array([1, 2, 3])b = np.array((4, 5.2), dtype=np.float32) 使用NumPy的函数创建ndarray数组，如arrange,ones,zeros 函数 说明 np.arrange(n) 类似range函数，返回ndarray类型，从0到n-1 np.ones(shape) 根据shape生成全1的数组，如np.ones((3, 5)) np.zeros(shape) 类似，全0数组 np.full(shape, val) 类似，数据全为val np.eyes(shanpe) 类似，对角线为1，其他为0 np.ones_like(a) 根据数组a生成全1的数组 np.zeros_like(a) 类似，全0 np.full_like(a, val) 类似，全val np.linspace() 根据起止数据等间距地填充数据 np.concatenate() 将两个或多个数组合并 例子 123456In: a = np.linspace(1, 10, 4)Out: array([1., 4., 7., 10.])In: b = np.linspace(1, 10, 4, endpoint=False)Out: array([1., 3.25, 5.5, 7.75])In: c = np.concatenate((a, b))Out: array([1., 4., 7., 10., 1., 3.25, 5.5, 7.75]) ndarray数组的维度变换 方法 说明 reshape(shape) 不改变数组元素，返回一个shape形状的数组，原数组不变 resize(shape) 与reshape一致，但修改原数组 swapaxes(ax1, ax2) 将数组n维度中的2个维度互换 flatten() 对数组进行将为，返回1维数组，原数组不变 ndarray数组的类型变换 1b = a.astype(new_type) astype会创建新数组，原数组不变 ndarray数组向列表转换 1ls = a.tolist() 从字节流（raw bytes）中创建 从文件中读取特定格式 数组的索引和切片一维数组的索引和切片与Python的列表一致 123456In: a = np..array([9, 8, 7, 6, 5])In: a[2]Out: 7In: a[1:4:2]Out: array([8, 6]) 多维数组的索引 1234In: a = np.arange(24).reshape((2, 3, 4))In: a[1, 2, 3] #逗号分隔Out: 23In: a[:, 1:3, :] #每个维度类似1维数组[起:止:间隔] ndarray数组的运算 数组与标量之间的运算作用于每一个元素 NumPy一元函数，元素级的运算 函数 说明 np.abs(x) np.fabs(x) 计算各元素的绝对值 np.sqrt(x) 计算各元素的平方根 np.square(x) 计算各元素的评分 np.log(x) np.log10(x) np.log2(x) 计算各元素的自然对数，10底对数，2底对数 np.ceil(x) np.floor(x) 计算各元素的celling和floor值 np.rint(x) 计算各元素四舍五入值 np.modf(x) 返回小数和整数部分两个数组 np.cos/sin/cosh/sinh/tan/tanh 三角函数值 np.exp(x) 各元素的指数值 np.sign(x) 各元素的符号值 Numpy的二元函数 函数 说明 + - / * 两个数组各元素运算 np.maximum(x, y) np.fmax() 两个数组逐个元素比较，返回较大元素组成的数组 np.minimum(x, y) np.fmin() 两个数组逐个元素比较，返回较小元素组成的数组 np.mod(x, y) 元素级的模运算 np.copysign(x, y) 将y数组各元素的符号值赋值给x &gt; &lt; &gt;= &lt;= == != 算术比较，返回bool型数组 CSV文件读写1,2维数据读写np.savetxt(frame, array, fmt=’%.18e’, delimiter=None) 12a = np.arange(100).reshape(5, 20)np.savetxt('a.csv', a, fmt='%d', delimiter=',') np.loadtxt(frame, dtype=np.float, delimiter=None, unpack=False) 1b = np.loadtxt('a.csv', dtype=np.int, delimiter=',') 多维数据的读写a.tofile(frame, sep=’’, format=’%s’) 123a = np.arange(100).reshape(5, 10, 2)a.tofile('a.bat', sep=',', format='%d')#不指定sep则保存为二进制 a.fromfile(frame, dtype=float, count=-1, sep=’’) 1b = np.fromfile('a.bat', dtype=np.int, sep=',') 便捷文件存取np.save(fname, array) np.savez(fname, array) fname以npy/npz结尾 np.load(fname) 123a = np.arange(100).reshape(5, 10, 2)np.save('a.npy', a)b = np.load('a.npy') Numpy的随机数函数np.random的随机数函数 函数 说明 rand(d0, d1,…dn) 根据d0-dn的shape创建随机数数组，[0, 1)均匀分布 randn(d0, d1,…dn) 根据d0-dn的shape创建随机数数组，标准正态分布 randint(low, high, shape) 根据shape创建随机数组，范围[low, high) seeds(s) 随机数种子 shuffle(a) 根据数组啊的第一轴进行随机排列，改变数组a permutation(a) 同上，但生成新数组，不改变原数组 choice(a[,size,replace,p]) 从一维数组a中以概率p抽取元素，形成size形状新数组；replace表示是否可以重用元素，默认False uniform(loc, scale, size) 产生具有均匀分布的数组 normal(low, high, size) 产生具有正态分布的数组， loc均值，scale标准差 poisson(lam, size) 产生具有泊松分布的数组，lam随机事件发生概率 NumPy的统计函数 函数 说明 sum(a, axis=None) 根据给定轴计算数组啊相关元素和 mean(a, axis=None) 期望 average(a, axis, weights=None) 加权平均值 std(a, axis=None) 标准差 var(a, axis=None) 方差 min(a) max(a) 求最小/大值 argmin(a) argmax(a) 最小/大值降一维后下标 unravel_index(index, shape) 根据shape将一维下标转换成多维下标 ptp(a) 最大值最小值的差 median(a) 中位数 Numpy的梯度函数 函数 说明 gradient(a) 计算数组a中元素的梯度，a为多维时，返回每个维度的梯度 梯度：连续值之间的变化率，即斜率 xy坐标轴连续3个x坐标对应的y值为：a，b，c，其中b的梯度为(c-a)/2 图像的数组表示123456789101112from PIL import Imageimport numpy as np#获得图像数组im = np.array(Image.open('1.jpg'))#运算并修改数组b = [255, 255, 255] -im#获取新图片im = Image.fromarray(b.astype(np.uint8))#保存图片im.save('new.jpg') 数据展示matplotlibmatplotlib库较复杂，类似于matlab。可以使用matplotlib.pyploy 123456import matplotlib.pyplot as pltplt.plot([3, 1, 4, 5, 2])plt.ylabel('grade')#保存图片plt.savefig('test', dpi=600)plt.show() 1234567#同时指定x,y值plt.plot([0, 2, 4, 6, 8],[3, 1, 4, 5, 2])#xmin,xmax,ymin,ymaxplt.axis([-1, 10, 0, 6])plt.ylabel('grade')#plt.savefig('test', dpi=600)plt.show() pyplot的绘图区域plt.subplot(nrows, ncols, plot_num) 123456789a = np.arange(0, 5, 0.02)#两行一列绘图区域的上半部分plt.subplot(2, 1, 1)plt.plot(a, np.exp(-a) * np.cos(2*np.pi*a))#两行一列绘图区域的下半部分plt.subplot(2, 1, 2)plt.plot(a, np.cos(np.pi*a))plt.show() plot函数plt.plot(x, y, format_string, **kwargs) x,y:列表或数组 format_string:控制曲线的格式字符串,由颜色，风格，标记字符组成 颜色字符 说明 ‘b’ 蓝色 ‘g’ 绿色 ‘r’ 红色 ‘c’ 青绿色 ‘#008000’ RGB的某种颜色 ‘m’ 洋红色 ‘y’ 黄色 ‘k’ 黑色 ‘w’ 白色 ‘0.8’ 灰度值 风格字符 说明 ‘-‘ 实线 ‘–’ 破折线 ‘-.’ 点划画线 ‘:’ 虚线 ‘’ ‘ ‘ 无线条 标记字符 说明 ‘.’ 点标记 ‘,’ 像素标记（极小点） ‘o’ 实心圈标记 ‘v’ 倒三角标记 ‘^’ 上三角标记 ‘&gt;’ 右三角标记 ‘&lt;’ 左三角标记 ‘1’ 下花三角标记 ‘2’ 上花三角标记 ‘3’ 左花三角标记 ‘4’ 右花三角标记 ‘s’ 实心方形标记 ‘p’ 实心五角标记 ‘*’ 星形标记 ‘h’ 竖六边形标记 ‘H’ 横六边形标记 ‘+’ 十字标记 ‘x’ x标记 ‘D’ 菱形标记 ‘d’ 瘦菱形标记 ‘ ‘ 垂直线标记 **kwargs:第二组或更多的(x, y, format_string) color:控制颜色，color=’green’ linestyle: 控制颜色，linestyle=’dashed’ marker:标记风格，marker=’o’ markerfacecolor:标记颜色，markerfacecolor=’blue’ markersize:标记尺寸,markersize=20 pyplot的中文显示 方法一：使用rcParams修改默认字体 123import matplotlibmatplotlib/rcParams['font.family'] = 'SimHei'y.tlabel('纵轴') rcParams的属性 属性 说明 ‘font.family’ 字体，’SimHei’黑体，’Kaiti’楷体，’LiSu’隶书，’Fangsong’仿宋，’YouYuan’幼圆，’STSong’华文宋体等 ‘font.style’ 字体风格，如normal,italic ‘font.szie’ 字体大小，数字或large,x-small等 方法二：使用属性fontproperties 1plt.ylabel('横轴', fontproperties='SimHei', fontsize=20) pyplot的文本显示 函数 说明 plt.xlabel() x轴标签 plt.ylabel() y轴标签 plt.title() 图形整体增加标签 plt.text() 任意位置增加文本 plt.annotate() 图形中增加带箭头的注解 详细切分绘图区域 subplot2grid 1plt.subplot2grid((3, 3), (1, 0), colspan=2) gridspec 123from matplotlib import gridspecgs = gridspec.GridSpec(3, 3)ax1 = plt.subplot(gs[0, :]) pyplot基础图表函数 函数 说明 plt.plot(x,y,fmt,…) 坐标图 plt.boxplot(data,notah,position) 箱形图 plt.bar(left,height,width,bottom) 条形图 plt.barh(width, bottom, left,height) 横向条形图 plt.polar(theta,r) 极坐标图 plt.pie(data, explode) 饼图 plt.psd(x,NFFT=256,pad_to,Fs) 功率谱密度图 plt.specgram(x,NFFT=256,pad_to,F) 谱图 plt.cohere(x,y,NFFT=256,Fs) x-y相关性函数 plt.scatter(x,y) 散点图 plt.step(x,y,where) 步阶图 plt.hist(x,bins,normed) 直方图 plt.contour(x,y,z,n) 等值图 plt.vlines() 垂直图 plt.stem(x,y,linefmt,markerfmt) 柴火图 plt.plot_date() 数据日期 饼图1234567891011#饼图labels = ['Frogs', 'Hogs', 'Dogs', 'Logs']sizes = [15, 30, 45, 10]#突出第二块explode = (0, 0.1, 0, 0)plt.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=False, startangle=90)#使得画出正圆形plt.axis('equal')plt.show() 直方图1234567#直方图np.random.seed(0)mu, sigma = 100, 20a = np.random.normal(mu, sigma, size=100)#第二个参数bin代表直方的个数（划分的区间，y为每个区间中元素的个数（normed=1）或概率(normed=1)）plt.hist(a, 40, normed=1, histtype='stepfilled', facecolor='b')plt.show() 极坐标散点图12345#散点图fig, ax = plt.subplots()#scatterax.plot(10*np.random.randn(100), 10*np.random.randn(100), 'o')plt.show() pandas库Series类型由一组数据及与之相关的索引组成 1pd.Series([9, 8, 7, 6], index=['a', 'b', 'c', 'd']) Series创建 从标量创建 1pd.Series(25, index=['a', 'b']) 从字典类型创建 1pd.Series(&#123;'a':8, 'b':7&#125;) 从ndarray创建 1pd.Seriess(np.arange(5)) 从列表创建 1pd.Series([9, 8], index=['a', 'b']) Series的基本操作索引切片等类似numpy Series的name属性对象和索引都有name属性 123b = pd.Series([9, 8], index=['a', 'b'])b.name='Series对象'b.index.name='索引列' DataFrame类型表格型数据类型 创建 二维ndarray对象 1pd.DataFrame(np.arange(10).reshape(2, 5)) 一维ndarray对象字典(或直接字典)创建123d = &#123;'one': pd.Series([1, 3, 5, 7], index=['a', 'b', 'c', 'd']), 'two': pd.Series([2, 4, 6, 8], index=['a', 'b', 'c', 'd'])&#125;p = pd.DataFrame(d) 索引行：d[]，列:d.ix[] 获取0轴索引：d.index 获取1轴索引: d.columns 索引的常用方法 append(idx) 连接另一个index对象，产生新的索引 diff(idx) 差集，并返回 intersection(idx) 交集 union(idx) 并集 delete(loc) 删除loc位置的元素 insert(loc, c) 在loc位置增加索引 数据类型操作 重新索引reindex 12345d = pd.DataFrame(&#123;'c1':[1, 3, 5], 'c2':[2, 4, 6]&#125;, index=['i1', 'i2', 'i3'])#改变行顺序d.reindex(index=['i3', 'i2', 'i1'])#改变列顺序d.reindex(columns=['c2', 'c1']) 参数– index,columns :新的行列自定义索引– fill_value : 填充缺失位置的值– method : 填充方法，ffill向前填充，bfill向后填充– limit: 最大填充量– copy : 默认True，生成新对象，为False时不复制 删除指定索引drop1234#删除0轴d.drop(['i1'])删除1轴d.drop(['c1'], axis=1) Pandas的排序根据索引进行排序sort_index(axix=0, ascending=True) 在指定轴上根据数据进行排序sort_values(by, axix=0, ascending=True) by： axis轴上的某个索引，或索引列表 NaN统一放到排序末尾 Pandas的统计分析 函数 说明 sum 计算数据综合，按0轴，下同 count 非Nan的数量 mean median 算术平均，算术中位数 var std 方差，标准差 min max 最小，最大 argmin argmax Series用，返回最值所在位置的索引（自动索引） idmin idmax 同上，返回自定义索引 describe 对0轴进行统计汇总","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python中使用IRR与XIRR","date":"2017-09-27T12:19:52.000Z","path":"2017/09/27/Python中使用IRR与XIRR/","text":"使用IRR函数可直接调用Numpy中的库函数，直接使用即可 1print(np.irr([30000, -5100, -5100, -5100, -5100, -5100, -5100])) 使用XIRR函数很遗憾，不知道为什么Numpy中没有提供该函数。 参考网上的大神：https://stackoverflow.com/questions/8919718/financial-python-library-that-has-xirr-and-xnpv-function 12345678910111213141516171819202122232425def xirr(transactions): years = [(ta[0] - transactions[0][0]).days / 365.0 for ta in transactions] residual = 1 step = 0.05 guess = 0.05 epsilon = 0.0001 limit = 10000 while abs(residual) &gt; epsilon and limit &gt; 0: limit -= 1 residual = 0.0 for i, ta in enumerate(transactions): residual += ta[1] / pow(guess, years[i]) if abs(residual) &gt; epsilon: if residual &gt; 0: guess += step else: guess -= step step /= 2.0 return guess-1from datetime import datetas = [ (date(2010, 12, 29), -10000), (date(2012, 1, 25), 20), (date(2012, 3, 8), 10100)]print(xirr(tas)) #0.0100612640381","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python常用知识点","date":"2017-09-07T02:03:03.000Z","path":"2017/09/07/Python常用知识点/","text":"删除重复字符1234567891011import re# s:输入字符串# n:重复几个的时候删除， n&gt;=2def removeSameCh(s, n): # (.)表示任意一个字符，并且组成一个分组1 # \\1表示匹配出的分组 # &#123;%d,&#125;表示重复，例如n为3的时候，则重复2次及以上 pat = r'(.)\\1&#123;%d,&#125;' % (int(n)-1) while re.search(pat, s) is not None: s = re.sub(pat, r'\\1', s) return s 读写文件123with open(fName, 'r') as f: for line in f.readlines(): print(line) 如果报错UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0x80 in position 84: illegal multibyte sequence 则将open函数修改为： 1open(fName, 'r', encoding='UTF-8') 或者使用二进制读取1open(fName, 'rb')","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"利用Python进行数据分析","date":"2017-08-22T23:32:21.000Z","path":"2017/08/23/利用Python进行数据分析/","text":"","tags":[]},{"title":"MySQL基础知识","date":"2017-08-15T13:17:50.000Z","path":"2017/08/15/深入浅出MySQL/","text":"常用命令可以通过[？CONTENTS]命令查询所有命令 DDL数据定义语言 命令作用 命令格式 创建数据库 CREATE DATABASE newdb; 显示数据库 SHOW DATABASES; 选择数据库 USE newdb; 显示表 SHOW TABLES; 删除数据库 DROP DATABASE newdb; 创建表 CREATE TABLE emp(ename VARCHAR(20), hiredata DATE, deptno INT(2)); 查看表信息 DESC emp; 查看更全面的表定义信息 SHOW CREATE TABLE emp\\G; 删除表 DROP TABLE emp; 修改表字段类型 ALTER TABLE emp MODIFY ename VARCHAR(30); 增加表字段 ALTER TABLE emp ADD age INT(5) [AFTER ename]; 删除表字段 ALTER TABLE emp DROP COLUMN age; 修改字段名字 ALTER TABLE emp CHANGE age newage INT(10); 修改字段排列顺序(ADD/CHANGE/MODIFY ) ALTER TABLE emp MODIFY newage INT(2) AFTER ename; 修改表名 ALTER TABLE emp RENAME emp2; DML数据库操作语言 命令作用 命令格式 插入记录 INSERT INTO emp (ename, hiredate, deptno) VALUES(‘kongdb’, ‘1991-05-16’, 1),(‘sss’, ‘1992-01-01’, 2); 更新记录 UPDATE emp SET ename=’new’ WHERE deptno=2; 更新多表 UPDATE emp a, dept b SET a.sal=a.sal*b.deptno WHERE a.deptno=b.deptno; 删除记录 DELETE FROM emp WHERE ename=’new’; 删除多表 DELETE a, b FROM emp a, dept b WHERE a.deptno=b.deptno AND a.deptno=1; 查询记录 SELECT * FROM emp; 查询不重复的记录 SELECT DISTINCT deptno FROM emp; 条件查询(=,&lt;,&gt;,&lt;=,&gt;=,!=,AND,OR) SELECT * FROM emp WHERE sal&gt;4000 AND deptno=4; 查询排序 SELECT * FROM emp ORDER BY sal [DESC]; 查询限制 SELECT * FROM emp LIMIT 1; 聚合操作(COUNT,SUM,MAX,MIN) SELECT [field1,field2,……fieldn] fun_nameFROM tablename[WHERE where_contition][GROUP BY field1,field2,……fieldn[WITH ROLLUP]][HAVING where_contition] 统计某个值出现次数 SELECT deptno, COUNT(1) FROM emp GROUP BY deptno; 对聚合结果再进行汇总WITH ROLLUP SELECT deptno, COUNT(1) FROM emp GROUP BY deptno WITH ROLLUP; 对统计结果再进行过滤HAVING SELECT deptno, COUNT(1) FROM emp GROUP BY deptno HAVING COUNT(1)&gt;1; 求和、最大值、最小值 SELECT SUM(sal), MAX(sal), MIN(sal) FROM emp; 内连接 SELECT ename, deptname FROM emp, dept WHERE emp.deptno=dept.deptno; 外连接（左连接）包含左边所有记录，即使右边没有 SELECT ename, deptname FROM emp LEFT JOIN dept ON emp.deptno=dept.deptno; 外连接（右连接）包含右边所有记录，即使左边没有 SELECT ename, deptname FROM emp RIGHT JOIN dept ON emp.deptno=dept.deptno; 子查询（查询所用到的条件是另一个select语句的结果）IN,NOT IN,=,!=,EXISTS,NOT EXISTS SELECT * FROM emp WHERE deptno IN (SELECT deptno FROM dept); 记录联合（UNION ALL） SELECT deptno FROM empUNION ALLSELECT deptno FROM dept; 记录联合（UNION）为[UNION ALL]再DISTINCT后的结果 SELECT deptno FROM empUNIONSELECT deptno FROM dept; DCL数据库管理语言 命令作用 命令格式 创建用户 CREATE USER ‘usr1’@’localhost’; 增加权限（GRANT） GRANT SELECT, INSERT ON newdb.* TO ‘usr1’@’localhost’; 解除权限（REVOKE） REVOKE INSERT ON newdb.* FROM ‘usr1’@’localhost’; MySQL支持的数据类型数值类型 整数类型 字节 最小值 最大值 TINYINT 1 有符号-128无符号 0 有符号 127无符号 255 SMALLINT 2 有符号-32768无符号 0 有符号 32767无符号 65535 MEDIUMINT 3 有符号-8388608无符号 0 有符号 8388607无符号 1677215 INT、INTEGER 4 有符号-2147483648无符号 0 有符号 2147483647无符号 4294967295 BIGINT 8 有符号-9223372036854775808无符号 0 有符号 9223372036854775807无符号 18446744073709551615 浮点数类型 字节 最小值 最大值 FLOAT 4 ±1.175494351E-38 ±3.402823466E+38 DOUBLE 8 ±2.2250738585072014E-308 ±1.7976931348623157E+308 定点数类型 字节 描述 DEC(M,D)，DECIMAL(M,D) M+2 最大取值范围与DOUBLE 相同，给定DECIMAL 的有效取值范围由M 和D决定 浮点数类型 字节 最小值 最大值 BIT(M) 1～8 BIT(1) BIT(64) 整数类型指定显示宽度1CREATE TABLE t1(id INT(5)); 则id的宽度指定为5（不指定时默认为INT(11)） 1ALTER TABLE t1 MODIFY id INT(5) ZEROFILL; 设置ZEROFILL则宽度不足时自动补0，指定ZEROFILL时会为该列自动添加UNSIGNED属性 AUTO_INCREMENT属性可利用此属性设置某列为自增 设置方法 123CREATE TABLE t2(id INT AUTO_INCREMENT NOT NULL PRIMARY KEY);CREATE TABLE t2(id INT AUTO_INCREMENT NOT NULL, PRIMARY KEY(id));CREATE TABLE t2(id INT AUTO_INCREMENT NOT NULL, UNIQUE(id)); 定点数（M,D）M表示所有数字位数（整数+小数），D表示小数位数字 DECIMAL不指定精度时，默认为(10,0) BIT(M)类型M为1到64，不写则默认为1 SELECT结果默认看不到BIT类型，可用BIN(二进制格式)，HEX(16进制格式)进行读取 1SELECT BIN(id), HEX(id) FROM t2; 日期时间类型常见类型 日期和时间类型 字节 最小值 最大值 DATE 4 1000-01-01 9999-12-31 DATETIME 8 1000-01-01 00:00:00 9999-12-31 23:59:59 TIMESTAMP 4 19700101080001 2038 年的某个时刻 TIME 3 -838:59:59 838:59:59 YEAR 1 1901 2155 TIME_STAMP 系统默认给该列创建CURRENT_TIMESTAMP默认值 和时区相关，当插入日期时，会先转换为本地时区后存放；而从数据库里面取出时，也同样需要将日期转换为本地时区后显示。 超过取值范围会被置为0000-00-00 00:00:00 YEARMySQL 以YYYY 格式检索和显示YEAR 值，范围是1901～2155。当使用两位字符串表示年份时，其范围为“00”到“99”。 “00”到“69”范围的值被转换为2000～2069 范围的YEAR 值 “70”到“99”范围的值被转换为1970～1999 范围的YEAR 值。 DATETIME合法的格式有 1234INSERT INTO t VALUES('1991-05-16 12:21:10');INSERT INTO t VALUES('91/05/16 12:21:10');INSERT INTO t VALUES('910516122110');INSERT INTO t VALUES(910516122110); 字符串类型 字符串类型 字节 描述及字符串存储需求 CHAR（M） M M 为0～255 之间的整数 VARCHAR（M） M 为0～65535 之间的整数，值的长度+1 个字节 TINYBLOB 允许长度0～255 字节，值的长度+1 个字节 BLOB 允许长度0～65535 字节，值的长度+2 个字节 MEDIUMBLOB 允许长度0～167772150 字节，值的长度+3 个字节 LONGBLOB 允许长度 0～4294967295 字节，值的长度+4 个字节 TINYTEXT 允许长度0～255 字节，值的长度+2 个字节 TEXT 允许长度0～65535 字节，值的长度+2 个字节 MEDIUMTEXT 允许长度0～167772150 字节，值的长度+3 个字节 LONGTEXT 允许长度 0～4294967295 字节，值的长度+4 个字节 VARBINARY（M） 允许长度0～M 个字节的变长字节字符串，值的长度+1 个字节 BINARY（M） M 允许长度0～M 个字节的定长字节字符串 CHAR和VARCHAR用来保存较短的字符串，CHAR的长度为声明的长度，VARCHAR为可变长 BINARY 和VARBINARY保存二进制字符串，对于BINARY定长类型，长度不够时填充’\\0’ ENUM枚举类型，值范围需要在创建表时通过枚举方式显式指定。最多允许有65535 个成员。 示例： 12CREATE TABLE t (e ENUM('M','F'));INSERT INTO t VALUES('M'),('F'),(NULL); 注：在MySQL5.7.19上插入不存在的ENUM中的值时，提示“Data truncated for column” SET可以保护0~64个成员，一次可以选取多个成员 示例 12CREATE TABLE t (s SET('A','B','C','D'));INSERT INTO t VALUES('A,B,A'),('D,A'),('C'); MySQL运算符算术运算符 运算符 作用 + 加法 - 减法 * 乘法 /，DIV 除法，返回商 %，MOD 除法，返回余数 比较运算符 运算符 作用 = 等于 &lt;&gt;或!= 不等于 &lt;=&gt; NULL 安全的等于(NULL-safe) &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 存在与指定范围 IN 存在于指定集合 IS NULL 为NULL IS NOT NULL 不为NULL LIKE 通配符匹配 REGEXP 或RLIKE 正则表达式匹配 &lt;=&gt;运算符[NULL &lt;=&gt; NULL]的结果为1 BETWEEN运算符[10 BETWEEN 10 AND 20]的结果为1，，等价于a&gt;=min and a&lt;=max LIKE和REGEXP[123456 LIKE ‘123%’]的结果为1 格式为[str REGEXP str_pat]，当str 字符串中含有str_pat相匹配的字符串时，则返回值为1 逻辑运算符 运算符 作用 NOT 或！ 逻辑非 AND 或&amp;&amp; 逻辑与 OR 或 \\ \\ 逻辑或 XOR 逻辑异或 位运算符 运算符 作用 &amp; 位与（位AND） \\ 位或 （位OR ） ^ 位异或（位 XOR） ~ 位取反 &gt;&gt; 位右移 &lt;&lt; 位左移 常用函数字符串函数 函数 功能 CANCAT(S1,S2,…Sn) 连接S1,S2,…Sn 为一个字符串 INSERT(str,x,y,instr) 将字符串str 从第x 位置开始，y 个字符长的子串替换为字符串instr LOWER(str) 将字符串str 中所有字符变为小写 UPPER(str) 将字符串str 中所有字符变为大写 LEFT(str ,x) 返回字符串str 最左边的x 个字符 RIGHT(str,x) 返回字符串str 最右边的x 个字符 LPAD(str,n ,pad) 用字符串pad 对str 最左边进行填充，直到长度为n 个字符长度 RPAD(str,n,pad) 用字符串pad 对str 最右边进行填充，直到长度为n 个字符长度 LTRIM(str) 去掉字符串str 左侧的空格 RTRIM(str) 去掉字符串str 行尾的空格 REPEAT(str,x) 返回str 重复x 次的结果 REPLACE(str,a,b) 用字符串b 替换字符串str 中所有出现的字符串a STRCMP(s1,s2) 比较字符串s1 和s2 TRIM(str) 去掉字符串行尾和行头的空格 SUBSTRING(str,x,y) 返回从字符串str x 位置起y 个字符长度的字串 数值函数 函数 功能 ABS(x) 返回x 的绝对值 CEIL(x) 返回大于x 的最大整数值 FLOOR(x) 返回小于x 的最大整数值 MOD(x，y) 返回x/y 的模 RAND() 返回0 到1 内的随机值 ROUND(x,y) 返回参数x 的四舍五入的有y 位小数的值 TRUNCATE(x,y) 返回数字x 截断为y 位小数的结果 日期和时间函数 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前的日期和时间 UNIX_TIMESTAMP(date) 返回日期date 的UNIX 时间戳 FROM_UNIXTIME 返回UNIX 时间戳的日期值 WEEK(date) 返回日期date 为一年中的第几周 YEAR(date) 返回日期date 的年份 HOUR(time) 返回time 的小时值 MINUTE(time) 返回time 的分钟值 MONTHNAME(date) 返回date 的月份名 DATE_FORMAT(date,fmt) 返回按字符串fmt 格式化日期date 值 DATE_ADD(date,INTERVAL expr type) 返回一个日期或时间值加上一个时间间隔的时间值 DATEDIFF(expr,expr2) 返回起始时间expr 和结束时间expr2 之间的天数 DATE_FORMAT(date,fmt)函数按字符串fmt 格式化日期date 值 示例 12SELECT DATE_FORMAT(NOW(), '%M,%D,%Y');-&gt; August,20th,2017 日期的格式 格式符 格式说明 %S,%s 两位数字形式的秒（00,01,…,59） %i 两位数字形式的分（00,01,…,59） %H 两位数字形式的小时，24 小时（00,01,…,23） %h,%I 两位数字形式的小时，12 小时（01,02,…,12） %k 数字形式的小时，24 小时（0,1,…,23） %l 数字形式的小时，12 小时（1,2,…,12） %T 24 小时的时间形式（hh:mm:ss） %r 12 小时的时间形式（hh:mm:ssAM 或hh:mm:ssPM） %p AM 或PM %W 一周中每一天的名称（Sunday,Monday,…,Saturday） %a 一周中每一天名称的缩写（Sun,Mon,…,Sat） %d 两位数字表示月中的天数（00,01,…,31） %e 数字形式表示月中的天数（1,2，…,31） %D 英文后缀表示月中的天数（1st,2nd,3rd,…） %w 以数字形式表示周中的天数（0=Sunday,1=Monday,…,6=Saturday） %j 以3 位数字表示年中的天数（001,002,…,366） %U 周（0,1,52），其中Sunday 为周中的第一天 %u 周（0,1,52），其中Monday 为周中的第一天 %M 月名（January,February,…,December） %b 缩写的月名（January,February,…,December） %m 两位数字表示的月份（01,02,…,12） %c 数字表示的月份（1,2,…,12） %Y 4 位数字表示的年份 %y 两位数字表示的年份 %% 直接值“%” DATE_ADD(date,INTERVAL expr type)函数返回与所给日期date 相差INTERVAL 时间段的日期。 示例 121分1秒后的时间SELECT DATE_ADD(NOW(), INTERVAL '1:1' MINUTE_SECOND); 表达式类型 描述 格式 HOUR 小时 hh MINUTE 分 mm SECOND 秒 ss YEAR 年 YY MONTH 月 MM DAY 日 DD YEAR_MONTH 年和月 YY-MM DAY_HOUR 日和小时 DD hh DAY_MINUTE 日和分钟 DD hh:mm DAY_ SECOND 日和秒 DD hh:mm:ss HOUR_MINUTE 小时和分 hh:mm HOUR_SECOND 小时和秒 hh:ss MINUTE_SECOND 分钟和秒 mm:ss 流程函数 函数 功能 IF(value,t f) 如果value 是真，返回t；否则返回f IFNULL(value1,value2) 如果value1 不为空返回value1，否则返回value2 CASE WHEN [value1]THEN[result1]…ELSE[default]END 如果value1 是真，返回result1，否则返回default CASE [expr] WHEN [value1]THEN[result1]…ELSE[default]END 如果expr 等于value1，返回result1，否则返回default 其他常用函数 函数 功能 DATABASE() 返回当前数据库名 VERSION() 返回当前数据库版本 USER() 返回当前登录用户名 INET_ATON(IP) 返回IP 地址的数字表示 INET_NTOA(num) 返回数字代表的IP 地址 PASSWORD(str) 返回字符串str 的加密版本 MD5() 返回字符串str 的MD5 值 INET_ATON(IP)函数返回IP 地址的网络字节序表示 示例 12SELECT INET_ATON('192.168.0.1');-&gt; 3232235521 INET_NTOA(num)函数返回网络字节序代表的IP 地址 示例 12SELECT INET_NTOA(3232235521);-&gt; 192.168.0.1 MD5(str)函数返回字符串str 的MD5 值，常用来对应用中的数据进行加密。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"IRR与XIRR","date":"2017-08-13T12:43:51.000Z","path":"2017/08/13/IRR与XIRR/","text":"IRR函数说明一系列现金流的内部收益率，现金流数额不必相等，但是必须是定期出现的（如每周或每月） 语法IRR(values, [guess]) 参数说明如下 Values 必需。 数组或单元格的引用，这些单元格包含用来计算内部收益率的数字。 Values 必须包含至少一个正值和一个负值，以计算返回的内部收益率。 IRR 使用值的顺序来说明现金流的顺序。 一定要按您需要的顺序输入支出值和收益值。 如果数组或引用包含文本、逻辑值或空白单元格，这些数值将被忽略。 Guess 可选。 对函数 IRR 计算结果的估计值。 Microsoft Excel 使用迭代法计算函数 IRR。 从 guess 开始，IRR 不断修正计算结果，直至其精度小于 0.00001%。 如果 IRR 运算 20 次，仍未找到结果，则返回 错误值 #NUM!。 多数情况下，不必为 IRR 计算提供 guess 值。 如果省略 guess，则假定它为 0.1 (10%)。 如果 IRR 返回 错误值 #NUM!，或结果不接近您预期的值，可用另一个 guess 值重试。 示例1、一开始投入一笔资金，每年取得一定收入，计算收益率 数据 说明 -70000 成本费用 12000 第一年净收入 15000 第二年净收入 18000 第三年净收入 21000 第四年净收入 26000 第五年净收入 8.66% 五年后的内部收益率( =IRR(A2:A7) ) 2、一开始借了一笔钱，每月还一部分，计算借款实际利率 比如和银行借了30000元，每月还5100，分6个月还 时间 现金流 - 30000 第一个月 -5100 第二个月 -5100 第三个月 -5100 第四个月 -5100 第五个月 -5100 第六个月 -5100 每月利率（=IRR(B2:B8)） 0.57% 年化利率 （=(1+IRR(B2:B8))^12-1） 7.04% 3、每月定投一笔钱，一段时间后计算平均收益 时间 定投资金 第一个月初 -10000 第二个月初 -10000 第三个月初 -10000 第四个月初 -10000 第五个月初 -10000 第六个月初 -10000 第六个月末余额 63000 每月利率（=IRR(B2:B8)） 1.4% 年化利率 （=(1+IRR(B2:B8))^12-1） 18.1% 哇塞，实际年化好吓人 XIRR函数说明用于计算不一定定期发生的现金流的内部收益率 语法XIRR(values, dates, [guess]) 参数说明如下 值 必需。 与 dates 中的支付时间相对应的一系列现金流。 首期支付是可选的，并与投资开始时的成本或支付有关。 如果第一个值是成本或支付，则它必须是负值。 所有后续支付都基于 365 天/年贴现。 值系列中必须至少包含一个正值和一个负值。 日期 必需。 与现金流支付相对应的支付日期表。 日期可按任何顺序排列。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题 。 Guess 可选。 对函数 XIRR 计算结果的估计值。 示例1、一开始投入一笔钱，不定期获得收益 现金流 日期 -10000 2008-1-1 2750 2008-3-1 4250 2008-10-30 3250 2009-2-15 2750 2009-4-1 年化收益率(=XIRR(A2:A6, B2:B6)) 37.34% 2、每月不定期定投 现金流 日期 -3000 2016-1-14 -3000 2016-1-10 -5000 2016-3-6 -10000 2016-8-10 -10000 2016-10-10 32850 2016-10-30 年化收益率(=XIRR(A2:A2, B2:B7)) 17.51% 参考链接微信公众号：越女事务所 IRR 官方说明： https://support.office.com/zh-CN/article/IRR-%E5%87%BD%E6%95%B0-64925EAA-9988-495B-B290-3AD0C163C1BC XIRR官方说明： https://support.office.com/zh-CN/article/XIRR-%E5%87%BD%E6%95%B0-DE1242EC-6477-445B-B11B-A303AD9ADC9D","tags":[{"name":"IRR","slug":"IRR","permalink":"http://yoursite.com/tags/IRR/"}]},{"title":"试题解答","date":"2017-08-09T12:10:02.000Z","path":"2017/08/09/试题解答/","text":"题目11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#-*- coding: utf-8 -*-import pandas as pdimport numpy as npimport os#逐块读取，每块的sizeCHUNK_SIZE = 1000#空年龄的keyNULL_KEY = -1def readDataFromFile(fName): if not os.path.exists(fName): print(\"请确认文件是否存在, 路径：%s\" % fName) return #逐块的迭代器，header=0表示忽略第一行的表头 chunker = pd.read_table(fName, sep='\\s+', header=0, chunksize=CHUNK_SIZE) #结果的列表 result = &#123;&#125; #行号 line = 0 for piece in chunker: #年龄的列表 ages = piece.age.values #年龄是否为空的列表，空则为False isEmptyAge = piece.age.isnull().values for i in range(len(ages)): line = line + 1 if isEmptyAge[i]: result[NULL_KEY] = (result[NULL_KEY] + 1 if NULL_KEY in result else 1) else: try: key = int(ages[i]) result[key] = (result[key] + 1 if key in result else 1) except: print('***错误！数据的第%d行，年龄不是整数数字***' % line) return resultdef saveResultToFile(fName, result): with open(fName, 'w') as f: f.write('年龄 人数\\n') #给年龄排个序 ages = list(result.keys()) ages.sort() for age in ages: if age == NULL_KEY: f.write('未知 %d\\n' % result[age]) else: f.write('%d %d\\n' % (age, result[age]))if __name__ == '__main__': inFile = 'E:/info.txt' outFile = 'E:/result.txt' result = readDataFromFile(inFile) if not result is None: saveResultToFile(outFile, result) 题目212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding: utf-8 -*-import unittestdef checkListFormat(lData): if not isinstance(lData, list) or len(lData) != 2: print('数据格式错误') return False for i in lData: if not isinstance(i, int): print('数据格式错误') return False if not lData[0] &lt; lData[1]: print('数据格式错误') return False return Truedef insertList(before, inData): if not checkListFormat(inData): return if not isinstance(before, list): return for i in before: if not checkListFormat(i): return n = len(before) startIndex = n endIndex = n for i in range(n): if inData[0] &gt; before[i][1]: continue startIndex = i break for i in range(n): if inData[1] &gt; before[i][0]: continue endIndex = i - 1 break #startIndex为n说明待插入值的最小值都比原列表发最后一个值大 newBegin = (inData[0] if startIndex == n else min(inData[0], before[startIndex][0])) newEnd = 0 if endIndex == -1: #待插入值的最大值都比原列表第一个值大 newEnd = inData[1] elif endIndex == n: #需要比较两个列表最后一个值 newEnd = max(inData[1], before[n-1][1]) else: newEnd = max(inData[1], before[endIndex][1]) for i in range(startIndex, min(endIndex+1, n)): before.pop(startIndex) before.insert(startIndex, [newBegin, newEnd]) return beforeclass TestInsert(unittest.TestCase): def test_insertList(self): self.assertEqual(insertList([[1, 3], [6, 9]], [2, 5]), [[1, 5], [6, 9]]) self.assertEqual(insertList([[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], [4, 9]), [[1, 2], [3, 10], [12, 16]]) self.assertEqual(insertList([[6, 9], [10, 11]], [1, 3]), [[1, 3], [6, 9], [10, 11]]) self.assertEqual(insertList([[6, 9], [10, 11]], [19, 32]), [[6, 9], [10, 11], [19, 32]]) self.assertEqual(insertList([[6, 9], [10, 13]], [3, 8]), [[3, 9], [10, 13]]) self.assertEqual(insertList([[6, 9], [10, 13]], [12, 17]), [[6, 9], [10, 17]]) self.assertEqual(insertList([[6, 9], [10, 13]], [11, 12]), [[6, 9], [10, 13]])if __name__ == '__main__': unittest.main()","tags":[]},{"title":"Python金融大数据分析学习笔记","date":"2017-07-26T13:49:28.000Z","path":"2017/07/26/Python金融大数据分析学习笔记/","text":"Python常用工具IPython Notebook说明: 本地Web短编写调试Python代码 安装方法: pip install juputer 运行: jupyter notebook Python quant-platform说明: Web浏览器的金融分析和协作平台，环境已经配置好 地址: http://analytics.quant-platform.com Anaconda说明: 拥有科学计算的Python发行版，提供了包管理和环境管理功能，可以方便地解决多版本Python共存的问题 数据类型和结构基本数据类型浮点数精确地存储12c = 0.5c.as_integer_ratio() decimal 模块1234567import decimalfrom decimal import Decimald = Decimal(1) / Decimal(11) #28位decimal.getcontext().prec = 50d = Decimal(1) / Decimal(11) #50位 函数式编程filter,map,reduce12345def even(x): return x % 2 == 0a = map(even, range(10)) #迭代器[x for x in a] #[True, False, True, False, True, False, True, False, True, False] 使用lamda函数 1map(lamda x: x ** 2, ) filter:筛选匹配函数布尔值的元素 12a = filter(even, range(10))[x for x in a] #[0, 2, 4, 6, 8] reduce:归纳列表 求列表和的例子12from functools import reducereduce(lambda x, y: x+ y, range(15)) Python 字符串逆序12s = \"123你好世界def\"s[::-1] str[begin:end:step] step 默认值为1 深层拷贝deepcopy的运用1234a = [0.5, 1]b = aa[0] = 3b #[3, 1] 12345from copy import deepcopya = [0.5, 1]b = deepcopy(a)a[0] = 3b #[0.5, 1] 参考：https://iaman.actor/blog/2016/04/17/copy-in-python","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python安装MySQL-Python库","date":"2017-07-22T11:48:05.000Z","path":"2017/07/22/Python安装MySQL-Python库/","text":"Python2.7安装MySQL-Python直接执行pip命令1pip2 install MySQL-Python 报错_mysql.c(42) : fatal error C1083: Cannot open include file: ‘config-win.h’: No such file or directory 安装mysql-connector-curl: https://dev.mysql.com/downloads/connector/c/6.0.html 下载相应的版本，比如64位的windows则下载： mysql-connector-c-6.0.2-winx64.msi 默认安装即可 再次执行pip命令还是同样的错误，去mysql-connector-c的安装目录下查找，config-win.h文件确实已经有了。 奇怪，把目录设到环境变量Path中也不行。既然是编译的时候报错了，是不是驾驶INCLUDE目录就行了呢？ 设置编译INCLUDE和LIB目录cmd输入 12SET INCLUDE=C:\\Program Files\\MySQL\\MySQL Connector C 6.0.2\\includeSET LIB=C:\\Program Files\\MySQL\\MySQL Connector C 6.0.2\\lib\\opt 再次执行pip，安装成功 Python3安装MySQL-Python安装上面同样的方法之后，还是报错 mysqlclient.lib中函数undefined，暂时不知道怎么解决。","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Python核心编程学习笔记","date":"2017-07-12T14:08:46.000Z","path":"2017/07/12/Python核心编程学习笔记/","text":"正则表达式常见正则表达式符号和字符 表示法 描述 示例 literal 匹配字符串字面值 re.match(‘foo’, ‘food’) re1 re2 匹配正则表达式re1或者re2 re.match(‘ab\\ cd’, ‘abd’) . 匹配任何字符（除了\\n之外） re.match(‘.e’, ‘de’) ^ 匹配字符串起始部分 re.match(‘^Dear’, ‘Dear my baby’) $ 匹配字符串的终止部分 re.search(‘baby$’, ‘Dear my baby’) * 匹配0次或多次前面出现的正则表达式 re.search(‘ba*b’, ‘Dear my baby’) + 匹配1次或多次前面出现的正则表达式 re.search(‘\\w+.com’, ‘http://ww.baidu.com‘) ? 匹配0次或1次前面出现的正则表达式 re.search(r’b\\w?.com’, ‘http://ww.ba.com‘) {n} 匹配n次前面出现的正则表达式 re.search(r’[0-9]{3}’, ‘87a45b775c’) {m, n} 匹配m到n次前面出现的正则表达式 re.search(r’[0-9]{2,3}’, ‘87a45b775c’) [x-y] 匹配x~y范围内的任意”单一字符” re.search(‘[a-z]’, ‘123ACFdGH’) [^…] 不匹配此字符集中出现的任意字符 re.search(‘[^A-Z]’, ‘ASDG1KL’) (…) 匹配封闭的正则表达式，并另存为子组 re.search(‘([A-Z]{3}).([0-9]{3})’, ‘ASDG123’).group() \\d 匹配任何十进制数，同[0-9]，与\\D相反 re.search(r’\\d’, ‘ASDG123’) \\w 匹配任何字母数字下划线，同[A-Za-z0-9_]，与\\W相反 re.search(r’\\w’, ‘:”@#$a_+’) \\s 匹配任何空格字符，与[\\n\\t\\v\\f]同，与\\S相反 re.search(r’\\s’, ‘:”abc def’) \\b 匹配任何边界字符，与\\B相反 re.search(r’\\bThe\\b’, ‘:”They is not The’) \\N 匹配已保存的子组，其中N为1,2… price:\\16 \\c 匹配特殊字符 .,\\,* 网络编程TCP示例代码tcp服务器 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-from socket import *from time import ctimeHOST = ''PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)tcpSerSock = socket(AF_INET, SOCK_STREAM)tcpSerSock.bind(ADDR)tcpSerSock.listen(5)while True: print(\"waiting for connection...\") tcpCliSock, addr = tcpSerSock.accept() print('...connected from :', addr) while True: data = tcpCliSock.recv(BUFSIZE) if not data: break #tcpCliSock.send(bytes('hello', 'utf-8')) sendData = '[%s] %s' % (ctime(), data.decode('utf-8')) tcpCliSock.send(bytes(sendData, 'utf-8')) tcpCliSock.close()tcpSerSock.close() tcp客户端 12345678910111213141516171819202122# -*- coding: utf-8 -*-from socket import *HOST = '127.0.0.1'PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)tcpClt = socket(AF_INET, SOCK_STREAM)tcpClt.connect(ADDR)while True: data = input('&gt; ') if not data: break tcpClt.send(bytes(data, 'utf-8')) data = tcpClt.recv(BUFSIZE) if not data: break print(data.decode('utf-8'))tcpClt.close() udp服务器 123456789101112131415161718from socket import *from time import ctimeHOST = ''PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)udpSerSock = socket(AF_INET, SOCK_DGRAM)udpSerSock.bind(ADDR)while True: print('waiting for message ...') data, addr = udpSerSock.recvfrom(BUFSIZE) sendData = '[%s] %s' % (ctime(), data.decode('utf-8')) udpSerSock.sendto(bytes(sendData, 'utf-8'), addr) print('...received from and returned to :', addr)udpSerSock.close() udp客户端 123456789101112131415161718from socket import *HOST = '127.0.0.1'PORT = 21567BUFSIZE = 1024ADDR = (HOST, PORT)udpCltSock = socket(AF_INET, SOCK_DGRAM)while True: data = input('&gt; ') if not data: break udpCltSock.sendto(bytes(data, 'utf-8'), ADDR) data, addr = udpCltSock.recvfrom(BUFSIZE) if not data: break print(data)udpCltSock.close() Web客户端和服务器urlparse模块注：以下皆以Python3为例 urlparse 1234from urllib.parse import urlparseurlparse(\"http://www.baidu.com\")OUT: ParseResult(scheme='http', netloc='www.baidu.com', path='', params='', query='', fragment='') urlunparse 123456from urllib.parse import urlparsefrom urllib.parse import urlunparseo = urlparse(\"http://www.baidu.com\")urlunparse(o)OUT: 'http://www.baidu.com' urljoin 将两个文件结合起来，但是不包括前一个文件的末端文件名 1234from urllib.parse import urljoinurljoin(\"http://www.baidu.com/doc/faq.html\", \"test/a/1.html\")OUT: 'http://www.baidu.com/doc/test/a/1.html'","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"日常记录备忘","date":"2017-07-01T07:38:26.000Z","path":"2017/07/01/日常记录备忘/","text":"系统同时配置了py2和py3环境，运行rf脚本无反应因为ride不支持py3，只能使用py2需要将Python27\\Scripts\\pybot.bat中[python]替换为[python2] 使用uiautomatorviewer.bat时提示unable connect to adb修改前： -Dcom.android.uiautomator.bindir=%prog_dir% 修改后： -Dcom.android.uiautomator.bindir=%ANDROID_HOME%\\tools android相关命令获取已安装的应用的包名adb shell pm list packages 获取包名对应的路径adb shell pm path com.huawei.ca 其中com.huawei.ca为相应的包名 查看已安装应用的Activity先打开应用，再输入以下命令 adb shell dumpsys window w |findstr \\/ | findstr name= 或者： adb shell dumpsys window windows | findstr mFocusedApp","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python爬虫学习笔记","date":"2017-06-28T12:05:49.000Z","path":"2017/06/28/Python爬虫学习笔记/","text":"Requests库的使用安装pip3 install requests 使用获取百度首页的内容1234import requestsr = requests.get(\"http://www.baidu.com\")r.encoding = \"utf-8\"print(r.text) 主要API request “集大成者”，可构造以下的各个请求。 get 获取页面内容的接口，对应于HTTP的GET 函数完整定义如下： 123456789101112def get(url, params=None, **kwargs): r\"\"\"Sends a GET request. :param url: URL for the new :class:`Request` object. :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`. :param \\*\\*kwargs: Optional arguments that ``request`` takes. :return: :class:`Response &lt;Response&gt;` object :rtype: requests.Response \"\"\" kwargs.setdefault('allow_redirects', True) return request('get', url, params=params, **kwargs) 注释部分已将各个参数及返回值含义解释清楚。 get函数返回的Response对象包含了爬虫返回的全部内容。主要包括 属性 说明 status_code 请求的状态码，200表示连接成功，404表示连接失败 text 响应内容的字符串形式 encoding 从header中取得的内容编码方式 apparent_encoding 从内容中分析出的响应内容的编码方式 content 响应内容的二进制形式 爬取网页的一般框架 1234567891011121314import requestsdef getHTMLText(url): try: r = requests.get(url) r.raise_for_status() #非正常状态，如404时，会产生异常 r.encoding = r.apparent_encoding return r.text except: return \"产生异常\"if __name__ == \"__main__\": url = \"http://www.baidu.com\" print(getHTMLText(url)) head 获取页面头信息的接口，对应于HTTP的HEAD 优势：网络流量小 123import requestsr = requests.head(\"http://www.baidu.com\")print(r.headers) post 向网页提交POST请求的接口，对应于HTTP的POST 1234import requestspayload = &#123;\"key1\" : \"value1\", \"key2\" : \"value2\"&#125;r = requests.post(\"http://httpbin.org/post\", data=payload)print(r.text) put 向网页提交PUT请求的接口，对应于HTTP的PUT 与post类似，会将原有的数据覆盖 1234import requestspayload = &#123;\"key1\" : \"value1\", \"key2\" : \"value2\"&#125;r = requests.put(\"http://httpbin.org/put\", data=payload)print(r.text) patch 向网页提交局部修改请求的接口，对应于HTTP的PATCH delete 向网页提交删除请求的接口，对应于HTTP的DELETE","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Win10下py2和py3共存","date":"2017-06-28T11:40:53.000Z","path":"2017/06/28/Win10下py2和py3共存/","text":"安装Python2和Python3从官网分别下载Python2.x和Python3.x版本的程序进行安装。安装方法略。 并将分别将Python加入到环境变量中。安装正确的话，环境变量中应当存在以下值。 path\\to\\Python27 path\\to\\Python27\\Scripts path\\to\\Python36 path\\to\\Python36\\Scripts 将Python27根目录下的python.exe,pythonw.exe分别重命名为python2.exe,python2w.exe 将Python36根目录下的python.exe,pythonw.exe分别重命名为python3.exe,python3w.exe cmd执行命令python2和python3查看是否成功 pip2和pip3设置cmd分别执行以下命令： python3 -m pip install –upgrade pip –force-reinstall python2 -m pip install –upgrade pip –force-reinstall 安装成功之后，可通过[pip2 install xxx]和[pip3 install xxx]来安装各自的包啦！","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"vi常用命令","date":"2017-06-27T13:43:16.000Z","path":"2017/06/27/vi常用命令/","text":"三种模式vi总共有三种模式，命名方法不一，暂且命名为 默认模式 命令模式 编辑模式 三种模式之间的切换及主要功能如下图所示： *使用vi命令时，最初始进入的即为默认模式 常用命令默认模式翻页[Ctrl+u] 向前翻半屏 [Ctrl+d] 向后翻半屏 [Ctrl+f] 向前翻一屏 [Ctrl+b] 向后翻一屏 移动光标[h] 向左移动光标（类似于左键） [j] 向下移动光标（类似于下键） [k] 向上移动光标（类似于上键） [l] 向右移动光标（类似于右键） [0] 移动光标到行首（类似于Home键） [$] 移动光标到行首（类似于End键） [G] 移动光标到末行行首 [nG] 移动光标到第n行行首，n为1,2,3… [gg] 移动光标到首行行首,类似于[1G] [1+Enter] 光标向下移动n行至行首 删除文本[x] 删除光标后的一个字符（X为向前删除一个字符） [dd] 删除光标在的一整行 [ndd] 删除光标所在行在内向后的n行。n为1,2,3… 复制粘贴[yy] 复制光标所在行 [nyy] 复制光标所在行在内向后的n行。n为1,2,3… [p] 粘贴复制的内容到所在行的下一行（P为粘贴到上一行） 撤销重复[u] 撤销上次操作（类似普通编辑器常用的Ctrl+z） [.] 重复上次的操作（不论上一次是什么操作） 命令模式查找[/word] 向下查找字符串 [?word] 向上查找字符串 [n] 查找下一个，若查找命令[/]则为向下查找，若为[?]则为向上查找（N正好相反） 行号[:set number] 左侧显示行号 [:set nonumber] 左侧不显示行号 保存退出[:w] 保存文件 [:w!] 若文件为只读，强制保存文件 [:q] 离开vi，若有修改未保存，会有警告 [:q!] 强制退出vi [:wq] 保存后退出vi [:wq!] 强制保存后退出vi [:w newfilename] 另存为 编辑模式[i] 从当前光标所在处插入[a] 从当前光标的下一个字符处插入[o] 从当前光标的下一行插入","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"vi","slug":"vi","permalink":"http://yoursite.com/tags/vi/"}]},{"title":"Hello World","date":"2017-06-24T13:45:47.239Z","path":"2017/06/24/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]